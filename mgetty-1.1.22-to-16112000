diff -urP mgetty-1.1.22/COPYING mgetty-current/COPYING
--- mgetty-1.1.22/COPYING	Thu Jan  1 01:00:00 1970
+++ mgetty-current/COPYING	Thu Nov 16 11:41:53 2000
@@ -0,0 +1,339 @@
+              GNU GENERAL PUBLIC LICENSE
+                 Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                          675 Mass Ave, Cambridge, MA 02139, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                   Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+              GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                   NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+               END OF TERMS AND CONDITIONS
+
+         How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urP mgetty-1.1.22/README.1st mgetty-current/README.1st
--- mgetty-1.1.22/README.1st	Tue Jul 18 22:27:49 2000
+++ mgetty-current/README.1st	Thu Nov 16 11:41:37 2000
@@ -11,6 +11,8 @@
 http://www.leo.org/~doering/mgetty/index.html. You'll find 
 all the documentation and the FAQ nicely formatted there.
 
+For voice stuff, look into voice/doc/readme.Beginners.
+
 
 My license policy boils down to this:
 --------------------------------------------------------------------------
diff -urP mgetty-1.1.22/TODO mgetty-current/TODO
--- mgetty-1.1.22/TODO	Mon Aug 14 21:21:17 2000
+++ mgetty-current/TODO	Thu Nov 16 11:41:37 2000
@@ -214,8 +214,7 @@
      and do vhangup() stuff
 
 180) switch from policy.h-dist to policy.h with "reasonable defaults"
-
-183) change license to GPL?
+240) do away with policy.h, make everything run-time configurable
 
 184) make sendfax choose fax device in a "random" fashion (avoid 
      problems when the first modem in a "hunt group" dies (NO DIALTONE))
@@ -234,8 +233,6 @@
 
 191) watchit.pl: make "remail" smarter
 
-192) make "max. fax speed" configuration file parameter
-
 193) makelock: check for existance of lock file *directory*, complain
      (loudly, L_FATAL!) if it doesn't exist.
 
@@ -336,4 +333,9 @@
 
 239) make utmp entry (CallerId/Connect) configurable from mgetty.config
 
-240) do away with policy.h, make everything run-time configurable
+241) cnd-program rework (more return codes, call after first RING)
+
+242) document callback and login.conf v2
+
+243) fix page lengths while sending (integrate in "send G3 file with
+     byte padding" that's necessary for class 1 anyway)
diff -urP mgetty-1.1.22/cnd.c mgetty-current/cnd.c
--- mgetty-1.1.22/cnd.c	Thu Aug 10 22:37:16 2000
+++ mgetty-current/cnd.c	Thu Nov 16 11:41:37 2000
@@ -1,4 +1,4 @@
-#ident "@(#)cnd.c	$Id$ Copyright (c) 1993 Gert Doering/Chris Lewis"
+#ident "@(#)cnd.c	$Id$ Copyright (c) 1993 Gert Doering/Chris Lewis"
 
 #include <stdio.h>
 #include <string.h>
@@ -84,6 +84,9 @@
 
     /* Kortex Adaptix 56000 (Quercia Michel, quercia@cal.enst.fr) */
     {"NBR=",			&CallerId},
+
+    /* some russian modem, Alexey Promokhov */
+    {"CallerID: ",		&CallerId},
 
     {NULL}
 };
Only in mgetty-1.1.22/contrib: 3b1
Only in mgetty-1.1.22/contrib: README
Only in mgetty-1.1.22/contrib: autoprint.sh
Only in mgetty-1.1.22/contrib: dvi-fax
Only in mgetty-1.1.22/contrib: faxdvi.config
Only in mgetty-1.1.22/contrib: faxdvi2.perl
Only in mgetty-1.1.22/contrib: faxin.c
Only in mgetty-1.1.22/contrib: faxiobe.sh
Only in mgetty-1.1.22/contrib: faxmail-smail
Only in mgetty-1.1.22/contrib: frame40ps.fix
diff -urP mgetty-1.1.22/contrib/g3hack.c mgetty-current/contrib/g3hack.c
--- mgetty-1.1.22/contrib/g3hack.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/contrib/g3hack.c	Thu Nov 16 11:41:40 2000
@@ -0,0 +1,199 @@
+/* 
+* From owner-mgetty Wed Jun 28 02:08:30 1995
+* Return-Path: <owner-mgetty>
+* Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+* 	id <m0sQkgA-0001nCC@greenie.muc.de>; Wed, 28 Jun 95 02:08 MEST
+* Return-Path: <l-mgetty-owner@muc.de>
+* Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+* 	id <m0sQkg6-0002jPC@greenie.muc.de>; Wed, 28 Jun 95 02:08 MEST
+* Received: from greenie.muc.de ([193.174.4.62]) by colin.muc.de with SMTP id <25543-2>; Wed, 28 Jun 1995 02:08:14 +0200
+* Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+* 	id <m0sQkXo-0001nCC@greenie.muc.de>; Wed, 28 Jun 95 01:59 MEST
+* Received: from GATEWAY by greenie.muc.de with netnews
+* 	for mgetty@muc.de (mgetty@muc.de)
+* To: mgetty@muc.de
+* Date: Sat, 24 Jun 1995 21:26:42 +0200
+* From: fdc@cliwe.ping.de (Frank D. Cringle)
+* Message-ID: <vt68lv7cb1.fsf_-_@cliwe.ping.de>
+* Organization: calls for speculation 
+* References: <m0sNnpJ-0001v0C@greenie.muc.de>
+* Subject: Save the forests (was: Conversion ascii->g3)
+* Status: RO
+* 
+* gert@greenie.muc.de (Gert Doering) writes:
+* >Erlend Schei wrote:
+* >> Any recommendations (perhaps som script-gurus who know how to make
+* >> gslp skip the white stuff at the end of the last page)?
+* >
+* >I'd like to see that too. I don't think it's easy, you'll have to hack the
+* >dfaxhigh (or faxg3) driver, I think.
+* 
+* Here is a nasty little hack that will chop the end off a g3 file.  It
+* is nasty 'cos it only works for single-page 1d-encoded files with
+* msbfirst bit order.  But that is what mgetty uses at present, so what
+* the hell.
+* 
+* It is rather cool in the way that it decides what to chop.  All
+* identical lines at the end of the page are candidates and any more
+* than 10 (by default) are discarded.  It does not matter whether they
+* are white, black or striped.
+* 
+* I leave it to a competent shell programmer to integrate it into the
+* faxspool script.
+* 
+* ----------------------------------------------------------------
+*/
+/* g3hack.c - hack identical lines off the end of a fax
+ *
+ * This program is in the public domain.  If it does not work or
+ * causes you any sort of grief, blame the public, not me.
+ *
+ * fdc@cliwe.ping.de, 1995-06-24
+ *
+ * $Id$
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern int getopt();
+extern char *optarg;
+extern int optind, opterr;
+
+char *usage = "usage: %s <-n count> <-h size> -o <outputfile>\n\n\
+Copy a g3-(1d)-fax file from stdin to stdout and delete any\n\
+   more than `count' identical trailing lines (default 10).\n\
+Optionally skip `size'-byte header.\n\
+Optionally named outputfile (else stdout).\n";
+
+#define nxtbit()	((imask>>=1) ? ((ibits&imask)!=0) :		\
+			 ((ibits=getchar()) == EOF) ? -1 :		\
+			 (((imask=0x80)&ibits)!=0))
+#define putbit(b)							\
+    do {								\
+	if (b)								\
+	    obits |= omask;						\
+	if ((omask >>= 1) == 0) {					\
+	    this->line[this->length>>3] = obits;			\
+	    omask = 0x80;						\
+	    obits = 0;							\
+	}								\
+	this->length++;							\
+	if (this->length >= BUFSIZ<<3) {				\
+	    fputs("g3hack: unreasonably long line\n", stderr);		\
+	    exit(1);							\
+	}								\
+    } while (0)
+
+static void
+copy(int nlines)
+{
+    int ibits, imask = 0;	/* input bits and mask */
+    int obits = 0;		/* output bits */
+    int omask = 0x80;		/* output mask */
+    int zeros = 0;		/* number of consecutive zero bits */
+    int thisempty = 1;		/* empty line (so far) */
+    int empties = 0;		/* number of consecutive EOLs */
+    int identcount = 0;		/* number of consecutive identical lines */
+    struct {
+	char line[BUFSIZ];
+	int length;
+    } lines[2], *prev, *this, *temp;
+
+    this = &lines[0];
+    prev = &lines[1];
+    this->length = prev->length = 0;
+    while (!ferror(stdout)) {
+	int bit = nxtbit();
+	if (bit == -1)
+	    break;		/* end of file */
+	putbit(bit);
+	if (bit == 0) {
+	    zeros++;
+	    continue;
+	}
+	if (zeros < 11) {	/* not eol and not empty */
+	    zeros = 0;
+	    thisempty = 0;
+	    for ( ; empties; empties--)
+		fwrite("\0\1", 1, 2, stdout);
+	    continue;
+	}
+	/* at end of line */
+	zeros = 0;
+	omask = 0x80;
+	obits = 0;
+	if (thisempty) {
+	    empties++;
+	    if (empties >= 6)
+		break;
+	    this->length = 0;
+	    continue;
+	}
+	thisempty = 1;
+	/* at end of non-empty line */
+	identcount++;
+	this->length = (this->length+7)&~7;
+	this->line[(this->length-1)>>3] = 1; /* byte-align the eol */
+	if (this->length == prev->length &&
+	    memcmp(this->line, prev->line, this->length>>3) == 0) {
+	    this->length = 0;
+	    continue;
+	}
+	/* at end of non-matching line */
+	for ( ; identcount; identcount--)
+	    fwrite(prev->line, 1, prev->length>>3, stdout);
+	temp = prev;
+	prev = this;
+	this = temp;
+	this->length = 0;
+    }
+    if (identcount > nlines)
+	identcount = nlines;
+    for ( ; !ferror(stdout) && identcount; identcount--)
+	    fwrite(prev->line, 1, prev->length>>3, stdout);
+    for ( ; !ferror(stdout) && empties; empties--)
+	fwrite("\0\1", 1, 2, stdout);
+    if (ferror(stdout)) {
+	fputs("write error\n", stderr);
+	exit(1);
+    }
+}
+
+int
+main(int argc, char **argv)
+{
+    int c;
+    int header = 0;
+    int nlines = 10;
+
+    opterr = 0;
+    while ((c = getopt(argc, argv, "h:n:o:")) != EOF)
+	switch (c) {
+	case 'h':
+	    header = atoi(optarg);
+	    break;
+	case 'n':
+	    nlines = atoi(optarg);
+	    break;
+	case 'o':
+	    if (freopen(optarg, "w", stdout) == NULL) {
+		perror(optarg);
+		exit(1);
+	    }
+	    break;
+	case '?':
+	    fprintf(stderr, usage, argv[0]);
+	    exit(1);
+	}
+    while (header--)
+	putchar(getchar());
+    copy(nlines);
+    exit(0);
+}
+
+/*
+* -- 
+* Frank Cringle                      | fdc@cliwe.ping.de
+* voice + fax                        | +49 2304 467101
+*/
Only in mgetty-1.1.22/contrib: g3tolj.1
Only in mgetty-1.1.22/contrib: g3tolj.c
Only in mgetty-1.1.22/contrib: g3tops.c
Only in mgetty-1.1.22/contrib: g3toxwd.1
Only in mgetty-1.1.22/contrib: g3toxwd.c
Only in mgetty-1.1.22/contrib: gs-security.fix
Only in mgetty-1.1.22/contrib: logparse.c
Only in mgetty-1.1.22/contrib: lp-fax
Only in mgetty-1.1.22/contrib: mgetty-to-flexfax.sh
Only in mgetty-1.1.22/contrib/next-login: Makefile
Only in mgetty-1.1.22/contrib/next-login: README
Only in mgetty-1.1.22/contrib/next-login: login.c
Only in mgetty-1.1.22/contrib/next-login: pathnames.h
Only in mgetty-1.1.22/contrib/next-login: setenv.c
Only in mgetty-1.1.22/contrib: pbm2styl800.tar.gz
Only in mgetty-1.1.22/contrib: pbmscale.c
Only in mgetty-1.1.22/contrib: pbmsplit.c
Only in mgetty-1.1.22/contrib: pgx.c
Only in mgetty-1.1.22/contrib: readme.supra
Only in mgetty-1.1.22/contrib: scrts.c
Only in mgetty-1.1.22/contrib: sun.readme
Only in mgetty-1.1.22/contrib: tsfax-0.1.tgz
Only in mgetty-1.1.22/contrib: ttyenable
Only in mgetty-1.1.22/contrib: two-modems
Only in mgetty-1.1.22/contrib: usr_gotcha.mail
diff -urP mgetty-1.1.22/doc/class2doc mgetty-current/doc/class2doc
--- mgetty-1.1.22/doc/class2doc	Thu Jan  1 01:00:00 1970
+++ mgetty-current/doc/class2doc	Thu Nov 16 11:41:39 2000
@@ -0,0 +1,1357 @@
+Path: greenie!gold.sub.org!imutm1.de.intel.com!chnews!asuvax!cs.utexas.edu!zaphod.mps.ohio-state.edu!howland.reston.ans.net!newsserver.jvnc.net!netnews.upenn.edu!netnews.cc.lehigh.edu!ns1.cc.lehigh.edu!dhs1
+From: dhs1@ns1.cc.lehigh.edu (David Savlin)
+Newsgroups: comp.dcom.fax
+Subject: Fax Class II document (from Supra)
+Message-ID: <1993Mar5.192102.81159@ns1.cc.lehigh.edu>
+Date: 5 Mar 93 19:21:02 GMT
+Organization: Lehigh University
+Lines: 1347
+
+
+                   SUPRA TECHNICAL SUPPORT BULLETIN
+               CLASS 2 FAX COMMANDS FOR SUPRA FAXMODEMS
+                              6/19/92
+
+Supra Corporation
+7101 Supra Drive SW, Albany, OR  97321
+General (503) 967-2400 / Sales (503) 967-2410 / Fax (503) 967-2401
+Supra Tech Support  (503) 967-2440  8:00am - 5:00pm PST, M-F
+
+Supra BBS........(503) 967-2444  24 Hours
+CompuServe.......76004,565
+BIX..............SupraCorp
+America Online...SupraCorp2
+GEnie............SupraTech
+AppleLink........D2456
+UseNet EMail.....supratech%supra.uucp@cs.orst.edu
+            .....supra!supratech@cs.orst.edu
+
+SUPRA's DISCLAIMER:
+   The following information has been taken from Rockwell's RC144AC
+manual. It has not been taken from the CCITT Class 2 documentation,
+which is copyrighted by the CCITT.  This information is provided for
+educational purposes only.  To fully understand this information
+requires a through knowledge of the T.4 fax image and the T.30 fax
+session protocol standards.  Due to the nature of this information,
+Supra's engineers and technical support can not and will not provide any
+help or support on this information.  While a majority of this
+information is correct, neither Supra nor Rockwell implies or warranties
+that the SupraFaxModem will work exactly as documented here. This
+information is based on an early draft of Class 2, which has undergone
+further revisions and changes by the CCITT TR29.2 committee.  We
+STRONGLY urge anyone attempting to develop fax software to get the
+required documentation from Global Engineering or the TIA.
+
+SHORT HISTORY OF CLASS 1 AND 2
+  In 1988 the CCITT TR29.2 committee accepted the Class 1 standard for
+communication between fax software and fax modems.  The committee also
+voted on, but did not accept for various technical reasons, the Class 2
+standard.  A year later, they had slightly revised the standard but
+again did not accept it.  Software and hardware manufactures decided to
+unofficially adopt this standard until the TR29.2 committee could
+develop an acceptable standard.  Since so many companies have used the
+unoffical standard, the TR29.2 committee has designated that when the
+standard is offically adopted it will be known as Class 2.0.  Over the
+last year or so, the TR29.2 committee has voted on several revisions to
+the Class 2 standard.  Their last vote was early May '92.  A no vote for
+technical reasons was entered.  The TR29.2 committee is now reviewing
+the technical issues that were raised.  At this time, Supra has not
+heard of a projected date for the next ballot.
+
+WHAT IS THE DIFFERENCE BETWEEN CLASS 1 AND 2
+  Class 1 fax software handles all of the T.4 fax image and T.30 session
+protocol information and timming.  Thus, the ability to communicate
+properly with various fax machines is more a function of the software
+than the fax modem.  Class 2 fax software generates a T.4  fax page
+image and sends it to the fax modem a page at a time.  The fax modem
+then handles the T.30 session protocol information and timming.  This
+relieves the computer's cpu from some work.  The ability to communicate
+properly with various fax machines is more a function of the fax modem
+than the software.  However, to further complicate matters, class 2 fax
+software can issue Class 1 commands and take over some of the duties of
+the Class 2 fax modem.
+
+  When customers have a problem communicating correctly with a fax
+machine/modem, it can be very difficult to determine which is at fault,
+ the software or the hardware.  Supra has collected numerous Class 1 and
+2 fax software for a variety of different computers.  When we receive a
+report of a problem, we use these programs to determine if it is a
+software or hardware problem.  If it is a hardware problem, we notify
+Rockwell, otherwise we notify the software company.
+
+BUG REPORTS
+  Supra is dedicated to making the best product for the best price.  If
+you feel that you have found a bug, please fax or send a letter to the
+attention of:
+
+   SUPRA V32/BIS FAX BUG
+
+Please fully describe the 'bug' (specific steps to generate it, phone
+numbers to call, make and model of fax/modem, rev of our ROM (from I3
+command) ), why you believe that it is a bug, what specific section of
+Class 2 applies to this bug and how you would like the bug to be fixed.
+Please remember that there are issues that have not been addressed or
+settled by the TR29.2 committee in the Class 2 specifications. (i.e. how
+the DCD and DTR lines are handled while in fax mode.)
+
+
+WHERE TO GET OFFICIAL FAX DOCUMENTATION
+
+  Telecommunications Industry Association
+  1722 Eye St. NW
+  Suite 440
+  Washington, DC  20006
+
+You need to ask for:
+
+    Class 1 documentation - EIA/TIA-578
+    Class 2 documentation - Electronic Industries Association and
+Telecommunications Industry Association TIA Project Number 2388,
+Asynchronous Facsimile DCE Control Standard, Service Class2, TR-29.2
+Committee Letter Ballot
+
+  Global Engineering Documents
+  2805 McGaw Ave
+  Irvin, CA  92713
+  800-854-7179
+  714-261-1455
+  714-261-7892 (Fax)
+
+You need to ask for:
+
+    EIA/TIA-578 - Class 1 documentation
+    EIA/TIA-592 - Class 2 documentation
+    CCITT v7.3  - T.1 - T.90 standards, includes T.4 & T.30
+
+(The cost for the above docs will run close to $200.  But Global will
+also update you on any changes or additions to those standards you
+purchase.)
+
+Global Engineering will not have the Class 2 documentation until approx.
+a month after the TR29.2 committee accepts it.  Most of those companies
+which have developed Class 2 fax software either sit on the TR29.2
+committee or know someone who does.  It may be possible to receive the
+documentation from the TIA if you present a credible proposal.  Supra
+has no knowledge of what this proposal should consist of or who you need
+to talk to.
+
+
+7.1  COMMAND SYNTAX AND GUIDELINES
+
+7.1.1 DTE COMMANDS
+
+The ISO 646 character set (T.50 International Alphabet 5, American
+Standard Code for Information Interchange) is used for the issuance of
+commands and responses.  Only the low-order 7 bits of each character are
+used for commands or parameters; the high order bit is ignored.  Upper
+case characters are equivalent to lower case characters.
+
+For Phase C data transmission or reception, all 8 bits are needed.
+
+DTE COMMAND LINES
+
+A command line is a string of characters sent from a DTE to the DCE
+while the DCE is in a command state.  Command lines have a prefix, a
+body, and a terminator.  The prefix consists of the ASCII characters
+'AT' (065, 084) or 'at' (097, 116).  The body is a string of commands
+restricted to printable ASCII characters, (032-126).  Space characters
+(ASCII 032) and control characters other than CR (013) and BS (010) in
+the command string are ignored.  The default terminator is the ASCII
+<CR> character.  Characters that precede the AT prefix are ignored.
+
+BSIC COMMAND SYNTAX
+
+Characters within the command line are parsed as commands with
+associated parameter values.  The basic commands consist of single ASCII
+characters, or single characters preceded by a prefix character (e.g.,
+'&'), followed by a decimal parameter.
+
+Missing decimal parameters are evaluated as 0.
+
+EXTENDED COMMAND SYNTAX
+
+The facsimile commands use extended syntax.  They are preceded by the
+'+F' characters, and they are terminated by the semicolon ';' character
+(059) or by the <CR> that terminated the command line.
+
+         AT+FAA=0         ;+FCR 1 <CR>
+
+This command instructs the DCE to answer automatically a data or fax
+call and also enables reception.
+
+         AT+FCLASS=0 <CR>      for data mode
+         AT+FCLASS=1 <CR>      for Service Class 1 Fax
+         AT+FCLASS=2 <CR>      for Service Class 2 Fax
+
+In Class 2, the DCE makes and terminates calls, manages the
+communication session and negotiates (T.30 protocol) and transports the
+image date to DTE.  The T.4 protocol management of image data, etc. is
+done by DTE.
+
+The response to
+
+         AT+FCLASS=0<CR>       in Data Mode
+
+or
+
+        AT+FCLASS=2<CR>       in Service Class 2 Fax
+
+is
+       OK
+
+The service class may be set by the DTE from the choices available using
+the '+FCLASS=<VALUE>' command.
+
+GENERAL RULES
+
+1.  +Fnnn commands must be entered completely otherwise an
+    ERROR response is sent.
+
+2.  All response messages are preceded and followed by <CR><LF>.
+    Multiple response commands, e.g., +FDIS:+FCSI: and +FDCS, will
+    therefore appear to a have a blank line between them.
+
+3.  Fax Class 2 commands can be separated by the ";" character.  The ";"
+    can be omitted if desired.  Note that non-data commands cannot be
+    separated by ";" which is allowed as a dial modifier.
+
+4.  All class 2 commands are assumed to be the final command on a
+    command line.  Additional characters will be ignored.
+
+5.  An ERROR message will be generated if any of the following
+    conditions:
+
+      a.  A class 1 command is received while in Class 2.
+
+      b.  A Class 2 command is received while in Class 1.
+
+      c.  A Class 1 or Class 2 action command is received while in data
+          modem mode
+
+      d.  A Class 2 read-only parameter is given the "=" form of a +F
+          command (e.g., AT+FAXERR=5).
+
+      e.  A class 2 action command is given the inappropriate "=" or
+          "=?" (e.g., AT+FDR=?).
+
+7.1.2 SERIAL PORT SPEED AND FLOW CONTROL
+
+During fax mode, the DTE-DCE port speed is 19200 bps.
+
+The DCE provides a speed buffer of 1024 bytes and provides DC1/DC3
+(XON/XOFF) or RTS/CTS method of controlling the data into the buffer.
+This flow control is controlled by AT&K3 or AT&K4 command.
+
+This method of data flow control is available only for DTE to DCE
+direction of data.  There is no provision for data flow control from DCE
+to DTE.
+
+DATA STREAM TERMINATION
+
+The DCE exchanges streams of data with the DTE while executing data
+transfer commands.  These use data stream termination described in
+Section 3.2/ISO 2111.
+
+The ASCII <DLE> character (016) is used as a special character to shield
+special characters.  The <DLE><ETX> character pair (<106><003>) is used
+to mark the end of a stream.  The following patterns are used:
+
+   any data....<DLE><ETX>       end of stream
+   any data....<DLE><DLE>       single <DLE> in data
+   any data....<DLE><any byte>  delete <DLE><any byte>
+
+DTE to DCE STREAMS
+
+The DCE filters the data stream from the DTE, and removes all character
+pairs beginning with <DLE>.  The DCE recognizes <DLE><ETX> as the stream
+terminator.  The DCE recognizes <DLE><DLE> and reinserts a single <DLE>
+in its place.
+
+The DTE must filter stream data to the DCE, and insert extra <DLE>
+characters ahead of data.
+
+DCE TO DTE STREAMS
+
+The DTE must filter the data stream from the DCE, and remove all
+character pairs beginning with <DLE>.  The DTE must recognize <DLE><ETX>
+as the stream terminator.  The DTE must recognize <DLE><DLE> and
+reinsert a single <DLE> in its place.
+
+The DCE filters stream data to the DTE, and inserts extra <DLE>
+characters ahead of data.
+
+7.1.3  AUTO ANSWER
+
+The DCE can answer as a data DCE or as a fax DCE.  It can answer the
+call adaptively, i.e. it can determine whether call is 'data' or 'fax'.
+The +FAA parameter controls this feature.
+
+     AT+FAA=1           ; Auto answer as a facsimile or a
+                        ; data modem depending on call
+
+     CONNECT xxx        ; DCE status response if data call
+
+     +FCON              ; DCE status response if fax call
+
+7.1.4  IDENTIFICATION OF T.30 OPTIONS
+
+Group 3 devices negotiate session parameters in DIS, DCS and DTC frames.
+ These parameters are defined in table 8.2.
+
+7.1.5  SESSION STATUS REPORTING
+
+The DCE provides reports to the DTE on the status of a session.  The DCE
+provides following status reports:
+
+1.  Connection and hang up status:
+
+        +FCON
+
+        +FHNG:<0-255>
+
+2.  Requested DIS session parameters +FDIS:<string> reports remote
+    facsimile capabilities.
+
+        Syntax:+FDIS:VR, BR, WD, LN, DF, EC, BF, ST
+
+3.  +FDCS:<string> reports the negotiated parameters
+
+4.  Phase C prompts:
+
+        XON, XOFF, DC2
+
+5.  Phase C base status reports: depending upon copy quality and related
+    end-of page status:
+
+        +FPTS:<1-5>
+
+7.1.6  PROCEDURE INTERRRUPT NEGOTIATION
+
+CCITT allows a station to request a procedure interruption at the end of
+a page.  This request is passed between stations by the PIP, PIN, and
+PRI-Q messages.
+
+
+TABLE 7-1. FAX CLASS 2 COMMANDS
+-----------------------------------------------------------
+|   Command        Function                               |
+|---------------------------------------------------------|
+|   SERVICE CLASS ID                                      |
+|---------------------------------------------------------|
+|   +FCLASS=       Service Class                          |
+|---------------------------------------------------------|
+|   CLASS 2 ACTION COMMANDS                               |
+|---------------------------------------------------------|
+|   D              Originate a call                       |
+|   A              Answer a call                          |
+|   +FDT=          Data Transmission                      |
+|   +FET=N         Transmit Page Punctuation              |
+|   +FDR           Begin or Continue Phase C Receive Data |
+|   +FK            Session Termination                    |
+|---------------------------------------------------------|
+|  CLASS 2 DCE RESPONSES                                  |
+|---------------------------------------------------------|
+|   +FCON          Facsimile Connection Response          |
+|   +FDCS:         Report Current Session                 |
+|   +FDIS:         Report Remote Identification           |
+|   +FCFR          Indicate Confirmation to Receive       |
+|   +FTSI:         Report the Transmit Station ID         |
+|   +FCSI:         Report the Called Station ID           |
+|   +FPTS:         Page Transfer Status                   |
+|   +FET:          Post Page Message Response             |
+|   +FHNG          Call Termination with Status           |
+|---------------------------------------------------------|
+|   CLASS 2 SESSION PARAMETERS                            |
+|---------------------------------------------------------|
+|   +FMFR?         Identify Manufacturer                  |
+|   +FMDL?         Identify Model                         |
+|   +FREV?         Identify Revision                      |
+|   +FDCC=         DCE Capabilities Parameters            |
+|   +FDIS=         Current Sessions Parameters            |
+|   +FDCS=         Current Session Results                |
+|   +FLID=         Local ID String                        |
+|   +FCR           Capability to Receive                  |
+|   +FPTS=         Page Transfer Status                   |
+|   +FAA           Adaptive Answer                        |
+|   +FBUF?         Buffer Size (Read Only)                |
+|   +FPHCTO        Phase C Time Out                       |
+|   +FAXERR        Fax Error Value                        |
+|   +FBOR          Phase C Data Bit Order                 |
+|---------------------------------------------------------|
+
+7.2 SERVICE CLASS 2 IDENTIFICATION AND SELECTION
+
+The fax class 2 commands are summarized in Table 7-1.
+
+Three commands report identification and selection information.  Each of
+these three commands cause the DCE to send a message to the DTE.  Each
+message is 20 bytes (ASCII encoded) followed by the terminating
+character (binary 0).
+
+7.2.1 +FMFR?, REQUEST MANUFACTURER IDENTIFICAITION
+
+The +FMFR? command caused the DCE to send a message identifying the DCE
+product manufacturer.  The default message is:
+
+    ROCKWELL
+    OK
+
+7.2.2  +FMDL?, IDENTIFY PRODUCT MODEL
+
+The +FMDL? command causes the DCE to send a message identifying the DCE
+product model.  The default message is:
+
+   V.32AC
+   OK
+
+7.2.3  +FREV?, IDENTIFY PRODUCT REVISION
+
+The +FREV? command causes the DCE to send a message identifying the DCE
+product model revision number.  The typical default message is:
+
+    V0.200 TR14-JXXX-001
+    OK
+
+7.3  SERVICE CLASS 2 ACTION COMMANDS
+
+These commands transfer data, and punctuate sessions.  They also release
+specific T.30 messages.  All action commands must be the last command on
+a command line.  This is indicated by the terminating <CR>.
+
+All action commands initiate processes.  The modem will not accept other
+commands from the DTE until the modem issues a final result code  (e.g.
+OK, CONNECT).  The modem will abort the process if it receives any
+character before the final result code is issued.
+
+7.3.1  ATD, ORIGINATE A CALL
+
+Syntax:    ATD...<CR>
+
+The DCE can support a DTE command to originate a call using the ATD
+command (See Table 4-2).
+
+If this command is unsuccessful, the DCE reports an appropriate failure
+or error type result code such as NO CARRIER, NO DIALTONE or BUSY (see
+Table 4-7).
+
+If this call is successful, the typical DCE response is:
+
+   ATDnn.nn         (go off-hook, dial, get CED)
+   +FCON            (DCE detects flags)
+   [+FCSI:<remote ID string>]
+   +FDCS:<T.30 subparameter string>
+   OK
+
+The DCE dials, detects call progress and generates the CNG tone.  Then
+it waits for a DIS frame.  On detection of the first Phase B preamble
+(V.21 ch. 2 modulated by 300 bit/s HDLC flags) it reports the "+FCON"
+message to the DTE.  The DCE then switches to 19.2K bps.
+
+The DCE generates a DCS frame based on the received DIS frame and on the
+previously set +FDIS parameter.  A +FDT command from the DTE releases
+the DCE to transmit that DCS frame.
+
+The DCE reports the initial received T.30 negotiation messages,
+including the DIS frame and the optional CSI ID string.  The +FDIS:
+report is followed by the OK final result code.
+
+7.3.2  ATA, ANSWER A CALL
+
+The DCE can support a DTE command to answer an incoming call using the
+ATA command (see Table 4-2).
+
+The DTE may issue an Answer command in response to an incoming ring.
+
+If the Answer command is unsuccessful, the DCE will report an
+appropriate failure or error type result code, such as NO CARRIER (see
+4-7)
+
+MANUAL CALL ANSWER
+
+If this call is successful, the typical DCE response (answer and
+receive) is:
+
+  +FCON
+  [+FTSI:<remote ID string>]
+  +FDCS: <T.30 subparameter string>
+  OK
+  (DTE should issue +FDR command here)
+
+On receipt of an Answer command from the DTE, the DCE answer and
+generates the CED tone.  The DCE then generates a DIS frame (derived
+from the +FDIS parameter) and hunts for the first T.30 negotiation
+frames.  On detection of the first Phase B preamble (V.21 ch 2 modulated
+by 300 bit/s HDLC flags), it reports the "+FCON" message to the DTE.
+
+The DTE should report the initial received T.30 negotiation messages,
+including the DCS frame.  The +FCS: report will be followed by the OK
+final result code.
+
+AUTOMATIC ANSWER
+
+The modem provides for automatic answering of incoming calls.  If
+configured for automatic answer, the modem answers and incoming call in
+compliance with T.30 and reports the same messages as described for
+manual answer.
+
+CONNECTIONS AS A DATA MODEM
+
+If configured to do so by the +FAA parameter, the DCE will adaptively
+answer as a facsimile DCE or as a data DCE.  If the DCE answers as a
+facsimile DCE or as a data DCE.  If the DCE answers as a data DCE, it
+resets the +FCLASS parameter to 0 and issues the appropriate final
+result code (e.g. CONNECT or NO CARRIER) to the DTE.
+
+7.3.3  +FDT, DATA TRANSMISSION
+
+Syntax: +FDT<CR>
+
+The +FDT command prefixes Phase C data transmission.  When the DCE is
+ready to accept Phase C data, it issues the negotiation responses and
+the CONNECT result code to the DTE.
+
+In Phase B, the +FDT command releases the DCE to proceed with
+negotiation, and releases the DCS message to the remote station.  In
+Phase C, the +FDT command resumes transmission after the end of a prior
+transmit data stream.
+
+INITIATE PAGE TRANSMISSION
+
+Phase B DCE polled response:
+
+  [+FCSI:<remote ID string>]                   ; If new CSI received
+  [+FDIS:<subparameters from remote station>]  ; If new DIS received
+  +FDCS:<T.30 subparameter string>
+  CONNECT
+  <XON>                                        ; When ready for data
+
+After placing a call, or after finishing a document exchange, the DTE
+may command the DCE to re-enter T.30 Phase B to attempt to negotiate a
+document transmission.
+
+CONTINUE A PAGE
+
+   CONNECT
+   <XON>
+
+The DTE may issue more than one +FDT command for a given page, so that
+different files may be concatenated together.  These files must have the
+same format.
+
+PHASE C DATA FRAMING
+
+Phase C data must be presented to the DCE in stream mode.  The DCE
+expects Phase C data to follow until it detects <DLE><ETX> termination
+characters.  The DCE will filter the stream as described in Section
+7.1.2
+
+The DCE will acknowledge the end of the data by returning the OK result
+code to the DTE.
+
+If there is data underrun before the next +FDT or +FET= command, the DCE
+will zero-fill pad as per T.4 until the  Phase C timeout (+FPHCTO) is
+reached, or until more data is received.  The DCE appends an RTC pattern
+to the transmit data after an +FET= command is received from the DTE.
+
+PHASE C DATA FORMAT
+
+The Phase C data will be of the format specified by the negotiated T.30
+DCS frame.  The +FDCS <string> response is defined in section 7.4.2.
+The subparameter values are described in table 7.2.
+
+The DCE will use the negotiated minimum Scan Time parameter from the DCS
+frame , and insert sufficient fill bits to pad each line to the minimum
+scan time.  This is reported in the +FDCS:ST subparameter.
+
+If the DCE finds more than one consecutive EOL in Phase C data (e.g.
+RTC), it will send only one EOL.
+
+Note 1:  Phase C data must conform to T.4 specifications
+
+Note 2:  The DTE need not include a final RTC, since the DCE will append
+         an RTC in response to an FET= command
+
+Note 3:  Some facsimile machines may treat two EOLs as an RTC
+
+<CAN>, ESCAPE FROM TRANSMISSION
+
+The DCE may request the DTE to halt Phase C transmission, by sending an
+cancel <CAN> character (024) to the DTE.  In this case, the DTE should
+terminate Phase C transmission, issue <CAN>, and wait for the OK
+response code from the DCE.
+
+Table 7-2  T.30 Session Subparameter Codes
+
+|-----------------------------------------------------------------|
+|  Label |  Function     |  Value  |  Description                 |
+|--------|---------------|---------|------------------------------|
+|  VR    |  Vertical     |   0     |  Normal, 98 lpi              |
+|        |  resolution   |   1     |  Fine, 196 lpi               |
+|--------|---------------|---------|------------------------------|
+|  BR    |  Bit Rate     |   0     |  2400 bit/s V.27 ter         |
+|        |               |   1     |  4800 bit/s V.27 ter         |
+|        |  (See note 1) |   2     |  7200 bit/s V.29 or v.17     |
+|        |               |   3     |  9600 bit/s V.29 or v.17     |
+|        |               | **4     |  12000 bit/s V.33 or v.17    |
+|        |               | **5     |  14400 bit/s V.33 or v.17    |
+|--------|---------------|---------|------------------------------|
+|  WD    | Page Width    |   0     |  1728 pixels in 215 mm       |
+|        |               |   1     |  2048 pixels in 255 mm       |
+|        |               |   2     |  2432 pixels in 303 mm       |
+|        |               |  *3     |  1216 pixels in 151 mm       |
+|        |               |  *4     |   864 pixels in 107 mm       |
+|--------|---------------|---------|------------------------------|
+|  LN    |  Page Length  |   0     |  A4, 297 mm                  |
+|        |               |  *1     |  B4, 364 mm                  |
+|        |               |  *2     |  unlimited length            |
+|--------|---------------|---------|------------------------------|
+|  DF    |  Data         |   0     |  1-D modified Huffman        |
+|        |  Compression  |   1     |  2-D modified Read           |
+|        |  Format       |  *2     |  2-D uncompressed mode       |
+|        |               |  *3     |  2-D modified Read           |
+|--------|---------------|---------|------------------------------|
+|  EC    |  Error        |   0     |  Disable ECM                 |
+|        |  Correction   |  *1     |  Enable ECM,64 bytes/frame   |
+|        |  (Annex       |  *2     |  Enable ECM,256 bytes/frame  |
+|        |   A/T.30)     |         |                              |
+|        |  (See Note 2) |         |                              |
+|--------|---------------|---------|------------------------------|
+|  BF    |  Binary File  |   0     |  Disable BFT                 |
+|        |  Transfer     |  *1     |  Enable BFT                  |
+|        |  (See Note 3) |         |                              |
+|--------|---------------|---------|------------------------------|
+|  ST    |  Scan Time/   |         |  VR=normal   VR=fine         |
+|        |  Line         |   0     |    0 ms        0 ms          |
+|        |               |   1     |    5 ms        5 ms          |
+|        |               |   2     |    10 ms       5 ms          |
+|        |               |   3     |    10 ms       10 ms         |
+|        |               |   4     |    20 ms       10 ms         |
+|        |               |   5     |    20 ms       20 ms         |
+|        |               |   6     |    40 ms       20 ms         |
+|        |               |   7     |    40 ms       40 ms         |
+|--------|---------------|---------|------------------------------|
+|  NOTES: 1: CCITT T.30 does not provide for the answering        |
+|            station to specify all speeds exactly using the DIS  |
+|            frame.  Implementation of some BR codes (e.g.code 2) |
+|            by an answering DCE is manufacturer specific.        |
+|                                                                 |
+|                                                                 |
+|         * =Not supported                                        |
+|        ** =RC144AC only                                         |
+|                                                                 |
+|         2: ECM has been implemented in Supra's version 1.200C.  |
+|            ECM transmit works correctly, and ECM receive works, |
+|            but does not tell the transmitting machine that the  |
+|            fax was received correctly.                          |
+|                                                                 |
+|        3:  BFT has been implemented in Supra's version 1.200C.  |
+|            BFT transmit works correctly, and BFT receive works, |
+|            but does not tell the transmitting machine that the  |
+|            file was received correctly.                         |
+|                                                                 |
+|-----------------------------------------------------------------|
+
+
+7.3.4  +FET=, TRANSMIT PAGE PUNCTUATION
+
+Syntax:   +FET=<ppm>[,<pc>,<bc>,<fc>]
+
+DCE response:
+  +FPTS:<ppr>    ; when receive from remote OK
+
+This command is used to punctuate page and document transmission after
+one or more +FDT commands.  This command generates T.30 Post Page
+Messages selected by the <ppm> code (Table 7-3)
+
+The +FET=<ppm> command indicates that the current page is complete; no
+more data will be appended to it.  The value indicates if there are any
+additional pages are to be sent and, if so, whether there is a change in
+any of the document parameters.
+
+The DTE can command the DCE to generate PRI-Q messages with the
++FET=<ppm> command using ppm codes 4-6 (see Table 7-3)
+
+This command must be sent within the time out specified by +FPHCTO after
+sending Phase C data, or else the DCE will end the page and document
+transmission.  If the Phase C timeout is reached, the DCE sends an EOP
+post page message and terminates the session
+
+The remote facsimile station should respond to the post page message
+with a post page response.  The DCE will report this using the
++FPTS:<ppr> response (Table 7-4)
+
+END A PAGE
+
+The +FET= command causes the DCE to append an ETC (6 EOL) pattern as
+needed and enter Phase D by sending the selected T.30 Post Page message.
+
+The +FET=1 (EOM) command signals the remote station that the next
+document will have a new DCS negotiated; this causes the session to re-
+enter Phase B.
+
+7.3.5  +FDR, BEGIN OR CONTINUE PHASE C RECEIVE DATA
+
+Syntax:   +FDR<CR>
+
+Default value:  3 seconds in some places
+
+The +FDR command initiates transition to Phase C data reception.  This
+can occur after answering, dialing, a document is received, or a page is
+received.
+
+The DCE reports the negotiated T.30 parameters, with the remote ID
+information if available.  When the DCE is ready to commence data
+transfer, it issues a CONNECT response code.  If the DCE cannot resume
+data transfer because there is no more data, it responds OK.  When the
+DTE is ready to accept data, it issues an <DC2> character (018) to the
+DCE.
+
+If the DTE issues an <XOFF> character to the DCE for flow control, the
+DCE signals the DTE when its buffers are empty by sending a <DLE><DC2>
+(<016><018>) character pair.
+
+When the DCE delivers that last byte of a page, the DCE reports the Page
+Transfer Status via the +FPTS:<ppr> response (Table 7-4).
+
+After a Page Transfer Status Report, the DCE reports the post page
+message from the remote facsimile station via the +FET:<ppm> response
+(Table 7-3) which signals the intentions of the remote station.
+
+
+Table 7-3.  T.30 Post Page Message Codes
+
+|-----------------------------------------------------------------|
+|  ppm    |                 |                                     |
+|  Code   |  Mnemonic       |  Description                        |
+|---------|-----------------|-------------------------------------|
+|    1    |  [PPS]-MPS      |  Another page next, same document   |
+|    2    |  [PPS]-EOM      |  Another page next                  |
+|    3    |  [PPS]-EOP      |  no more pages or documents         |
+|    4    |  [PPS-]PRI-MPS  |  Another page, procedure interrupt  |
+|    5    |  [PPS-]PRI-EOM  |  Another doc, procedure interrupt   |
+|    6    |  [PPS-]PRI-EOP  |  All done, procedure interrupt      |
+|    7    |  CTC            |  Continue to correct                |
+|   8-15  |  EOR-           |  End of Retransmission (8)+         |
+|  =8+ppm |                 |  Post Page Message (ppm code)       |
+|-----------------------------------------------------------------|
+
+Table 7-4.  T.30 Post Page Response Message Codes
+
+|-----------------------------------------------------------------|
+|  ppr    |                 |                                     |
+|  Code   |  Mnemonic       |  Description                        |
+|---------|-----------------|-------------------------------------|
+|   0     |  PPR            |  Partial page errors                |
+|   1     |  MCF            |  Page Good                          |
+|   2     |  RTN            |  Page bad, retrain requested        |
+|   3     |  RTP            |  Page good, retrain requested       |
+|   4     |  PIN            |  Page bad, interrupt requested      |
+|   5     |  PIP            |  Page good, interrupt requested     |
+|-----------------------------------------------------------------|
+
+The DCE holds the post page response message to the remote facsimile
+station (MCF, etc.), represented in the +FPTS parameter until the next
++FDR command.  The DTE may modify the +FPTS parameter before issuing the
++FDR command which releases that message.  The DTE must issue a +FDR
+command to release Post Page Messages.
+
+INITIATE DOCUMENT RECEPTION
+
+The +FDR command may be issued in Phase B after an answer command, or in
+Phase B after a pervious document.
+
+The DCE response in stream mode is:
+
+   +FCR             ; when CFR sent
+   [+FTSI:<remote ID string>]  ; if new TSI received
+   +FDCS:<T.30 subparameter string>]  ; if new DCS
+   CONNECT
+   (<DC2> needed from DTE here)
+   <Phase C data stream>
+   <DLE><ETX>
+   +FPTS:<ppr>,<lc>[,<blc>,<cblc>]
+   +FET:<ppm>
+   OK
+   (DTE must issue +FDR command to release post page response)
+
+CONTINUE DOCUMENT RECEPTION
+
+The DTE may issue a +FDR command in Phase D, which releases the post
+page message, and indicates readiness to receive another page after
+receipt of a Multipage (+FET:0) or PPS-NULL (+FET:3) message.  The DCE
+response will be:
+
+   CONNECT
+   (<DC2> needed from DTE here)
+   <Phase C data stream>
+   <DLE><ETX>
+   +FPTS:<ppr>,<lc>[,<blc>,<cblc>]
+   +FET:<ppm>
+   OK
+   (DTE must issue +FDR command to release post page response.
+If done receiving:
+   +FHNG:<hangup cause code>
+   OK
+
+   Continue page reception
+
+PHASE C DATA FRAMING
+
+Phase C data may be presented to the DTE in stream mode.  The DCE will
+transfer a stream of data to the DTE, followed by the <DLE><ETX> stream
+termination characters.  The DCE will filter the stream as described in
+7.1.2.
+
+PHASE C DATA FORMAT
+
+The received data format is negotiated under T.30 reported by the
++FDCS:VR,BR,WD,LN,DF,EC,BF,ST response.
+
+The DCE will delete the terminating RTC (6 EOLs) patterns.  The DCE may
+strip zero fill bits from the data, to minimize storage needs.
+
+<CAN>, ESCAPE FROM RECEPTION
+
+From the +FDR command until the end of Phase D Date, the DCE is in a
+data transfer state, and will not respond to DTE command characters.
+The DCE will respond to three ASCII control characters, <DC1 (017) and
+<DC3> (019) flow control characters, and cancel <CAN> (024).
+
+Upon receipt of the <CAN> character, the DCE will terminate the
+reporting of received data by sending trailing <DLE><ETX> characters to
+the DTE, and will then execute an implied +FK command in order to
+conduct an orderly disconnection.
+
+7.3.6  +FK, SESSION TERMINATION
+
+Syntax:  +FK
+
+The +FK command causes the DCE to terminate the session in an orderly
+manner.  In particular, the DCE will send a DCN message at the next
+opportunity and hang up.  At the end of the termination process, the DCE
+will report the +FHNG response with result code (Table 7-5).
+
+This operation can be invoked by using the cancel <CAN> character during
+Phase C data reception (see prior section).
+
+The DCE will wait until the current page completes, unless the reception
+is of unlimited length; in that case, the DCE may halt reception and
+terminate the session at any time.
+
+7.4  SERVICE CLASS 2 DCE RESPONSES
+
+The DCE sends information responses to the DTE as a facsimile session
+proceeds.  They indicate the state of the facsimile session and convey
+need information.  These messages are solicited messages generated in
+execution of DTE action commands described in section 7.3.
+
+The DCE precedes and follows the following information responses with
+<CR><LF>.
+
+The DCE provides the on-line status of several session parameters when
+they are available during T.30 handshaking.  These include the remote ID
+string and the DIS/DCS parameters.  These responses report the T.30
+session parameter frames.  The subparameters are described in Table 7-2.
+
+7.4.1  +FCON, FACSIMILE CONNECTION RESPONSE
+
++FCON indicates connection with a fax machine.  It is released by
+detection of HDLC flags in the first received frame +FCON is generated
+in response to an Originate or Answer command.
+
+7.4.2  +FDCS:, REPORT CURRENT SESSION CAPABILITIES
+
+Syntax:   +FDCS:VR,BR,WD,LN,DF,EC,BF,ST
+
++FDCS:<string> reports the negotiated parameters.  Phase C data will be
+formatted as described by the subparameters.  This message may be
+generated in execution of +FDT or +FDR commands before the CONNECT
+result code if new DCS frames are generated of received.  (See Table 7-
+2.)
+
+7.4.3  +FDIS:, REPORT REMOTE STATION CAPABILITIES
+
+Syntax:   +FDIS:VR,BR,WD,LN,DF,EC,BF,ST
+
++FDIS:<string> reports remote facsimile station capabilities and
+intentions.  The parameters are provided in ASCII notation.  (See Table
+7-2.)
+
+This message is generated in execution of Originate, Answer, +FDT, or
++FDR commands.
+
+7.4.4  +FCFR, INDICATE CONFIRMATION TO RECEIVE
+
+Syntax:  +FCFR
+
+The DCE sends a +FCFR response to the DTE upon reception of an
+acceptable TCF training burst and a valid DCS signal from the remote
+machine.  This indicates that the DCE will receive Phase C data after
+the remote station receives the local DCE's CFR message.  The +FCFR
+message is generated in execution of a +FDR command.
+
+7.4.5  +FTSI:, REPORT THE TRANSMIT STATION ID
+
+Syntax:  +FTSI:"<TSI ID string>" Transmit Station ID
+
+This response reports the received transmit station ID string, if any.
+ This message is generated in execution of Originate, Answer, +FDT, or
++FDR commands.
+
+7.4.6  +FCSI:, REPORT THE CALLED STATION ID
+
+Syntax:   +FCSI:"<CSI ID string>" Called Station ID
+
+This response reports the received called station ID string, if any.
+This message is generated in execution of Originate, Answer, +FDT, or
++FDA commands.
+
+7.4.7  +FPTS:, RECEIVE PAGE TRANSFER STATUS
+
+Syntax:  +FPTS:<ppr>,<lc>[,<blc>,<cblc>]
+
+The +FPTS:<ppr> is generated by the DCE at the end of Phase C data
+reception in execution of a +FDR command.
+
+The <ppr> is generated by the DCE; it depends on the DCE capabilities at
+T.4 error checking.  See Table 7-4 for <ppr> values.
+
+The receiving DCE will count the lines and may optionally generate bad
+line counts.  These values are:
+
+    <lc> = line count
+    <blc> = bad line count
+    <cblc> = <consecutive bad line count
+
+A receiving DTE may inspect <ppr> and write a modified value into the +FPTS para
+meter.  The DCE will hold the corresponding Post Page Response message until rel
+eased by a +FDR command from the DTE.
+
+7.4.8  +FET:, POST PAGE MESSAGE RESPONSE
+
+Syntax:   +FET:<ppm>
+
+The +FET:<post page message> response is generated by a receiving DCE
+after DCE after the end of Phase C reception on receipt of the post-page
+message from the transmitting station.  The +GET:<ppm> response is
+generated in execution of a +FDR command.  The <ppm> codes respond to
+the T.30 pst page messages (Table 7-3)
+
+7.4.9  +FPTS:, TRANSMIT PAGE TRANSFER STATUS
+
+Syntax:  +FPTS:<ppr>
+
+The +FPTS: response reports a <ppr> number representing the copy quality
+and related post page message responses received from the remote DCE.
+The set of valid <ppr> values are defined in Table 7-4.
+
+The +FPTS:<ppr> response is generated in execution of a +FET=<ppm>
+command.
+
+7.4.10  +FHNG:, CALL TERMINATION WITH STATUS
+
+Syntax:  +FHNG:<hangup status code>
+
++FHNG indicates that the call has been terminated.  The hangup cause is
+reported and stored in the +FAXERR parameter for later inspection.  The
+<hangup status code> values are described in Table 7-5.
+
++FHNG:<hsc> is a possible intermediate result code to any DTE action
+command described in Section 7.3.  It is always followed by the OK final
+result code.
+
+Upon termination of a call, the DCE determines the cause of termination
+and reports it as part of the FHNG:<hsc> response.  It also stores this
+<hsc> code in the +FAXERR parameter for later inspection.
+
+The hangup values are organized according to the phases of the facsimile
+transaction as defined by T.30.  A COMREC error or RSPREC error
+indicates that one of two events occurred.  1) a DCN (disconnect) signal
+was received, or 2) an FCS error was detected and the incoming signal
+was still present after 3 seconds.
+
+The table values are in decimal notation.  Leading zero characters are
+optional.
+
+
+Table 7-5  Hangup Status Codes
+
+|------------------------------------------------------------|
+|    Code  |  Cause Description                              |
+|----------|-------------------------------------------------|
+|     0-9  |  CALL PLACEMENT AND TERMINATION                 |
+|----------|-------------------------------------------------|
+|       0  |  Normal and proper end of connection            |
+|       1  |  Ring Detect without successful handshake       |
+|       2  |  Call aborted, from +FK or AN                   |
+|       3  |  No Loop Current                                |
+|----------|-------------------------------------------------|
+|   10-19  |  TRANSMIT PHASE A & MISCELLANEOUS ERRORS        |
+|----------|-------------------------------------------------|
+|      10  |  Unspecified Phase A error                      |
+|      11  |  No Answer (T.30 T1 timeout)                    |
+|----------|-------------------------------------------------|
+|   20-39  |  TRANSMIT PHASE B HANGUP CODES                  |
+|----------|-------------------------------------------------|
+|      20  |  Unspecified Transmit Phase B error             |
+|      21  |  Remote cannot receive or send                  |
+|      22  |  COMREC error in transmit Phase B               |
+|      23  |  COMREC invalid command received                |
+|      24  |  RSPEC error                                    |
+|      25  |  DCS sent three times without response          |
+|      26  |  DIS/DTC received 3 times; DCS not recognized   |
+|      27  |  Failure to train at 2400 bps or +FMINSP value  |
+|      28  |  RSPREC invalid response received               |
+|----------|-------------------------------------------------|
+|   40-49  |  TRANSMIT PHASE C HANGUP CODES                  |
+|----------|-------------------------------------------------|
+|      40  |  Unspecified Transmit Phase C error             |
+|      43  |  DTE to DCE data underflow                      |
+|----------|-------------------------------------------------|
+|   50-69  |  TRANSMIT PHASE D HANGUP CODES                  |
+|----------|-------------------------------------------------|
+|      50  |  Unspecified Transmit Phase D error             |
+|      51  |  RSPREC error                                   |
+|      52  |  No response to MPS repeated 3 times            |
+|      53  |  Invalid response to MPS                        |
+|      54  |  No response to EOP repeated 3 times            |
+|      55  |  Invalid response to EOM                        |
+|      56  |  No response to EOM repeated 3 times            |
+|      57  |  Invalid response to EOM                        |
+|      58  |  Unable to continue after PIN or PIP            |
+|----------|-------------------------------------------------|
+|   70-89  |  RECEIVE PHASE B HANGUP CODES                   |
+|----------|-------------------------------------------------|
+|      70  |  Unspecified Receive Phase B error              |
+|      71  |  RSPREC error                                   |
+|      72  |  COMREC error                                   |
+|      73  |  T.30 T2 timeout, expected page not received    |
+|      74  |  T.30 T1 timeout after EOM received             |
+|----------|-------------------------------------------------|
+|   90-99  |  RECEIVE PHASE C HANGUP CODES                   |
+|----------|-------------------------------------------------|
+|      90  |  Unspecified Receive Phase C error              |
+|      91  |  Missing EOL after 5 seconds                    |
+|      92  |  Unused code                                    |
+|      93  |  DCE to DTE buffer overflow                     |
+|      94  |  Bad CRC or frame (ECM or BFT modes)            |
+|----------|-------------------------------------------------|
+| 100-119  |  RECEIVE PHASE D HANGUP CODES                   |
+|----------|-------------------------------------------------|
+|     100  |  Unspecified Receive Phase D errors             |
+|     101  |  RSPREC invalid response received               |
+|     102  |  COMREC invalid response received               |
+|     103  |  Unable to continue after PIN or PIP            |
+|----------|-------------------------------------------------|
+| 120-255  |  RESERVED CODES                                 |
+|------------------------------------------------------------|
+
+
+7.5  SERVICE CLASS 2 PARAMETERS
+
+All Service Class 2 parameters can be read, written, and tested for
+range of legal values by the DCE.  The general syntax is described in
+Section 7.1.
+
+Group 3 FAX devices negotiate session parameters in DIS, DCS, and DTC
+frames.  The following parameters are provided to condition the
+facsimile DCE for the capabilities it will offer and to report the
+session settings negotiated.
+
+The three primary T.30 session parameters are +FDCC, +FDIS and +FDCS.
+They are compound parameters, using values listed in Table 7-2.  Figure
+70-1 illustrates their relationships.
+
+7.5.1  +FDCC, DCE CAPABILITIES PARAMETERS
+
+Write Syntax:   +FDCC:VR,BR,WD,LN,DF,EC,BF,ST
+
+Valid values    See Table 7-2
+
+Default values  0,3,0,2,0,0,0,0  (RC96AC)
+                0,5,0,2,0,0,0,0  (RC144AC)
+
++FDCC allows the DTE to sense and constrain the capabilities of the
+facsimile DCE from the choices defined in CCITT t.30 Table 2.  When
++FDCC is modified by the DTE, the DCE copies +FDCC into +FDIS.
+
+7.5.2  +FDIS, CURRENT SESSIONS CAPABILIIES PARAMETERS
+
+Write Syntax:   +FDIS:VR,BR,WD,LN,DF,EC,BF,ST
+
+Valid values    See Table 7-2
+
+Default values  0,3,0,2,0,0,0,0  (RC96AC)
+                0,5,0,2,0,0,0,0  (RC144AC)
+
+
+The +FDIS parameter allows the DTE to sense and constrain the
+capabilities used for the current session.  The DCE uses +FDIS to
+generate DIS or DTC messages directly, and uses +FDIS and received DIS
+messages to generate DCS messages.
+
+The DCE initializes the +FDIS parameter from the +FDCC parameter on
+initialization, when +FDCC is written, and at the end of a session.
+
+7.5.4  +FLID=, LOCAL ID STRING
+
+Write Syntax   +FLID="<local ID string>"
+
+Valid values:   20 character ASCII string
+
+Default value:  Empty
+
+If FLID is not a null string, it generates a TSI or CSI frame.  Table
+3/T.30 includes digits 0-9, "+" and space.
+
+If the DCE supports use of Table 3/t.30 only, the response to a +FLID=?
+command is "<20)(32, 43, 48-57)".  If the DCE supports printable ASCII
+<, the response is "(20)(32-127)<CRLF>"  The first "(20)" represents
+string length: the second (character values) field reports supported
+string values.
+
+Notes:  1.  The string is saved in RAM.
+        2.  Non-numeric characters are not filtered out.
+
+7.5.5  +FCR, CAPABILITY TO RECEIVE
+
+Write Syntax:  +FCR=<value>
+
+Valid values:  1,0
+
+Default values 0
+
++FCR=0 indicates that the DCE will not receive message data.  This can
+be sued when the DTE has insufficient storage.  The DCE can send and can
+be polled for a file.
+
++FCR is sampled in CCITT T.30 Phase A and Phase D
+
+7.5.6  +FPTS=, PAGE TRANSFER STATUS
+
+Write syntax:   +FPTS=<ppr>
+
+Valid Values:   1,2,3,4,5
+
+Default value:  0
+
+7.5.7  +FCQ, COPY QUALITY CHECKING
+
+Write Syntax:  +FCQ=<value>
+
+Valid Values:  0
+
+Default Value: 0
+
+This parameter controls Copy Quality checking by a receiving facsimile
+DCE.
+
+The DCE returns +FCQ=0 which indicates the DCE does no quality checking.
+The DCE will generate Copy Quality OK (MCF) responses to complete pages,
+and set +FPTS=1.
+
+7.5.8  +FPHCTO, DTE PHASE C RESPONSE TIME-OUT
+
+Write Syntax:   +FPHCTO=<value>
+
+Valid Values:   0-255, 100 millisecond units
+
+Default Value:  30
+
+The +FPHCTO command determines how long the DCE will wait for a command
+after reaching the end of data when transmitting in Phase C.  When this
+time-out is reached, the DCE assumes there are no more pages and no
+documents to send.  It then sends the T.30 EOP response to the remote
+device.
+
+7.5.9  +FAXERR, T.30 SESSION ERROR REPORT
+
+Read Syntax:   +FAXERR=<table value>, read only
+
+Valid values:  0-255, see table 7-5 for meaning
+
+This read-only parameter indicates the cause of the hangup.  Table 7-5
+shows the valid values for this parameter as well as the meaning of the
+each value.  +FAXERR is set by the DCE at the conclusion of a fax
+session.  The DCE resets +FAXERR to 0 at the beginning of Phase A off-
+hook time.
+
+7.5.10  +FBOR, DATA BIT ORDER
+
+Write Syntax:  +FBOR=<value>
+
+Valid Values:  0,1
+
+Default value:  0
+
+This parameter controls the mapping between PSTN facsimile data and the
+DTE-DCE link.  There are two choices:
+
+DIRECT:  The first bit transferred to each byte on the DTE-DCE link is
+the first bit transferred on the PSTN data carrier.
+
+REVERSED:  The last bit transferred of each byte on the DTE-DCE link is
+the first bit transferred on the PSTN data carrier.
+
+There are two data types to control:
+
+This command controls Phase C data (T.4 encoded data) transferred during
+execution of +FDT or +FDR commands.
+
+The following two codes are supported.
+
+  +FBOR=0  selects direct bit order for Phase C data
+
+  +FBOR=1  selects reversed bit order for Phase C data
+
+Note that this parameter does not affect the bit order of control
+characters generated by the DCE.
+
+7.5.11  +FAA, ANSWER PARAMETER
+
+Write syntax:  +FAA=<value>
+
+Valid values:   0,1
+
+Default value   0
+
+   +FAA=0   constrains the DCE to answer as set by +FCLASS
+
+   +FAA=1   indicates that the DCE can answer and automatically
+determine whether to answer as a Class 2 facsimile DCE or as a data
+modem.  If the DCE automatically switches, if modifies FCLASS
+appropriately.
+
+Class 2 adaptive answer is implemented as follows:
+
+First, a data mode handshake is attempted.  If the DCE has been
+configured for automode detection (using the A command), the DCE may try
+several protocols be terminating attempts to make a data mode
+connection.  This can take as long as 6-8 seconds.
+
+If the data mode connection attempt fails, a facsimile Class 2
+connection is assumed.  When a connection is made, a result of the
+adaptive answer, the DCE issues the D or FAX result code before the
+CONNECT or +FCC message to inform the DTE of the connection type.  A
+making a class 2 connection, the DCE stays on-line rather than going
+into the command mode as with a Class 2 connection.
+
+7.5.12  +FBUF?, BUFFER SIZE
+
+Read syntax:   +FBUF?
+
+DCE response syntax <bs>,<xoft>,<xont>,<bc> where:
+
+  <bs> = total buffer size
+  <xoft> = XOFF threshold
+  <xcont> = XON threshold
+  <bc> = current buffer byte count
+
+The +FBUF parameter allows the DTE to determine the characteristics of
+the DCE's data buffer.  Data buffers are used for flow control.  Use of
+the reported values allow the DTE to transfer data without provoking
+XOFF.
+
+
+7.6  EXAMPLE SESSIONS
+
+Table 7-6 and 7-7 show the typical command and responses for sending and
+receiving two pages respectively.
+
+              Table 7-6 Send two pages, 1-D data, no errors
+|----------------------------------------------------------------------|
+| DTE COMMAND | DCE RESPONSE | LOCAL DTE ACTION |REMOTE STATION ACTION |
+|-------------|--------------|------------------|----------------------|
+| AT+FCLASS=2 | OK           | Set Class 2      |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FLID=    |              |                  |                      |
+| <local id>  | OK           | Set local ID     |                      |
+|-------------|--------------|------------------|----------------------|
+| AT<dial str>|              | off hook, dial   | answer               |
+|             |              | send CNG         | send [CED],          |
+|             | +FCON        | detect flags     | v.21 flags           |
+|             | +FDIS:<csi>  | get CSI          | CSI                  |
+|             | +FDIS:<codes>| get DIS          | DIS                  |
+|             | OK           |                  |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FDT      |              | send TSI         | get TSI              |
+|             |              | send DCS         | get DCS              |
+|             |              | send TCF         | get TCF              |
+|             | +FDCS:<codes>| get CFR          | send CFR             |
+|             | CONNECT      | send carrier     | receive carrier      |
+|             | <XON>        |                  |                      |
+| <1st page>  |              | send page data   | receive page data    |
+| <DLE><ETX>  | OK           |                  |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FET=0    |              | send RTC         | get RTC              |
+|             |              | get MPS          | send MPS             |
+|             | +FPTS:1      | get MCF          | send MCF             |
+|             | OK           |                  |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FDT      | CONNECT      | send carrier     | receive carrier      |
+|             | <XON>        |                  |                      |
+| <2nd page>  |              | send page data   | receive page data    |
+| <DLE><ETX>  | OK           |                  |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FET=2    |              | send RTC         | get RTC              |
+|             |              | send EOP         | get EOP              |
+|             | +FPTS:1      | get MCF          | send MCF             |
+|             | +FHNG:0      | send DCN         | get DCN              |
+|             | OK           | hangup           | hangup               |
+|-------------|--------------|------------------|----------------------|
+
+
+              Table 7-7 Receive two pages, 1-D data, no errors
+|----------------------------------------------------------------------|
+| DTE COMMAND | DCE RESPONSE | LOCAL DTE ACTION |REMOTE STATION ACTION |
+|-------------|--------------|------------------|----------------------|
+| AT+FCR=1    | OK           | Enable reception |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FLID=    |              |                  |                      |
+| <local id>  | OK           | Set local ID     |                      |
+|-------------|--------------|------------------|----------------------|
+|             | RING    <-   | detect ring  <-  | Dials[, send CNG]    |
+|-------------|--------------|------------------|----------------------|
+| ATA         |              | off hook         |                      |
+|             |              | send CED         | get CED              |
+|             |              | send CSI         | get CSI              |
+|             |              | send DIS         | get DIS              |
+|             | +FCON        | detect flags     | send v.21 flags      |
+|             |[+FTSI:"<tsi>"] [get TSI]        | [send TSI]           |
+|             | +FDCS:<codes>| get DCS          | send DCS             |
+|             | OK           | begin TCF receive| start TCF            |
+|-------------|--------------|------------------|----------------------|
+| AT+FDR      |              | accept TCF       | finish TCF           |
+|             | +FCFR        | send CFR         | get CFR              |
+|             |[+FDCS:<codes>]                  |                      |
+|             | CONNECT      | get page carrier | send page carrier    |
+| <DC2>       |              | get page data    | send page data       |
+|             |<page data stream>               |                      |
+|             | <DLE><ETX> <-| detect RTC   <-  | send RTC             |
+|             | +FPTS:1,<lc> |                  | drop carrier         |
+|             | +FET:0    <- | get MPS       <- | send MPS             |
+|             | OK           |                  |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FDR      |              | send MCF         | get MCF              |
+|             | CONNECT      | get page carrier | send page carrier    |
+| <DC2>       |              | get page data    | send page data       |
+|             |<page data stream>               |                      |
+|             | <DLE><ETX> <-| detect RTC   <-  | send RTC             |
+|             | +FPTS:1,<lc> |                  | drop carrier         |
+|             | +FET:2    <- | get EOP       <- | send EOP             |
+|             | OK           |                  |                      |
+|-------------|--------------|------------------|----------------------|
+| AT+FDR      |              | send MCF         | get MCF              |
+|             | +FHNG:0   <- | get DCN       <- | send DCN             |
+|             | OK           | hangup           | hangup               |
+|-------------|--------------|------------------|----------------------|
+
+
+-- 
+---
+   "The segment of our population most visibly susceptible to myth and most
+    productive in this regard are those who are `coming of age,' the young."
+
+                                                    Michael Benedikt,
+   dhs1@lehigh.edu                                  CYBERSPACE: First Steps
+
diff -urP mgetty-1.1.22/doc/mgetty.texi-in mgetty-current/doc/mgetty.texi-in
--- mgetty-1.1.22/doc/mgetty.texi-in	Mon Aug 14 21:52:04 2000
+++ mgetty-current/doc/mgetty.texi-in	Thu Nov 16 11:41:39 2000
@@ -1,6 +1,6 @@
 \input texinfo    @c -*-texinfo-*-
 @c %**start of header
-@c $Id$ (c) 1993-2000 Gert Doering and Klaus Weidner
+@c $Id$ (c) 1993-2000 Gert Doering and Klaus Weidner
 @setfilename mgetty.info
 @settitle mgetty + sendfax
 @c %**end of header
@@ -17,7 +17,7 @@
 @sp 6
 @center @titlefont{mgetty+sendfax}
 @sp 4
-@center Version 1.1.22
+@center Version 1.1.23
 @sp 1
 @center August 2000
 @sp 5
@@ -178,7 +178,10 @@
 
 The mailing list is archived on a WWW site, look at
 @file{http://www.elilabs.com/mgarc/index.html} (many thanks to
-Robert J. Brown, rj@@eli.elilabs.com)
+Robert J. Brown, rj@@eli.elilabs.com).  It's also archived by Marc
+Schaefer, on @file{http://www-internal.alphanet.ch/recherche_ml.html}.
+The latter search engine indexes somewhat more than only the mgetty list,
+so you might want to add 'mgetty' to your query to restrict it.
 
 @node Supported, Install, Overview, Intro
 @section Supported systems and modems
@@ -2972,7 +2975,7 @@
 * BSD::             BSD-like flavours of Unix
 * AIX::             IBM's AIX Operating System
 * SunOS::           SunOS 4.1.1 and up
-* Solaris2::        SunSoft Solaris 2.3 and 2.4
+* Solaris2::        SunSoft Solaris 2.3 and up
 * 3b1::             AT&T 3b1
 * HP-UX::           The HP-UX operating system
 * NEXTSTEP::        The NEXTSTEP operating system
@@ -3424,9 +3427,10 @@
 Please read also the generic BSD section.
 
 @node Solaris2, 3b1, SunOS, Systems
-@subsection Solaris 2.3 and 2.4
+@subsection Solaris 2.3 and up
 
-mgetty runs successfully and without trouble under Solaris 2.3 and 2.4.
+mgetty runs successfully and without trouble under Solaris 2.3, 2.4 and
+2.5.1 (later versions should also work, but I didn't get any report so far).
 For compilation use @code{-Dsolaris2}. With Solaris 2.3 it's recommended to use
 GNU gcc, but with Solaris 2.4 it compiles fine with the SPARCompiler C 3.0.1.
 Define @code{CC=cc}.
@@ -3461,6 +3465,13 @@
 entries in @file{/etc/saf/_sactab} and @file{/etc/saf/zsmon/_pmtab}.}
 
 Many thanks to Stefan Muehlenweg (muehlenw@@samhh.hanse.DE) for this section.
+
+Solaris (as all Sun operating systems) seems to be somewhat weird
+concerning its handling of the RTS line.  I have received two reports that
+'sometimes' a modem hangs during initialization, and won't talk to mgetty
+anymore.  In these cases, the problem went away when the modem (an USR
+Sportster) was set to @code{AT&R1}, which means 'ignore RTS line'.  Thanks
+to Valerio Di Giampietro for detailing this.
 
 @node 3b1, HP-UX, Solaris2, Systems
 @subsection AT&T 3b1
diff -urP mgetty-1.1.22/elsa/faxfile.c mgetty-current/elsa/faxfile.c
--- mgetty-1.1.22/elsa/faxfile.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/elsa/faxfile.c	Thu Nov 16 11:41:53 2000
@@ -0,0 +1,127 @@
+#ident "$Id$"
+
+/* faxfile.c
+ *
+ * Auxiliary functions for fax (raw G3 or TIFF/F) file access
+ *
+ * the idea behind this is that all the G3-writing (and reading) programs 
+ * can access a single interface to "raw G3", digifax, and TIFF files
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+#ifndef ENOENT
+# include <errno.h>
+#endif
+
+#include "mgetty.h"
+
+/* for fax rec stuff */
+#define ETX     003
+#define DLE     020
+#define SUB     032
+#define DC2     022
+
+static int fax_out_fd;
+
+#define BUFSIZE 1024
+static unsigned char fo_buf[BUFSIZE+20];
+static int fo_bufidx;
+static int fo_was_dle;
+
+static unsigned char fo_swaptable[256];
+
+/* set up bit swap table to "direct" or "reverse bits"
+ */
+void fax_init_swaptable _P2( (direct, byte_tab),
+                              int direct, unsigned char byte_tab[] )
+{
+int i;
+    if ( direct ) for ( i=0; i<256; i++ ) byte_tab[i] = i;
+    else
+      for ( i=0; i<256; i++ )
+             byte_tab[i] = ( ((i & 0x01) << 7) | ((i & 0x02) << 5) |
+                             ((i & 0x04) << 3) | ((i & 0x08) << 1) |
+                             ((i & 0x10) >> 1) | ((i & 0x20) >> 3) |
+                             ((i & 0x40) >> 5) | ((i & 0x80) >> 7) );
+}
+
+/* open file "name" for output, set up swaptable
+ */
+int faxfile_write_g3 _P2((name, direct),
+			char * name, int direct)
+{
+    fax_out_fd = open( name, O_WRONLY | O_CREAT | O_TRUNC, 0644 );
+
+    if ( fax_out_fd < 0 )
+    {
+    	lprintf( L_ERROR, "can't open '%s' for writing", name );
+	return -1;
+    }
+
+    fo_bufidx = 0;
+    fo_was_dle = 0;
+
+    fax_init_swaptable( direct, fo_swaptable );
+
+    return 0;
+}
+
+/* strip DLE characters, recognize DLE ETX, swap bits if needed
+ * return values: 0 = ok, >0 = end of file, -1 = error
+ */
+int faxfile_wbyte _P1((byte), unsigned char byte)
+{
+    if ( !fo_was_dle )
+    {
+	if ( byte == DLE ) fo_was_dle = 1;
+		      else fo_buf[fo_bufidx++] = fo_swaptable[byte];
+    }
+    else				/* last character WasDLE */
+    {
+	if ( byte == DLE ) 		/* DLE DLE -> DLE */
+	    { fo_buf[fo_bufidx++] = fo_swaptable[byte]; }
+	else
+	  if ( byte == SUB )		/* DLE SUB -> 2x DLE */
+	{
+	    fo_buf[fo_bufidx] = fo_buf[fo_bufidx+1] = fo_swaptable[DLE];
+	    fo_bufidx+=2;
+	}
+	else
+	  if ( byte == ETX )
+	{
+	    lprintf( L_NOISE, "DLE ETX -> page complete" );
+	    if ( write( fax_out_fd, fo_buf, fo_bufidx ) != fo_bufidx )
+	    {
+	    	lprintf( L_ERROR, "can't write all %d bytes to file", fo_bufidx );
+		close( fax_out_fd );
+		return -1;
+	    }
+	    close( fax_out_fd );
+	    return 1;
+	}
+
+	fo_was_dle=0;
+    }
+
+    if ( fo_bufidx >= BUFSIZE )	/* buffer full */
+    {
+    	if ( write( fax_out_fd, fo_buf, BUFSIZE ) != BUFSIZE )
+	{
+	    lprintf( L_ERROR, "can't write all %d bytes to file", BUFSIZ);
+	    close( fax_out_fd );
+	    return -1;
+	}
+	fo_bufidx -= BUFSIZE;
+
+	if ( fo_bufidx > 0 )	/* some leftover bytes */
+		memcpy( fo_buf, fo_buf+BUFSIZE, fo_bufidx );
+    }
+
+    return 0;
+}
+
diff -urP mgetty-1.1.22/elsa/mlo.c mgetty-current/elsa/mlo.c
--- mgetty-1.1.22/elsa/mlo.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/elsa/mlo.c	Thu Nov 16 11:41:53 2000
@@ -0,0 +1,490 @@
+#ident "$Id$"
+
+/* mlo.c
+ *
+ * Command-Line interface to ELSA MicroLink Office modem
+ * (upload/download files, convert ADPCM to .RMD files, convert .T4* to G3)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+#ifndef ENOENT
+# include <errno.h>
+#endif
+
+#include "version.h"
+#include "mgetty.h"
+#include "tio.h"
+#include "policy.h"
+
+/* for RMD stuff */
+#include "voice/include/header.h"
+#include <netinet/in.h>
+
+rmd_header elsa_rmd = { "RMD1", "Elsa", 0, 0, 0, { 0,0,0,0,0,0,0 }};
+
+/* for fax rec stuff */
+#define ETX     003
+#define DLE     020
+#define SUB     032
+#define DC2     022
+
+int verbose=1;
+
+extern int xmodem_blk;
+
+int open_device _P3( (tty, tio, speed), char * tty, TIO *tio, int speed )
+{
+    char	device[MAXPATH];
+    int	fd;
+
+    int tries;
+    
+    /* ignore leading "/dev/" prefix */
+    if ( strncmp( tty, "/dev/", 5 ) == 0 ) tty += 5;
+    
+    if ( verbose ) printf( "Trying fax device '/dev/%s'... ", tty );
+
+    tries = 0;
+    while ( makelock( tty ) != SUCCESS )
+    {
+	if ( ++ tries < 3 )
+	{
+	    if ( verbose ) { printf( "locked... " ); fflush( stdout ); }
+	    sleep(5);
+	}
+	else
+	{
+	    if ( verbose ) { printf( "locked, give up!\n" );
+			     fflush( stdout ); }
+	    lprintf( L_MESG, "cannot lock %s", tty );
+	    return -1;
+	}
+    }
+    
+    sprintf( device, "/dev/%s", tty );
+
+    if ( ( fd = open( device, O_RDWR | O_NDELAY ) ) == -1 )
+    {
+	lprintf( L_ERROR, "error opening %s", device );
+	if ( verbose ) printf( "cannot open %s: %s!\n", device, strerror(errno) );
+	rmlocks();
+	return fd;
+    }
+
+    /* unset O_NDELAY (otherwise waiting for characters */
+    /* would be "busy waiting", eating up all cpu) */
+
+    if ( fcntl( fd, F_SETFL, O_RDWR ) == -1 )
+    {
+	lprintf( L_ERROR, "error in fcntl" );
+	close( fd );
+	if ( verbose ) printf( "cannot fcntl!\n" );
+	rmlocks();
+	return -1;
+    }
+
+    /* initialize baud rate, hardware handshake, ... */
+    tio_get( fd, tio );
+
+    tio_mode_sane( tio, TRUE );
+    tio_set_speed( tio, speed );
+    tio_mode_raw( tio );
+#ifdef sun
+    /* sunos does not rx with RTSCTS unless carrier present */
+    tio_set_flow_control( fd, tio, FLOW_SOFT );
+#else
+    tio_set_flow_control( fd, tio, FLOW_HARD );
+#endif
+    
+    if ( tio_set( fd, tio ) == ERROR )
+    {
+	lprintf( L_ERROR, "error in tio_set" );
+	close( fd );
+	if ( verbose ) printf( "cannot set termio values!\n" );
+	rmlocks();
+	return -1;
+    }
+
+    log_init_paths( NULL, NULL, &tty[ strlen(tty)-3 ] );
+    lprintf( L_NOISE, "open_device succeeded, %s -> %d", tty, fd );
+    
+    if ( verbose ) printf( "OK.\n" );
+
+    return fd;
+}
+
+/* finish off - close modem device, rm lockfile */
+
+void modem_close _P1( (fd),
+		    int fd )
+{
+    tio_flush_queue( fd, TIO_Q_BOTH );		/* unlock flow ctl. */
+    mdm_send( "ATZ", fd );
+    delay(500);
+    tio_flush_queue( fd, TIO_Q_BOTH );		/* unlock flow ctl. */
+    close( fd );
+    rmlocks();
+}
+
+TIO modem_tio;
+
+
+/* -------------------------------------------------------------------- */
+
+/* query modem type, model, and firmware version */
+int elsa_query _P1((fd), int fd)
+{
+char * l;
+
+    l = mdm_get_idstring( "ATI", 1, fd );
+    lprintf( L_NOISE, "mdm_identify: string '%s'", l );
+    
+    if ( strcmp( l, "<ERROR>" ) == 0 ) 
+    {
+	lprintf( L_WARN, "mdm_identify: can't get modem ID" );
+	return -1;
+    }
+
+    if ( strcmp( l, "282" ) != 0 )
+    {
+	lprintf( L_WARN, "mdm_identify: no ELSA modem" );
+	return -1;
+    }
+
+    l = mdm_get_idstring( "AT+GMM?", 1, fd );
+
+    if ( strcmp( l, "<ERROR>" ) == 0 ||
+         strcmp( l, "+GMM: \"MicroLink Office\"" ) != 0 )
+    {
+    	lprintf( L_WARN, "mdm_identify: no ELSA ML Office" );
+	return -1;
+    }
+
+    l = mdm_get_idstring( "AT+GMR?", 1, fd );
+
+    if ( verbose ) printf( "query: found ELSA MicroLink modem, version info: %s\n", l );
+    return 0;
+}
+
+int elsa_list_dir _P1((fd), int fd)
+{
+char * l;
+
+    if ( mdm_send( "AT$JDIR", fd ) == ERROR ) return -1;
+
+    while( ( l = mdm_get_line( fd ) ) != NULL )
+    {
+	if ( strcmp( l, "AT$JDIR" ) == 0 ) continue;		/* echo */
+	if ( strcmp( l, "OK" ) == 0 ) { return 0; }		/* done */
+
+    	printf( "dir: %s\n", l );
+    }
+    return -1;
+}
+
+
+int elsa_download_raw _P5((fd, nam1, nam2, buf, len), 
+			int fd, char * nam1, char * nam2, 
+			char * header_buf, int header_len)
+{
+char buf[1050];
+int outfd;
+int s;				/* xmodem block size */
+int total=0;
+
+    /* open output file for saving */
+    outfd = open( nam2, O_WRONLY|O_CREAT |O_TRUNC, 0644 );
+    if ( outfd < 0 )
+    {
+	lprintf( L_ERROR, "can't write to %s", nam2);
+        fprintf( stderr, "can't write to %s: %s\n", nam2, strerror(errno));
+	return -1;
+    }
+
+    sprintf( buf, "AT$JDNL=\"%s\"", nam1 );
+    if ( mdm_send( buf, fd ) == ERROR )
+    {
+        lprintf( L_ERROR, "can't send download command (%s)", buf );
+	fprintf( stderr, "can't send download command (%s)\n", buf );
+	close(outfd);
+	unlink(nam2);
+	return -1;
+    }
+
+    s = xmodem_rcv_init( fd, NULL, buf );
+
+    if ( s <= 0 ) 
+    {
+        lprintf( L_ERROR, "XModem startup failed" );
+        fprintf( stderr, "XModem startup failed\n" );
+	close(outfd);
+	unlink(nam2);
+	return -1;
+    }
+
+    if ( header_buf != NULL && header_len>0 )
+    {
+	lprintf( L_NOISE, "writing %d byte header", header_len );
+    	if ( write( outfd, header_buf, header_len ) != header_len )
+	{
+	    lprintf( L_ERROR, "can't write header to %s: %s", nam2, strerror(errno));
+	    fprintf( stderr, "can't write header to %s: %s", nam2, strerror(errno));
+	    close(outfd);
+	    unlink(nam2);
+	    return -1;
+	}
+    }
+
+    do
+    {
+    	if ( write( outfd, buf, s ) != s ) 
+	{
+	    lprintf( L_ERROR, "can't write %d bytes to %s: %s",
+	    		s, nam2, strerror(errno) );
+	    fprintf( stderr, "can't write %d bytes to %s: %s\n",
+	    		s, nam2, strerror(errno) );
+	    close(outfd);
+	    return -1;
+	}
+	total += s;
+	printf( "block #%d, bytes %d\r", xmodem_blk, total ); fflush( stdout );
+
+        s = xmodem_rcv_block( buf );
+
+	lprintf( L_JUNK, "ed: s=%d", s );
+    }
+    while( s > 0 );
+    close(outfd);
+
+    if ( s < 0 )
+    {
+    	lprintf( L_ERROR, "can't receive expected block" );
+    	fprintf( stderr, "can't receive expected block\n" );
+	return -1;
+    }
+
+    printf( "%s received successfully\n", nam2);
+    return 0;
+}
+
+/* download voice file - basically "download raw, prepend RMD header"
+ */
+int elsa_download_voice _P5((fd, nam1, nam2, bits, speed),
+			int fd, char * nam1, char * nam2, 
+			int bits, int speed )
+{
+/* compression 2/3/4 = ADPCM-2/3/4, bits = compression fuer ADPCM */
+    elsa_rmd.compression = htons(bits);
+    elsa_rmd.speed = htons(speed);
+    elsa_rmd.bits = bits;
+
+    return elsa_download_raw(fd, nam1, nam2, 
+    			     (char *)&elsa_rmd, sizeof(elsa_rmd));
+}
+
+/* download fax file - remove DLE stuffing, interpret +F sequences
+ */
+int elsa_download_fax _P3((fd, nam1, nam2),
+			int fd, char * nam1, char * nam2 )
+{
+char buf[1050], line[200], ch;
+int outfd;
+int s,i,l,			/* xmodem block size */
+    in_g3 = 0;			/* G3 mode (vs. "line mode") */
+int total=0;
+int pagenr=0;			/* current page number */
+
+    sprintf( buf, "AT$JDNL=\"%s\"", nam1 );
+    if ( mdm_send( buf, fd ) == ERROR )
+    {
+        lprintf( L_ERROR, "can't send download command (%s)", buf );
+	fprintf( stderr, "can't send download command (%s)\n", buf );
+	close(outfd);
+	return -1;
+    }
+
+    s = xmodem_rcv_init( fd, NULL, buf );
+
+    if ( s <= 0 ) 
+    {
+        lprintf( L_ERROR, "XModem startup failed" );
+        fprintf( stderr, "XModem startup failed\n" );
+	close(outfd);
+	unlink(nam2);
+	return -1;
+    }
+
+    /* nothing in line buffer yet */
+    l = 0;
+
+    do
+    {
+    	/* handle block */
+	for ( i=0; i<s; i++ )
+	{
+	    ch = buf[i];
+
+	    if ( !in_g3 )		/* +F... responses */
+	    {
+		lputc( L_JUNK, ch );
+	    	if ( ch != 0x0a && ch != 0x0d )
+		{
+		    if ( l < sizeof(line)-1 )  line[l++]=ch;
+		}
+		else			/* line full */
+		{
+		    if ( l==0 ) continue;
+
+		    line[l]='\0';
+		    lprintf( L_NOISE, "line: '%s'", line );
+		    if ( strncmp( line, "CONNECT", 6 ) == 0 )
+		    {
+			pagenr++;
+			sprintf( line, "%s.%02d", nam2, pagenr );
+			if ( faxfile_write_g3( line, 0 ) < 0 )
+			{
+			    fprintf( stderr, "can't open '%s': %s\n", 
+			    	    line, strerror(errno) );
+			    return -1;
+			}
+		        in_g3 = 1;
+		    }
+		    l=0;
+		}
+	    }
+	    else			/* save data, until <DLE><ETX> */
+	    {
+	        int rc = faxfile_wbyte( ch );
+
+		if ( rc != 0 )
+		{
+		    if ( rc < 0 ) return -1;		/* error */
+		    in_g3 = 0;		/* file complete */
+		}
+	    }
+	}
+
+	total += s;
+	printf( "page %d, block #%d, bytes %d\r", pagenr, xmodem_blk, total ); 
+	fflush( stdout );
+
+	/* get next block (or final EOT) */
+        s = xmodem_rcv_block( buf );
+    }
+    while( s > 0 );
+
+    close(outfd);
+
+    if ( s < 0 )
+    {
+    	lprintf( L_ERROR, "can't receive expected block" );
+    	fprintf( stderr, "can't receive expected block\n" );
+	return -1;
+    }
+
+    printf( "%s received successfully\n", nam2);
+    return 0;
+}
+
+/* -------------------------------------------------------------------- */
+
+
+void exit_usage _P1((s), char * s)
+{
+    if ( s ) fprintf( stderr, "mlo: %s\n", s );
+    fprintf( stderr, "usage: mlo -v -x<level> <device>\n" );
+    exit(1);
+}
+
+int main _P2( (argc, argv),
+	      int argc, char ** argv )
+{
+    int	fd;
+    int opt;
+    boolean opt_T = FALSE;			/* test mode */
+    int opt_s = 38400;				/* DTE/DCE speed */
+    char * Device;
+
+    /* initialize logging */
+    log_init_paths( argv[0], "/var/log/mlo.log", NULL );
+
+    lprintf( L_MESG, "mlo: %s", mgetty_version );
+    lprintf( L_NOISE, "%s compiled at %s, %s", __FILE__, __DATE__, __TIME__ );
+
+#ifdef HAVE_SIGINTERRUPT
+    /* interruptible system calls */
+    siginterrupt( SIGINT,  TRUE );
+    siginterrupt( SIGALRM, TRUE );
+    siginterrupt( SIGHUP,  TRUE );
+#endif
+
+    while ((opt = getopt(argc, argv, "x:Ts:")) != EOF)
+    {
+	switch (opt)
+	{
+	  case 'x':	/* debug level */
+	  	log_set_llevel( atoi(optarg) ); break;
+	  case 'T':	/* Testing */
+	  	opt_T = TRUE; break;
+	  case 's':	/* download speed */
+	  	opt_s = atoi(optarg); break;
+	  case '?':
+	    exit_usage(NULL);
+	    break;
+	}
+    }
+
+    /* device name is on the command line */
+    if ( optind >= argc ) { exit_usage("missing device name"); }
+
+    Device = argv[optind++];
+
+    fd = open_device( Device, &modem_tio, opt_s );
+
+    if ( fd < 0 ) { exit(2); }
+
+    delay(200);					/* give modem time to settle */
+    tio_flush_queue(fd, TIO_Q_BOTH);		/* clear junk */
+
+    /* Is there a modem...? */
+    if ( mdm_command( "ATV1Q0", fd ) == ERROR )
+    {
+	/* no??!? -- try again, maybe modem was just unwilling... */
+	if ( mdm_command( "ATV1Q0", fd ) == ERROR )
+	{
+	    lprintf( L_AUDIT, "failed initializing modem, dev=%s", Device );
+	    fprintf( stderr, "The modem doesn't respond!\n" );
+	    tio_flush_queue( fd, TIO_Q_BOTH );	/* unlock flow ctl. */
+	    close(fd);
+	    rmlocks();
+	    exit(3);
+	}
+	lprintf( L_WARN, "retry succeded, dev=%s", Device );
+    }
+
+    /* make sure there IS an Elsa modem */
+    if ( elsa_query( fd ) < 0 ) 
+    	{ modem_close(fd); exit(7); }
+
+    elsa_list_dir( fd );
+
+    /* now present user with command line, unless "testing only" */
+    if ( opt_T )
+    {
+/*	elsa_download_voice( fd, "19990330211355.VOI", "/tmp/v1.rmd", 4, 7200);
+	elsa_download_voice( fd, "19990405121736.VOI", "/tmp/v2.rmd", 4, 7200);
+*/
+/*	elsa_download( fd, "GREET_000.GRT", "/tmp/grt" );*/
+	elsa_download_fax( fd, "19990405132347.FAX", "/tmp/f2.fax");
+	exit(0);
+    }
+
+    modem_close(fd);
+
+    return 0;
+}
diff -urP mgetty-1.1.22/elsa/xmodem.c mgetty-current/elsa/xmodem.c
--- mgetty-1.1.22/elsa/xmodem.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/elsa/xmodem.c	Thu Nov 16 11:41:53 2000
@@ -0,0 +1,240 @@
+#ident "$Id$"
+
+/* xmodem.c
+ *
+ * XModem-primitives for uploading and downloading from an already 
+ * open file descriptor (no terminal handling etc)
+ *
+ * warning: these functions use alarm() and mess up SIGALRM handlers
+ *
+ * $Log$
+ * Revision 1.3  1999/04/11 21:11:36  gert
+ * cleanup
+ *
+ * Revision 1.2  1999/04/05 20:43:15  gert
+ * - add ELSA-EOT (NAKing EOT doesn't work, recognize 0d/0a/OK/0d/0a
+ * - add "all-in-one" download function
+ * - fix timeout bug
+ *
+ * Revision 1.1  1999/03/31 21:03:22  gert
+ * XModem primitives - first cut, downloading works
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+#ifndef ENOENT
+# include <errno.h>
+#endif
+
+#include "mgetty.h"
+
+/* defines for the XModem protocol */
+#define ACK	0x06			/* Acknowledge */
+#define NAK	0x15			/* Not Acknowledge */
+#define CAN	0x18			/* CANcel transmission (ctrl-X) */
+#define SOH	0x01			/* start of block, 128byte */
+#define STX	0x02			/* start of block, 1024byte */
+#define EOT	0x04			/* end of transmission */
+
+static char c_ack = ACK, c_nak = NAK;	/* to be used for write() */
+
+static int x_errcnt=0;			/* error counter */
+static int x_eotcnt=0;			/* EOT counter */
+       int xmodem_blk=0;		/* current block number */
+
+/* message function is specified by a pointer to a (char *, ...) function */
+typedef void (*msg_func_t)(char *,...);
+
+/* semi-globals */
+static int x_fd;			/* file descriptor to "modem" */
+static msg_func_t x_msg_func;		/* message function for logging */
+
+/* prototypes */
+static int x_nak(void);
+int xmodem_rcv_block _PROTO((unsigned char *buf));
+
+/* helper for x_timeout handling */
+static int x_timeout=0;
+static void x_sigalarm(int s)
+{ 
+    signal(SIGALRM, x_sigalarm); 
+    x_timeout=1;
+}
+
+/* initialize XModem receiver
+ */
+int xmodem_rcv_init _P3((fd, msg_func, buf),
+			int fd, msg_func_t msg_func, char *buf)
+{
+    x_fd = fd;
+    x_msg_func = msg_func;
+    signal(SIGALRM, x_sigalarm);
+
+    xmodem_blk = 1;
+    x_errcnt = x_eotcnt = 0;
+
+    x_nak();
+    return xmodem_rcv_block(buf);
+}
+
+/* get next block
+ */
+int xmodem_rcv_block _P1((buf), unsigned char *buf)
+{
+unsigned char ch;
+int got_can=0, ok_seq_cnt=0;
+int len, i, chks;
+static char ok_seq[] = { 0x0d, 0x0a, 'O', 'K', 0x0d, 0x0a };
+
+again:
+    alarm(10); 
+
+    lprintf( L_NOISE, "xmodem_rcv_block, got:" );
+
+    do
+    {
+	if ( read( x_fd, &ch, 1 ) < 1 ) { goto send_nak; }
+	lputc( L_NOISE, ch );
+
+	/* if we get two CANs in sequence, give up
+	 */
+	if ( ch == CAN ) 
+	    { lprintf( L_NOISE, "<CAN>" );
+	      if ( ++got_can > 1 ) { x_errcnt=10; return -1;}}
+	else 
+	    { got_can=0; }
+
+	/* the XModem protocol description suggests that the first EOT
+	 * should be NAKed, and the second one should be accepted - 
+	 * problem with that is, the ELSA doesn't send a second EOT,
+	 * so we accept \r\nOK\r\n as "second EOT"
+	 */
+	if ( ch == EOT ) 
+	{ 
+	    x_eotcnt++;
+	    if ( x_eotcnt < 2 )		/* false alarm? NAK! */
+	    	goto send_nak;
+	    return 0;			/* EOF */
+	}
+
+	if ( ch == ok_seq[ok_seq_cnt] )
+	{
+	    ok_seq_cnt++;
+	    lputs( L_JUNK, "<s>" );
+	    if ( ok_seq_cnt >= 6 )
+	    	{ lprintf( L_NOISE, "ELSA-EOT" ); return 0; }
+	}
+	else ok_seq_cnt= ( ch == ok_seq[0] );
+    }
+    while( ch != SOH && ch != STX );
+
+    len = ( ch == SOH )? 128: 1024;
+    lprintf( L_NOISE, "got SOH/STX, block size=%d", len );
+
+    if ( read( x_fd, &ch, 1 ) < 1 || ch != (xmodem_blk & 0xff) ) 
+	{ fprintf( stderr, "Block # %d doesn't match %d\n", ch, xmodem_blk); 
+	  goto send_nak; }
+    if ( read( x_fd, &ch, 1 ) < 1 || ch != 255-(xmodem_blk & 0xff) ) 
+	{ fprintf( stderr, "!Block # %d doesn't match %d\n", ch, xmodem_blk); 
+	  goto send_nak; }
+    
+    lprintf( L_NOISE, "expected seq.# %d ok, read block", xmodem_blk );
+    chks=0;
+
+    for( i=0; i<len; i++ )
+    {
+	if ( read( x_fd, &buf[i], 1 ) < 1 ) { goto send_nak; }
+	chks += buf[i];
+    }
+
+    if ( read( x_fd, &ch, 1 ) < 1 || ch != (chks &0xff)) 
+    { lprintf( L_WARN, "Chksum %02x doesn't match %02x\n", ch, (chks & 0xff)); 
+      goto send_nak; }
+
+    alarm(0);
+    
+    lprintf( L_NOISE, "Block %d len %d ok, send ACK\n", xmodem_blk, len );
+    write( x_fd, &c_ack, 1 );
+    xmodem_blk++;
+    return len;
+
+send_nak:
+    x_nak();
+    x_errcnt++;
+    if ( x_errcnt<10 ) goto again;
+
+    alarm(0);
+    lprintf( L_MESG, "too many NAKs, giving up" );
+    return -1;
+}
+
+static int x_nak(void)
+{
+    char ch;
+
+    lprintf( L_JUNK, "x_nak: drain queue, send NAK, got:" );
+
+    /* drain input queue - make sure we're not in the middle of a block
+     */
+    x_timeout=0;
+    while(!x_timeout)
+    { 
+	alarm(1);
+	if ( read( x_fd, &ch, 1 ) != 1 && errno != EINTR ) 
+		{ alarm(0); return -1; }
+	lputc( L_JUNK, ch );
+    }
+
+    /* send NAK */
+    return write( x_fd, &c_nak, 1 );
+}
+
+int xmodem_rcv_file _P3(( modem_fd, out_fd, msg_func),
+			 int modem_fd, int out_fd, msg_func_t msg_func )
+{
+int s;
+char buf[1030];
+
+    s = xmodem_rcv_init( modem_fd, msg_func, buf );
+
+    if ( s <= 0 ) 
+    {
+        lprintf( L_ERROR, "XModem startup failed" );
+        fprintf( stderr, "XModem startup failed\n" );
+	close(out_fd);
+	return -1;
+    }
+
+    do
+    {
+    	if ( write( out_fd, buf, s ) != s ) 
+	{
+	    lprintf( L_ERROR, "can't write %d bytes to file: %s",
+	    		s, strerror(errno) );
+	    fprintf( stderr, "can't write %d bytes to file: %s\n",
+	    		s, strerror(errno) );
+	    close(out_fd);
+	    return -1;
+	}
+	printf( "block #%d\r", xmodem_blk ); fflush( stdout );
+
+        s = xmodem_rcv_block( buf );
+    }
+    while( s > 0 );
+
+    if ( s < 0 )
+    {
+    	lprintf( L_ERROR, "can't receive expected block" );
+    	fprintf( stderr, "can't receive expected block\n" );
+	return -1;
+    }
+
+    close(out_fd);
+
+    return 0;
+}
diff -urP mgetty-1.1.22/faq/SGML/FAQ.sgml mgetty-current/faq/SGML/FAQ.sgml
--- mgetty-1.1.22/faq/SGML/FAQ.sgml	Thu Aug 10 22:37:20 2000
+++ mgetty-current/faq/SGML/FAQ.sgml	Thu Nov 16 11:41:52 2000
@@ -7,7 +7,7 @@
               which are now maintained by Marc Schaefer
 <author>			 Klaus Lichtenwalder, now maintained by
                                  Marc Schaefer
-<date>$Date$
+<date>$Date$
 
 <abstract>
 This document attempts to answer the most frequently asked questions
@@ -1298,6 +1298,14 @@
 in post-init-chat: 
 <p>
 post-init-chat "" AT#CID=1 OK
+
+<sect1>Garbage instead of RINGs with vgetty<label id="speed mismatch">
+<p>
+From: Marc SCHAEFER
+<p>
+Garbage instead of RINGs with vgetty usually mean that the mgetty and
+vgetty speed do not match. Set both to 115200.
+<p>
 
 <sect1>Can you dialout and play a voice message on phone pickup with vm? <label id="vm dialout">
 <p>
diff -urP mgetty-1.1.22/faq/SGML/FAQ.txt-generated-with-SGML-tools-maybe-not-uptodate mgetty-current/faq/SGML/FAQ.txt-generated-with-SGML-tools-maybe-not-uptodate
--- mgetty-1.1.22/faq/SGML/FAQ.txt-generated-with-SGML-tools-maybe-not-uptodate	Thu Jan  1 01:00:00 1970
+++ mgetty-current/faq/SGML/FAQ.txt-generated-with-SGML-tools-maybe-not-uptodate	Thu Nov 16 11:41:53 2000
@@ -0,0 +1,1323 @@
+  Answers to Frequently-Asked Questions regarding Gert Doer-
+  ing's Fax-enabled getty replacement, with Klaus Weidner and
+  Marc Eberhard's voice extensions, which are now maintained
+  by Marc Schaefer ``mgetty+sendfax''
+  Klaus Lichtenwalder
+  May 15, 1998
+
+  This document attempts to answer the most frequently asked questions
+  about mgetty+sendfax/vgetty, Gert Doering's fax-enabled getty replace-
+  ment with Klaus Weidner's and Marc Eberhard's voice processing exten-
+  sions.  The official release of mgetty is now (at least) 1.0. Gert
+  adopted the numbering scheme of the Linux kernel, with even release
+  numbers (1.0, 1.2,...) being production version and uneven numbers
+  being development versions. Pls note that in 1.0 there's no vgetty
+  support as that is being revamped. If you need voice, you have to go
+  for older versions or, far better, for the newer development tree.
+  I'm glad I can announce a Japanese Version made by chie nakatani
+  <jeanne@mbox.kyoto-inet.or.jp>. You can find it at <URL:http://epse-
+  newsc.gee.kyoto-u.ac.jp/JF/JF-ftp/euc/mgetty_j.euc> This document is
+  copyrighted by the FAQ Maintainer, K.Lichtenwalder. It may not be
+  reproduced in part or in full without the written consent of the FAQ
+  Maintainer.
+  ______________________________________________________________________
+
+  Table of Contents:
+
+  1.      Part I: "Deciding whether to use it" questions
+
+  1.1.    What is it?
+
+  1.2.    What does it look like when it runs?
+
+  1.3.    What do I need to use mgetty+sendfax/vgetty?
+
+  1.4.    What other software do I need?
+
+  1.5.    What terms cover my use of mgetty+sendfax/vgetty?
+
+  1.6.    Where can I get mgetty+sendfax?
+
+  1.7.    How can I integrate it into an office environment?
+
+  1.8.    What's going on with those Class 1 modems?
+
+  1.9.    What modems are recommended?
+
+  1.10.   Where is the list archived?
+
+  2.      Part 2: Other questions
+
+  2.1.    How can I contact mgetty/vgetty users and developers?
+
+  2.2.    Why doesn't mgetty accept other file formats besides G3?
+
+  2.3.    Why doesn't mgetty use the modem's autoanswer capabilities?
+
+  2.4.    Why mgetty ignores /dev/tty* dialin, /dev/cua* dialout
+  conventions:
+
+  2.5.    Troubleshooting questions & answers
+
+  2.6.    Programs generating "invalid" Postscript that can't converted
+
+  2.7.    My ZyXEL doesn't work right after a ROM upgrade: What's wrong?
+
+  2.8.    Why the occasional "tcsetattr failed: I/O error" message?
+
+  2.9.    When is mgetty actually running? (i.e. what can mgetty
+  control?)
+
+  2.10.   The user's shell doesn't get killed after the line drops
+
+  2.11.   AutoPPP appears in the "who" listing
+
+  2.12.   Things to think of if using AutoPPP, or, as you might call it,
+
+  2.13.   Viewing received faxes from a PC running windows
+
+  2.14.   Howto setup MSN/distinctive rings mappings
+
+  2.15.   Howto convert wav's to rmd's for mgetty
+
+  2.16.   Where can I get hp2pbm?
+
+  2.17.   My (ISDN/digital) modem doesn't say
+
+  2.18.   Is mgetty Y2K compliant?
+
+  3.      Part 3: Compatibility Issues
+
+  3.1.    Suspicious fax machines
+
+  3.2.    Caller ID
+
+  3.3.    Referral for Zyxel in US
+
+  4.      Part 4: Compiling, installing and using vgetty
+
+  4.1.    Compiling vgetty
+
+  4.2.    US Robotics voice format converter
+  ______________________________________________________________________
+
+  11..  PPaarrtt II:: ""DDeecciiddiinngg wwhheetthheerr ttoo uussee iitt"" qquueessttiioonnss
+
+  11..11..  WWhhaatt iiss iitt??
+
+  From: steve@work.bellingham.wa.us (Steve Work)
+
+  Mgetty+sendfax is a collection of programs to send and receive faxes
+  in a unix environment using a class 2.0 or 2 (they're different)
+  faxmodem.  vgetty is an extension to mgetty, distributed with it, that
+  implements incoming voice call handling for certain voice-capable
+  modems, with new ones added regularly, if specs are available.
+
+  More specifically, the program `mgetty' allows you to use a class 2.0
+  or 2 fax modem for receiving faxes and handling external logins
+  without interfering with outgoing calls.  `sendfax' is a standalone
+  program which sends fax files.  `vgetty' is an extended version of
+  mgetty that can answer the telephone like an answering machine and
+  record a voice-mail message (if it finds one), or perform `mgetty's
+  fax or data call handling otherwise.  The mgetty+sendfax distribution
+  includes vgetty and a good-sized gob of utility programs that help you
+  manage faxes and voice messages.
+
+  11..22..  WWhhaatt ddooeess iitt llooookk lliikkee wwhheenn iitt rruunnss??
+
+  From: steve@work.bellingham.wa.us (Steven Work) and the distribution
+  CC: clewis@ferret.ocunix.on.ca (Chris Lewis)
+
+  Like a smarter `getty'.  getty is the program that manages the first
+  step of the login procedure on a Unix computer; when used with a
+  modem, it watches for an incoming call and (ordinarily) prints the
+  "login:" prompt (and reads the username, and passes off to "login").
+
+  Unlike traditional versions of getty or uugetty, which will put a
+  modem into auto-answer mode, mgetty does not.  When an incoming call
+  occurs, mgetty sees the "RING"s when they occur (see note below for
+  ISDN/digital modems).  When they do occur, mgetty tells the modem to
+  answer, and the modem will tell mgetty what kind of connection
+  happens.  If it is FAX, mgetty will receive the FAX.  If data, mgetty
+  prompts for a userid, then hands the open line off to login for a
+  normal data login.
+
+  Note that it's the modem's job to distinguish a FAX call from a data
+  call.  Not all fax modems can do this, and if yours _can't_ there is
+  no way for mgetty to do this for it.  mgetty can be used with modems
+  that cannot distinguish a fax call from a data call, but you must tell
+  it ahead of time what type of call to expect.
+
+  mgetty is also configurable to select programs other than login for
+  special connections (eg: uucico, fido or other programs) depending on
+  the login userid.
+
+  mgetty also supports caller-id and can deny connections based on
+  originating telephone number.
+
+  vgetty is an extension to mgetty that works with voice-capable modems
+  to provide additional call-handling capabilities.  When the modem
+  reports a RING, vgetty has the modem pick up the line and play a voice
+  message (the greeting).  If the modem detects a data or fax calling
+  tone, it reports this back to vgetty with special codes (DLE-
+  sequences) which causes vgetty to switch to either mode. Else voice
+  mode is used. This comportment can be modified by using a voice
+  script, for example ``mvm'' (see below).
+
+  If instead the modem hears nothing following the greeting (a certain
+  level of silence that continues for a certain number of seconds) it
+  assumes the caller is a data modem and attempts a data connection.
+
+  vgetty implements the normal answering-machine functions of remote
+  message playback as well; its operation is driven from shell scripts,
+  so you can extend it to a full voice-mail jail if you wish.  (This
+  description of voice modem behavior applies to the ZyXELs; I
+  steve@work.bellingham.wa.us assume other voice modems are similar.)
+
+  For an example on how a voice mail system looks like, there is the mvm
+  <http://www-internal.alphanet.ch/~schaefer/mvm/> from Marc Schaefer.
+  Since the voice shell is independent of the real modem hardware, it
+  works on all supported modems, not just ZyXELs. The hardware drivers
+  hide the modem specific stuff, so that the voice shell can provide a
+  general interface that is completely modem independant. Of course the
+  reliability of the whole systems relies on the reliability of the used
+  voice modem. And there are quite notably differences between different
+  modems.
+
+  mvm offers the following features: multiple voice mailboxes with each
+  a number and a password, multiple languages, voice message
+  forwarding/copying/notification by e-mail, WWW gateway for reading and
+  sending voice messages, English and French number synthesis, multiple
+  voice mailboxes instances based on called MSN ID (ISDN), dynamic menu
+  system with access levels editable on-line. Some of the features need
+  some patches to vgetty (see below). mvm also fixes some of the below
+  mentionned modem/voice sharing problems (either by requiring a DTMF to
+  be pressed to go into voice modem, or with the called MSN ID).
+
+  vgetty is intended for people who want to share a phone line for data
+  and voice use, with the main focus being voice calls. It is *NOT*
+  intended for a dialup system that occasionally gets a voice call,
+  since some modems are confused by hearing a recorded voice message and
+  won't connect.
+
+  If you have distinctive ring, you still can have one line, but vgetty
+  can detect the type of the call from the RING message and switch
+  directly to data/fax mode. In countries where distinctive ring is
+  supported, you can have dialup and voice on the same line without
+  problems.
+
+  Voice extensions were originally written by Klaus Weidner
+  (klaus@snarc.greenie.muc.de) and then Marc Eberhard
+  (Marc.Eberhard@Uni-Duesseldorf.DE) but are now being maintained by
+  Marc Schaefer (schaefer@alphanet.ch).  Direct questions about them to
+  that address. This is the official vgetty server <http://www-
+  internal.alphanet.ch/~schaefer/vgetty.html> There you will find
+  special patches, too.
+
+  More from the distribution (some edits):
+
+  This is what you can do with `sendfax' if you have a standard class
+  2.0 or 2 fax modem:
+
+  +o  send faxes directly or using shell scripts (easily integrated into
+     other applications).
+
+  +o  do "fax polling", this means you can call the weather station and
+     get them to send you a fax containing the current weather map.
+     (Not all modem manufacturers implement this feature in their
+     modems!)
+
+  +o  create a "fax queue", outgoing faxes get sent automatically, the
+     user is informed by mail about the result.
+
+  +o  `mgetty' allows you to use a single modem line for receiving calls
+     and dialing out.
+
+  +o  `mgetty' knows about "smart" modems, and will make sure that the
+     modem is always in a defined state (specific modem initialization
+     possible)
+
+  +o  Incoming calls are answered manually (`RING' -> `ATA' -> `CONNECT')
+     instead of using auto-answer (`ATS0=1'), this way the modem won't
+     pick up the phone when the machine is down or logins are not
+     allowed. (but see note below for ISDN/digital modems)
+
+  +o  mgetty completely replaces getty and/or uugetty.  Like uugetty,
+     supports lock files in a fashion compatible with almost all known
+     versions of UUCP (HDB/BNU, SVR4, V7, Taylor in various flavours).
+     uugetty has some features mgetty doesn't support; see "How does
+     mgetty differ from uugetty?" below.
+
+  +o  mgetty supports System V style gettydefs terminal configurations.
+
+  +o  mgetty can receive class 2 faxes (if your modem supports it).
+
+  +o  mgetty knows about incoming FidoNet calls.
+
+  +o  mgetty has extensive logging / debugging features
+
+  +o  do "fax poll sending", that is, you can setup your machine as fax
+     poll server, to send some fax pages to "fax poll" callers. (Send
+     informations about your system, the current wheather map, ...). Be
+     warned, even less modems support this feature.
+
+  +o  mgetty can selectively refuse calls based upon CallerID, if your
+     modem supports it, and you're subscribed to the service. CallerID
+     is also logged.
+
+  +o  mgetty has facilities to allow you to refuse incoming FAXes when
+     available disk space is low.
+
+  +o  mgetty knows about incoming PPP calls, and can hand them off to the
+     PPP-daemon, without requiring a login/password sequence. This
+     feature is also known as AutoPPP
+
+  vgetty inherits all of mgettys features, and offers some additional
+  ones:
+
+  +o  behaves like a normal answering machine for human callers
+
+  +o  automatic fax reception when a T.30 calling tone is detected
+
+  +o  If the caller isn't a human or fax, a data connect is attempted, if
+     this is successful, the caller will get a normal login
+
+  +o  does not interfere with dialouts
+
+  +o  remote playback of messages via a DTMF code
+
+  +o  toll saver -- if there are new messages, pick up the phone earlier,
+     this way you can hang up in time to avoid a useless call
+
+  +o  message light - the autoanswer LED of your modem (if it has one) is
+     turned on if there are new messages
+
+  +o  easy playback - on some modems, you can play back the new messages
+     just by pressing DATA/VOICE
+
+  +o  using a speech synthesizer is possible - add the date and time to
+     messages (not included by default). The scripts show how to use a
+     speech synthesizer like rsynth, but it is not included in the
+     package. To use this feature, you need a voice modem for that; a
+     converter from the pvf format to the rmd (raw modem data) format
+     exists. This is not true for all supported modems.
+
+  +o  voice conversion utilities - play messages on /dev/audio (Not for
+     all supported modems, some voice modems use a proprietary format)
+
+  +o  and more, more features available through the voice library/mvm
+
+  11..33..  WWhhaatt ddoo II nneeeedd ttoo uussee mmggeettttyy++sseennddffaaxx//vvggeettttyy??
+
+  From: steve@work.bellingham.wa.us (Steve Work), and distribution CC:
+  clewis@ferret.ocunix.on.ca (Chris Lewis)
+
+  Several things.  A computer running some (most) variants of the Unix
+  operating system.  (The operating system must support termio.h or
+  termios.h; this generally rules out "pure BSD" systems.)  For support
+  of dial-in data connections (a la "getty"), you need a modem (probably
+  one somewhat compatable with the H*yes "AT" command set).  For sending
+  and receiving faxes, you need a modem that understands the Class 2 (or
+  2.0) fax command set.  For voice processing, you need a modem that is
+  capable of doing voice.
+
+  Vgetty currently supports Dolphin, Dr. Neuhaus Cybermod, Elsa, IS 101
+  compatible, Rockwell, Sierra, US Robotics and all ZyXEL modems.
+
+  The Cirrus Logic, ISDN4Linux and UMC drivers are basically working,
+  but they need to be updated to the new internal interface between the
+  generic vgetty parts and the hardware dirver. This change was
+  necessary to be strictly ANSI C compatible. Vgetty now compiles with
+  gcc -Wall -pedantic without a warning.
+
+  Mgetty has been successfully installed and run on at least the
+  following systems, probably more by the time you read this list:
+
+  +o  SCO Unix 3.2.1 (ODT 1.0)           (very well tested)
+
+  +o  SCO Unix 3.2.4 (ODT 2.0 + 3.0)     (very well tested)
+
+  +o  SCO Open Server 5.0                (Gert uses it ...)
+
+  +o  Linux 0.99pl1 .. 2.1               (very well tested)
+
+  +o  ISC Unix 3.0                       (tested)
+
+  +o  SVR4 Unix                          (well tested)
+
+  +o  AT&T 3B1 3.51m                     (well tested)
+
+  +o  HP-UX 8.x                          (well tested)
+
+  +o  AIX 3.2.5, 4.1.4, 4.2              (mgetty, not vgetty)
+
+  +o  SunOS 4.1.x                        (well tested)
+
+  +o  SunOS 5.x                          (at least with USR 33.6 Misha
+     Pavlov <oj@interport.net>)
+
+  +o  NetBSD / FreeBSD                   (works)
+
+  +o  BSDI v1.1                          (under work, not done --
+     greg@wwa.com)
+
+  It should be possible to run mgetty on any other Unix with termio.h or
+  termios.h. For best results, select(S) or poll(S) are recommended, but
+  there's a workaround. (Warning: for Unix SVR3.1 or earlier, *do not
+  use poll()*, it will not work on tty devices.)
+
+  Up to now, it has been successfully used with at least the following
+  modems, and probably more:
+
+  Here's a short list of often used modems. For an up to date list check
+  with doc/modems.db from the distribution:
+
+  +o  Aceex 1496
+
+  +o  Boca V.32bis
+
+  +o  Creatix LC 288 FC
+
+  +o  Practical Peripherals PM14400FXMT
+
+  +o  TKR Terbo Line
+
+  +o  U.S. Robotics Courier V.34 Fax
+
+  +o  U.S. Robotics Sportster V.34 28.800 Fax Modem
+
+  +o  Zoltrix Platinum Series 14.4
+
+  +o  ZyXEL 1496E+, always recommended
+
+  Mgetty *should* work with all class 2 faxmodems. Maybe the DC2
+  character sent at the beginning of a page by faxrec.c must be changed
+  to XON, for old class 2 modems (implementing very old drafts of the
+  standard).  Unfortunately, each class 2 modem can be a tiny bit
+  different.
+
+  Early USR fax modems did a bad job of conforming to the Class 2.0 (and
+  maybe Class 2) operating standards.  Reports are that current USR
+  modems (Sportster and Courier) work without excuses.
+
+  11..44..  WWhhaatt ootthheerr ssooffttwwaarree ddoo II nneeeedd??
+
+  From: clewis@ferret.ocunix.on.ca (Chris Lewis) CC: gert@greenie.muc.de
+  (Gert Doering)
+
+  For data only, no other software is needed.
+
+  mgetty itself can only send or receive G3 (raster) format.  However,
+  the distribution includes tools to convert raw G3 files to or from the
+  format used by "pbmplus", the Portable Bitmap Toolkit.  The pbmplus
+  formats support (or are supported by) most raster-image programs and
+  file formats generally used in the Unix world.  pbmplus is available
+  at this URL (among others):
+
+  pbmlus <ftp://sunsite.unc.edu/pub/X11/contrib/pbmplus10dec91.tar>
+
+  The mgetty+sendfax distribution contains a patch to fix pbmplus's
+  broken pbmtog3 converter -- using the unpatched pbmtog3 can cause
+  errors during transmission.
+
+  GhostScript, the free Postscript page description language
+  interpreter, can convert PostScript to G3.  Ghostscript is available
+  at this URL (among others):
+
+  Ghostscript
+  <ftp://sunsite.unc.edu/pub/gnu/applications/ghostscript-2.6.1.tar.gz>
+  (also check out patch files in same directory.)
+
+  Hp2pbm, available from ftp:// ??, can convert text and PCL (HP
+  Laserjet language) to G3 or PBM.  It also contains programs for
+  converting PBM to PostScript, PCL and Epson printers.
+
+  Pbmplus has converters from most existing raster formats or ASCII to
+  PBM, and from PBM to most raster formats.  You'd use the pbm2g3 and
+  g32pbm utilities in mgetty to convert between PBM and G3.
+
+  In essence, you can run with hp2pbm or pbmplus alone.  With
+  GhostScript, you also need pbmplus or hp2pbm to convert ASCII (used
+  for page headers etc.) to G3.
+
+  Mgetty+sendfax includes some voice processing utilities in the voice/
+  subdirectory. These tools (pvftools) can convert ZyXEL, Rockwell and
+  ISDN4Linux voice formats. Other formats are coming. People reported
+  success in translating GSM encoded voice formats, so support for that
+  will also be added in the future. This means that vgetty currently
+  supports the three above and support for more modems is planned.
+
+  Note that for some USR modems, the format has been changed to be
+  ``pure'' with no trailer nor header. More details can be found in
+  voice/contrib/Philip_Hands.
+
+  11..55..  WWhhaatt tteerrmmss ccoovveerr mmyy uussee ooff mmggeettttyy++sseennddffaaxx//vvggeettttyy??
+
+  >From the distribution:
+
+  "The mgetty+sendfax package is Copyright (c) 1993 Gert Doering. You
+  are permitted to do anything you want with this program - redistribute
+  it, use parts of the code in your own programs, ..., but you have to
+  give me credit - do not remove my name.
+
+  "If the program works for you, and you want to honour my efforts, you
+  are invited to donate as much as you want.
+
+  "If you make money with mgetty, I want a share. What I mean by that
+  is: it's perfectly OK with me to get paid for mgetty installation or
+  support, but if you want to actually sell mgetty, or pack mgetty with
+  a modem and sell it as "unix fax package", contact me first.
+
+  "**WWAARRNNIINNGG::** This package is still BETA software. Use it at your own
+  risk, there is *no* warranty. If it erases all the data on your hard
+  disk, damages your hardware, or kills your dog, that is entirely your
+  problem. Anyway, the program works for me and quite a lot of other
+  people."
+
+  Marc put the voice part under the GPL. To avoid misunderstandings,
+  Gert decided to not include the GPL text into the distribution,
+  though. The copyright for the voice stuff is GPL.
+
+  11..66..  WWhheerree ccaann II ggeett mmggeettttyy++sseennddffaaxx??
+
+  The home page is at http://www.leo.org/ doering/mgetty/
+
+  The official release sites are these URLs:
+
+  The master site is <ftp://alpha.greenie.net/pub/mgetty/> resp.  here
+  <http://alpha.greenie.net/mgetty/>
+
+  Mirrors are at:
+
+  ftp://ftp.leo.org/pub/comp/os/unix/networking/mgetty
+
+  11..77..  HHooww ccaann II iinntteeggrraattee iitt iinnttoo aann ooffffiiccee eennvviirroonnmmeenntt??
+
+  From: Klaus Lichtenwalder <Lichtenwalder@ACM.org> and the mgetty dist.
+
+  With mgetty, you get a subdirectory called frontends/. There are a lot
+  of more or less documented programs for viewing/printing/organizing
+  received faxes, for entering them into the queue from all kinds of
+  different programs.
+
+  11..88..  WWhhaatt''ss ggooiinngg oonn wwiitthh tthhoossee CCllaassss 11 mmooddeemmss??
+
+  From: Klaus Lichtenwalder <Lichtenwalder@ACM.org>, modifying comments
+  from Gert Doering
+
+  While Class 2 and Class 2.0 modems do most of the dirty work
+  themselves, clever modem manufacturers seem to drift toward
+  implementing only class 1 fax modes. Probably so they can use smaller
+  proms while also integrating voice functionality. Well, they want to
+  see $$$, too..  The bad thing with Class 1 is, the modem expects all
+  the dirty work to be done by the host computer. After all, why did you
+  buy a Pentium II 300MHz? Just for hitting on a few keys from time to
+  time? So you have a very fast cpu and there should be no problem to do
+  something every n ms? Right? Wrong! Most of the Unix systems out there
+  don't have realtime extensions (this *is* a real time job, after all),
+  and if they have, there's no real standard to these extensions, so
+  generally it's not possible to maintain that strain. Windows knows how
+  to use class 1 modems? Yeah, sure, the multitasking is quite
+  different, you can quite easily exclude other processes from running,
+  because you just want to have that high priority process. And if you
+  insist in doing some other time consuming tasks, your fax might no be
+  very readable... So, so much prosa for this situation, you still might
+  see some class 1 support in the near future. Just hang on and in the
+  meantime, boycott modem manufacturers who only support class 1 modes.
+
+  11..99..  WWhhaatt mmooddeemmss aarree rreeccoommmmeennddeedd??
+
+  From: Gert Doering <gert@greenie.muc.de> and the List
+
+  MODEM Recommendations for use with mgetty/vgetty
+
+  What modem to recommend depends on your needs.  There are very few
+  modems that handle fax + data + voice perfectly, but quite a number
+  that are well suited for two of the categories, and less good (or
+  sometimes not at all) for the third.
+
+     FFoorr FFaaxx++DDaattaa::
+        * USR Courier V.34/X.2 (no voice)
+
+     FFoorr FFAAXX++VVooiiccee::
+        * ZyXEL 1496 (data only up to 19200, but best fax
+        implementation)
+
+     FFoorr DDaattaa++VVooiiccee::
+        * USR Sportster VI series (fax implementation is VERY bad)
+
+     FFoorr FFAAXX++DDAATTAA++VVooiiccee
+
+     +o  ZyXEL 2864
+
+     +o  MultiTech MT2834ZDXv
+
+     +o  ELSA MicroLink TQV series (fax is not perfect, but works ok)
+
+  Last updated: February 1998
+
+  11..1100..  WWhheerree iiss tthhee lliisstt aarrcchhiivveedd??
+
+  From: Gert Doering <gert@greenie.muc.de>
+
+  A pointer to the archive as well as lots of other documentation can be
+  found at <URL:http://alpha.greenie.net/mgetty>. The archive itself can
+  be found at <URL:http://www.elilabs.com/mgarc/index.html>
+
+  22..  PPaarrtt 22:: OOtthheerr qquueessttiioonnss
+
+  22..11..  HHooww ccaann II ccoonnttaacctt mmggeettttyy//vvggeettttyy uusseerrss aanndd ddeevveellooppeerrss??
+
+  From: ezmlm at crynwr
+
+  A mailing list exists. Due to its international character, the only
+  supported language on this list is **EEnngglliisshh**, though it's gated to
+  some local newsgroups, de.alt.comm.mgetty for example. To subscribe to
+  the list, send mail to mgetty-subscribe@crynwr.com, to unsubscribe,
+  send a mail to mgetty-unsubscribe@crynwr.com, NOT to mgetty@muc.de.
+  If you want to specify a different e-mail address for your
+  subscribtion than the address you send your subscribe request, send it
+  to mgetty-subscribe-<your e-mail address with @ replaced by
+  =>@crynwr.com.  This address gets checked by sending a confirmation
+  message. Due to the fact that this list is a *mailing-list*, even
+  though you can also see it in newsgroups you *have* to use a valid e-
+  mail address. Not complying to this (e.g., you add the dreaded
+  -NOSPAM- somewhere in your address) you can't be reached for answers.
+  And most of the time people who care to answer don't check for rules
+  how to legalize your mail address for lack of time.
+
+  Example (from mgetty-help@crynwr.com): to specify God@heaven.af.mil as
+  your subscription address, send mail to <mgetty-subscribe-
+  God=heaven.af.mil@crynwr.com>.  I'll send a confirmation message to
+  that address; when you receive that message, simply reply to it to
+  complete your subscription.
+
+  The volume on mgetty@muc.de varies from one or two messages a week to
+  ten or so a day, depending on development activity.
+
+  If you have questions because of a misbehaving mgetty or vgetty, be
+  sure to include the relevant parts of your log file, usually obtained
+  with a loglevel of 6 The default location of these log files is /tmp/
+  for mgetty and /var/log for vgetty.
+
+  Subject:  What image file formats can sendfax send?  From:
+  gert@greenie.muc.de (Gert Doering)
+
+  Fax input format:
+
+  raw G3 data (according to CCITT standard T.4, 1-dimensionally
+  compressed). Can be created by GhostScript's "dfaxhigh" or "dfaxlow"
+  drivers (they will create raw G3 data with a 64 byte header, that
+  sendfax + g3cat + g32pbm will recognize and skip) or by the "pbm2g3"
+  program.  Warning: the pbmtog3 program from the "pbmplus" distribution
+  does *not* create valid G3 data according to T.4, to be precise, the
+  lines are shorter than 1728 pixels and the leading EOL code is
+  missing. To fix it, use the patch that is provided in
+  "patches/pbmtog3.p1". Even better, use my own utility. (The patch is
+  *NOT* needed for my pbm2g3 program!).  Use of a unpatched pbmtog3 will
+  most likely cause +FHNG:50 or +FHNG:54 error codes. But see also
+  ``Troubleshooting and answers'' for other causes for these errors.
+
+  Do not use "tiff-G3" data as input. Though the data itself is G3
+  encoded, it's wrapped into a complex layer of TIFF headers that would
+  require non-trivial parsing that's simply not needed for sendfax.
+  Faxing a TIFF file will result in a warning message from sendfax, and,
+  most likely, in a failed transmission.
+
+  Fax output format:
+
+  The files that mgetty places into FAX_SPOOL_IN are in the same format
+  as the files that sendfax wants to send, raw G3 data as of CCITT T.4.
+  To convert them to "pbm", use the g32pbm program. To convert them to
+  X-Windows xwd format, use the "contrib/g3toxwd" program.
+
+  If the files are received without transmission errors, it is possibly
+  to send received fax files without any additional conversion. Since
+  some modems insert filling zero-bits, a run through "g3cat" is
+  recommended anyway, this will remove any surplus stuff, and clean up
+  garbled lines.
+
+  22..22..  WWhhyy ddooeessnn''tt mmggeettttyy aacccceepptt ootthheerr ffiillee ffoorrmmaattss bbeessiiddeess GG33??
+
+  Why does mgetty only send raw G3 fax files, instead of converting
+  arbitrary image files (like TIFF) on the fly?
+
+  >From Chris Lewis:
+
+  "As I understand it, in addition to its own formats, TIFF can
+  encapsulate some number of other formats.  Put another way, TIFF is,
+  at least to some extent, simply a way of getting magic numbers into
+  other formats so that TIFF-capable converters can handle multiple
+  formats transparently.
+
+  "Yes, you certainly can have TIFF encapsulate a G3, and mgetty
+  wouldn't have much trouble with that.  However, that leaves you with
+  the question - what does mgetty do if it's not a G3 that's been
+  encapsulated?  It would have to convert it.  And then we would
+  encounter situations where mgetty's conversion speeds couldn't meet
+  the class II FAX transmission timeouts, and you've wasted telephone
+  time...  Ditto on reception.  Indeed, there is a real possibility that
+  mgetty would not be able to keep up if the input or output file was
+  anything other than a G3.
+
+  "Approaching this from another viewpoint, we should also remember that
+  mgetty is a transfer protocol and implementation.  *Not* conversion
+  software.  mgetty needs to read and write G3s, and that's all.  Leave
+  conversions to other software."
+
+  And from Gert Doering:
+
+  "Well, TIFF is a very complex file format, that can support dozens of
+  different page data encodings, different byte / bit orderings,
+  multiple pages per file, and so on.  While TIFF is a flexible format,
+  parsing it is a complex task.
+
+  "In contrast, mgetty's "g3" files are raw G3 data. No headers, no
+  formatting, no need for the transmission code to dig around in the
+  file to find the actual page data.  One page per file, simplest
+  possible.
+
+  "Ignoring TIFF (leaving TIFF conversions to outside software)
+  simplifies mgetty and sendfax enormously, but doesn't complicate the
+  user interface much, as long as "faxspool" or similar tools are used
+  that will hide the internals, that is, how the fax backend expect its
+  data, from the user. To be precise, leaving out TIFF support
+  *simplifies* mgetty.  Many Unix programs can read pbm and converting
+  g3 -> pbm is very easy, while I haven't seen a good *multipage*-Tiff -
+  to - PBM converter yet."
+
+  22..33..  WWhhyy ddooeessnn''tt mmggeettttyy uussee tthhee mmooddeemm''ss aauuttooaannsswweerr ccaappaabbiilliittiieess??
+
+  1. Because it isn't possible to distinguish a fax from a data call if
+  you don't have full modem control. Besides, it will make sure that the
+  modem doesn't answer the phone while the host isn't ready for it. (but
+  see note below for ISDN and digital modems)
+
+  2. And callerid won't work without extreme difficulty.
+
+  22..44..  WWhhyy mmggeettttyy iiggnnoorreess //ddeevv//ttttyy** ddiiaalliinn,, //ddeevv//ccuuaa** ddiiaalloouutt ccoonnvveenn--
+  ttiioonnss::
+
+  Under Linux and most other Unices (excepting SunOS) mgetty should be
+  set on the tty* devices, and the cua* devices should be ignored
+  entirely:
+
+  From: "Theodore Y. Ts'o" <tytso@mit.edu>
+
+  /dev/ttySxx devices are fully POSIX-compliant TTY devices.  If you are
+  only going to be using one set of tty devices, you should be using
+  /dev/ttySxx.
+
+  /dev/cuaXX devices are different from /dev/ttySXX in two ways ---
+  first of all, they will allow you to open the device even if CLOCAL is
+  not set and the O_NONBLOCK flag was not given to the open device.
+  This allows programs that don't use the POSIX-mondated interface for
+  opening /dev/ttySxx devices to be able to use /dev/cuaXX to make
+  outgoing phone calls on their modem (cu stands for "callout", and is
+  taken from SunOS).
+
+  The second way in which /dev/cuaXX differs from /dev/ttySXX is that if
+  they are used, they will trigger a simplistic kernel-based locking
+  scheme:  If /dev/ttySXX is opened by one or more processes, then an
+  attempt to open /dev/cuaXX will return EAGAIN.  If /dev/cuaXX is
+  opened by one or more processes, then an attempt to open /dev/ttySXX
+  will result the open blocking until /dev/cuaXX is closed, and the
+  carrier detect line goes high.
+
+  While this will allow for simple lockouts between a user using a modem
+  for callout and a getty listening on the line for logins, it doesn't
+  work if you need to arbitrate between multiple programs wanting to do
+  dialout --- for example, users wanting to do dialout and UUCP.
+
+  I originally implemented the cuaXX/ttySXX lockout mechanism back
+  before FSSTND established a standard convention for the use of tty
+  lock files.  Now that it's there, people should use the tty lock files
+  and not try using /dev/cuaXX.  The only reason why /dev/cuaXX hasn't
+  disappeared yet is for backwards compatibility reasons.  - Ted
+
+  Under SunOS *everything* should use cua*, as follows: From: Gert
+  Doering <gert@muc.de>
+
+  The two-device scheme is meant to prevent multiple processes from
+  accessing the same physical device at the same time. Since mgetty
+  opens the port with O_NDELAY, the kernel sees a process on tty*
+  (mgetty) and prevents any open() on cua* (uucico, cu, ...). So, you
+  have to use the same device for both program types, and that's cua*.
+  22..55..  TTrroouubblleesshhoooottiinngg qquueessttiioonnss && aannsswweerrss
+
+  From: gert@greenie.muc.de
+
+  Q: I keep getting the error code +FHNG:50 or +FHNG:54 after sending a
+  page. Sometimes it says "page bad, retrain requested" and infinitely
+  resends the page.
+
+  A: This error means that something went wrong between the two
+  machines, while your end was sending the page data. In the case of
+  +FHNG:50 or +FHNG:54, the other end most likely simply hung up (so
+  your modem couldn't get any page transfer status at all), in the other
+  case, the receiver complained that it didn't like the data on the
+  page.
+
+  The most common reason for this behaviour is that you used a copy of
+  ``pbmtog3'' that came from the ``pbmplus'' distribution and doesn't
+  have my patch included (Mind you, the pbmtog3 program is required for
+  the page headers that faxspool puts on top of each page!).
+
+  If that is not the reason, there may be flow control problems, or the
+  line have simply has been very noisy, or so. Get in touch with the
+  receiver, and find out whether the page looks good or whether there
+  are lines missing, others corrupted, ... - if there are errors, check
+  your flow control setting.
+
+  If there are no errors whatsoever, and you're sure that you use my
+  version of pbmtog3 (called pbm2g3 or a patched version of pbmplus',
+  then I'm out of wits - something's broken in the modem. Maybe you
+  should upgrade your ROM version.
+
+  Bjoern Jacke (bjoern.jacke@gmx.de) reports that there was a bug in gs
+  5.50 such that if the input file specified a paper size explicitly,
+  the line length was not properly adjusted to 1728 pixels.  This bug
+  was fixed in beta version 5.71. This can also cause the same errors.
+
+  Q: When receiving faxes, I get the +FCON message logged, then mgetty
+  says "starting fax receiver". fax_wait_for(OK) is called, logs some
+  random junk bytes, and gives up after a minute, complaining about
+  "timeout".
+
+  A: Most likely, you have a modem that switches baud rate to 19200 bps
+  right after sending the +FCON message to the host, and the normal port
+  speed is something else. Check policy.h whether FAX_RECEIVE_SWITCHBD
+  is defined, and change the setting (if the modem does *not* change
+  speed, but the define is *set*, the effect will be similar).  Better
+  yet, with the runtime configurable stuff, is to add the entry switchbd
+  <nnn>" in mgetty.config
+
+  Q: I keep changing values in policy.h, but nothing changes.
+
+  A: maybe you've had an older version of mgetty installed to
+  /usr/local/bin/mgetty and are calling this from /etc/init? Newer
+  versions are installed in /usr/local/sbin/mgetty. Check the time stamp
+  on the mgetty you just compiled vs. the mgetty listed in /etc/inittab.
+
+  Q: Half of the faxes that I receive are too short, they look as if
+  every second pixel line is missing.
+
+  A: Well, they *are* short: most likely, they are received in normal
+  resolution (204x98 dpi) instead of fine resolution (204x196 dpi). You
+  can see it in the filename, if it starts with "ff*", it's fine, if it
+  starts with "fn*", it's normal resolution. To ``stretch'' a normal
+  resolution fax to proper proportions, use ``g32pbm -stretch fn...''
+
+  Q: login complains with ``no utmp entry, must execute login from the
+  lowest level sh''
+
+  A: I *told* you not to fiddle with the ``utmp'' field... - most
+  likely, in your ``login.config'' file, the utmp field for the entry
+  calling /bin/login isn't "-".
+
+  Another reason could be a faulty /etc/init (hits only Linux users) or
+  a corrupted /etc/utmp file. In that case, reboot your machine.
+
+  Q: When mgetty is running and I dial out, I do not get "CONNECT" but
+  only junk, as "+FCO", "+FTI:", "+FHS:20"
+
+  A: Well, yes, that's a problem with the 2.0 implementation in mgetty.
+  That is: while mgetty is running, the modem is in "AT+FCLASS=2.0" mode
+  and expects to connect to a fax on the remote side. (With class 2, we
+  worked around this by setting +FCLASS=0;+FAA=1, but that will make the
+  modem answer in class 2, not 2.0 subject to further testing!)
+
+  Solution: in the program dialing out, initialize the modem with
+  "AT+FCLASS=0".  Most likely, a modem reset (ATZ) will also help.
+
+  Q: every time mgetty starts up, the permissions of my tty device get
+  changed and I have to issue "chmod +w /dev/ttySx" to be able to dial
+  out.
+
+  A: that's not a bug, that's a feature. You don't *want* to allow
+  anybody using your machine to be able to dial out (think of your phone
+  costs!), so it's a security issue.  If you *want* to allow dialout for
+  everyone, #define FILE_MODE 0666 in policy.h. I would not recommend
+  it, I would give access to a special group, and put every one that may
+  dial out into this group.
+
+  Q: I have a Linux system, and while trying to dial out on /dev/cua1
+  (mgetty is running on /dev/ttyS1), it says "device busy" (EBUSY)???
+
+  A: use the same device (always!!) for dial-in and dial-out.  On Linux,
+  use /dev/ttySx, on SunOS and *BSD use /dev/cuax.  And while you're at
+  it, dont' use links like /dev/modem. You'll end up confused and will
+  most certainly forget it. But you have to not only use the same device
+  for all those programs but in fact also the same *name*, for the lock
+  file will be named appropriately.
+
+  Q: If I create a fax file with "gs -sDEVICE=dfaxhigh ..." and send it
+  with sendfax, everything works *great*. If I run it through
+  "faxspool", the receiving side reports an error. Is the "g3cat"
+  program broken?
+
+  A: No, g3cat isn't the problem. The real problem is "pbmtog3", and I
+  bet you have the pbmtog3 program from the pbmplus distribution
+  installed.  This program is *broken* (patch is in
+  mgetty/patches/pbmtog3.p1), that is, it doesn't create proper T.4/G3
+  fax data. Thus, the receiving fax machine will get a fax that has some
+  corrupt lines (the page header) and will complain about it.  Patch
+  pbmtog3, or use mgetty's pbm2g3. It's faster anyway.
+
+  Q: mgetty doesn't accept FidoNet calls. I get log entries like this:
+
+  10/30 01:54:54 ##### data dev=ttyS1, pid=3401, caller=none,
+  conn='38400/V32b 14400/V42b', name='', cmd='/bin/login',
+  user='**EMSI_INQC816**EMSI_INQC816q.'
+
+  or this:
+
+  10/30 05:31:03 ##### data dev=ttyS1, pid=7238, caller=none,
+  conn='38400/ZyX  16800/V42b', name='', cmd='/bin/login', user='q.q.q.'
+
+  A: did you compile mgetty with -DFIDO defined? I don't think so. If
+  -DFIDO isn't set, mgetty doesn't know about fido.
+
+  Q: Some of my programs use binary lockfiles and some use ASCII
+  lockfiles.  Why does mgetty complain?  Can't it recognize both?
+
+  A: Mgetty complains because your system configuration is _wrong_.
+  These error messages are there to help the system administrator notice
+  a *severe configuration error* on his site.
+
+  If all programs would understand both types of Locking, the messages
+  would be silly, but since kermit usually simply ignores ascii locks,
+  and uucico does so for binary locks, the situation is *highly* error-
+  prone, and sysadmins should *SEE* this.
+
+  Recompile your applications that use the modem so that all agree on
+  the lockfile types.
+
+  Q: My modem and I share one phone line. Now I answered the phone and a
+  modem greets me. How can I make mgetty take over?
+
+  A: Send the signal SIGUSR1 to the mgetty process. It will then answer
+  the phone.
+
+  Q: I can fax only one page, then I get an error
+
+  A: When you see something like this in your log: > 03/22 19:15:58 yS1
+  fax_wait_for: string 'OK'** found ** > 03/22 19:15:58 yS1  fax_send:
+  'AT+FET=0' > 03/22 19:15:58 yS1  fax_wait_for(OK) > 03/22 19:15:58 yS1
+  fax_read_byte: read returned 0: Unknown error > 03/22 19:15:58 yS1
+  fax_get_line: cannot read byte, return: Unknown error > 03/22 19:15:58
+  ##### failed transmitting f1.g3: +FHS:-4, time=55s or (the newer log
+  entries) > sendfax: FAILED to transmit 'f1.g3'.  > Transmission error:
+  +FHNG:-5 (Unexpected hangup / read() error / write() > error (int.))
+
+  you should define ''ignore-carrier yes'' in your sendfax.config file.
+
+  Q: The message "WARING: DSR off - modem turned off or bad cable?"
+  keeps showing up in the mgetty logfile.
+
+  A: If you see this message, it basically means that mgetty can't get
+  the status of dsr (data set ready). This can be because the cable is
+  bad or because you are using mgetty on solaris. Solaris doesn't give
+  you the status of dsr. If you are running mgetty on a different
+  platform, you might consider checking your cable or the modem setting.
+  Note that the Multitech modems (especially 2834) don't seem to be able
+  to force DSR to be on, giving this annoying message but no other
+  problem.
+
+  Q: How many slashes do I need to put into mgetty.config to have mgetty
+  send a  to the modem?
+
+  A: Well, four. Why did you ask? The syntax for a  is \\N3 (Tnx to:
+  Ruud van Tol <rvtol@isolution.nl>)
+
+  22..66..  PPrrooggrraammss ggeenneerraattiinngg ""iinnvvaalliidd"" PPoossttssccrriipptt tthhaatt ccaann''tt ccoonnvveerrtteedd
+
+  to the G3 format for sendfax From: Gert Doering <gert@greenie.muc.de>
+
+  Right now the list of programs generating "invalid" postscript
+  (causing Ghostscript to create G3 files with wrong line width, in turn
+  causing sendfax to fail) includes:
+
+  FrameMaker 4.0 WinWord (dunno which version) dvipsk 5.58f
+
+  Gert Doering wrote on Sun, 22 Dec 1996 00:26:55 +0100 in message
+  <m0vbaoh-0004B5C@greenie.muc.de>:
+
+  Interesting enough, I tried dvipsk 5.58f today, and it does *NOT* emit
+  any of those bad "setpagedevice" commands, and thus the resulting
+  postscript *will* generate correct page sizes. So maybe it's
+  sufficient to upgrade your dvips program to the most recent version.
+
+  Maybe it's necessary to tell *ghostscript* what the "right" paper size
+  is supposed to be (A4 -- but you must make sure that dvips makes "a4"
+  as well!), by specifying "gs -sPAPERSIZE=a4".
+
+  For some people, even that does not suffice (some strange interaction
+  between different paper sizes in different programs), so it may help
+  to post-process the G3 files with "g3cat" (from mgetty 0.99*, versions
+  after July 96!), or with "g32pbm badfile.g3  | pbm2g3 >goodfile.g3".
+  The latter will definitely help.
+
+  22..77..  MMyy ZZyyXXEELL ddooeessnn''tt wwoorrkk rriigghhtt aafftteerr aa RROOMM uuppggrraaddee:: WWhhaatt''ss wwrroonngg??
+
+  From: felix@escape.vsse.in-berlin.de
+
+  Do a full modem reset after upgrading the firmware. This is not
+  described in the German ZyXEL manual (is it described in the English
+  one?) but should be done in any case.
+
+  22..88..  WWhhyy tthhee ooccccaassiioonnaall ""ttccsseettaattttrr ffaaiilleedd:: II//OO eerrrroorr"" mmeessssaaggee??
+
+  From: gert@greenie.muc.de
+
+  Q: Occasionally, mainly after "clean" user logouts (that is, the user
+  typed "exit" instead of just hanging up), I get the message 09/08
+  21:26:26 yS2  lowering DTR to reset Modem 09/08 21:26:27 yS2
+  tcsetattr failed: I/O error in the mgetty log file, and a similar I/O
+  error message in the syslog file.
+
+  A: Well, this is a Linux and SunOS specific problem: if the modem is
+  still connected to the other end when mgetty starts, mgetty will force
+  it to hangup by lowering DTR (and sending +++ATH, in case DTR drop
+  won't suffice).  This will make the modem lower the DCD (carrier
+  detect) line.  Unfortunately, this will trigger a security mechanism
+  in the Linux kernel, which will prevent all further access via that
+  file descriptor.  This is done to prevent one well-known password hack
+  (I won't that explain in detail).
+
+  Mgetty knows about that problem, and, upon noticing an error at this
+  point during modem initialization, will simply reopen the port and
+  redo all modem / port setup stuff.
+
+  Because suppressing that error message would be messy, it keeps
+  appearing, but it is harmless (... "trying again").
+  22..99..  WWhheenn iiss mmggeettttyy aaccttuuaallllyy rruunnnniinngg?? ((ii..ee.. wwhhaatt ccaann mmggeettttyy ccoonnttrrooll??))
+
+  From: Klaus Lichtenwalder <Lichtenwalder@ACM.org>
+
+  At what moments can mgetty exert control over the line? Let's consider
+  mgetty's life span: at some time (e.g. system boot, init assumes the
+  specified run level and starts mgetty) mgetty starts and (simplified)
+  checks for the lock file on the device it has to control. If there's
+  no lock file, it initializes the modem and wait's for an event on the
+  line. If a character arrives, mgetty does not read it but first checks
+  the lock file.
+
+  * If a lock file is present, mgetty knows some{body,thing} wants to
+  dial out and periodically checks for the existence of the lock file.
+  After the lock file is gone, the device is free and mgetty simply
+  exits. It'll get restarted by init, so the modem line will get
+  reinitialized.  * If no lock file is present, the modem most probably
+  sent a RING, so we go check for the expected word (= RING) and send
+  our answer_chat. If it's a fax call (and the modem can receive faxes
+  and we allow receiving them) we get the pages, store 'em away and
+  exit, thus restarting mgetty, see above. If it's a data call (I ignore
+  DISTINGIVE_RING and Caller_ID features for now), we prompt for the
+  login and wait for an answer. After the answer is read, it's checked
+  against the login.config file and the appropriate program get's exec'd
+  by mgetty, which means, there's *no* mgetty for that line. Only after
+  the termination of the connection, when the other process(es) exit(s),
+  mgetty will be restarted by init.
+
+  22..1100..  TThhee uusseerr''ss sshheellll ddooeessnn''tt ggeett kkiilllleedd aafftteerr tthhee lliinnee ddrrooppss
+
+  From: Gert Doering <gert@greenie.muc.de>
+
+  > why doesn't mgetty kill the user's shell when the user just hangs up
+  > the modem, without doing 'logout'? Mod: or the line simply crashes
+
+  How should mgetty kill a user's shell? While the user is logged in,
+  mgetty is *not running*.
+
+  The kernel will signal the shell via the SIGHUP signal when the DCD
+  line on the modem drops. Then the shell will exit, and init will re-
+  start mgetty. Unfortunately, the BASH shell is very broken in various
+  versions and will ignore the SIGHUP signal, so that could be one
+  reason why it isn't exiting.
+
+  Another reason could be an improper modem setup (AT&C0), make sure
+  that the modem raises and lowers the DCD line properly (check with the
+  modem manual) and that your serial cable is OK (swap it with another
+  one for testing).
+
+  22..1111..  AAuuttooPPPPPP aappppeeaarrss iinn tthhee ""wwhhoo"" lliissttiinngg
+
+  From: Gert Doering <gert@greenie.muc.de>
+
+  If you use the /AutoPPP/ option for automatically creating a ppp
+  connection, the user name does not appear in the who list. Instead,
+  something like AutoPPP or ppp is displayed. Solution: you have to
+  patch pppd, that's not mgetty's issue and thus can't resolved patching
+  mgetty.  If you have the patched pppd, this is how it works. You have
+  to add the option "login" to pppd in login.config and change the third
+  column to "-" (in the example it's a_ppp or ppp).
+
+  22..1122..  TThhiinnggss ttoo tthhiinnkk ooff iiff uussiinngg AAuuttooPPPPPP,, oorr,, aass yyoouu mmiigghhtt ccaallll iitt,,
+
+  ppp connections From: Gert Doering <gert@greenie.muc.de>
+
+  You can't get a ppp connection going. So, what should you check before
+  calling for help in the list.
+
+  Run mgetty with a debug level high enough to see what login it will
+  try. It might not be wrong to just use level 9 to see everything
+  happening.
+
+  Scenario 1: mgetty recognizes AutoPPP:
+
+         03/11 12:06:31 yS1   match: user='/AutoPPP/', key='/AutoPPP/'*** hit!
+         03/11 12:06:31 yS1   login: utmp entry: ppp
+         03/11 12:06:31 yS1    looking for utmp entry... (my PID: 5313)
+         03/11 12:06:31 yS1   utmp + wtmp entry made
+         03/11 12:06:31 yS1   calling login: cmd='/usr/sbin/pppd', argv[]='pppd...
+         03/11 12:06:31 ##### data dev=ttyS1, pid=5313, caller=none, conn='LAPM', name=''
+
+  At this point, mgetty executes pppd and has nothing to do with
+  connection failures, failing authorization, the police banging at your
+  door or anything else. Check pppd's logs for any trouble.
+
+  If you use "who" and the only thing you can see is "a_ppp", go check
+  your pppd sources. It's pppd's job to forge a utmp entry
+
+  It looks like some unix clients should explicitely send the string
+  "/AutoPPP/" as there seems to be a problem in connecting. Mgetty
+  doesn't seem to get ppp-frames and waits for something it can decide
+  what to do. As you are most probably using a script for the
+  connection, there should be no problem to send that string.
+
+  22..1133..  VViieewwiinngg rreecceeiivveedd ffaaxxeess ffrroomm aa PPCC rruunnnniinngg wwiinnddoowwss
+
+  From: Amadeu Pi <AmadeuP@santiveri.es>
+
+  Software needed: Unix side: libtiff <ftp://ftp.sgi.com/graphics/tiff>
+  PC side: MS Imaging
+
+     WW9955
+        http://www.microsoft.com/windows/windows95/info/wang.htm
+
+     WWNNTT44
+        It comes with standard distribution
+
+     WWNNTT33..5511
+        NT4 version can be made to work here (contact me if interested)
+
+  Howto: Probably from FAX_NOTIFY_PROGRAM run fax2tiff to generate a
+  single tif file from all the received g3 page files, example:
+
+            fax2tiff -M -R 98 -o fax.tif fn54d6e4eS1.01 fn54d6e4eS1.02
+
+  where -M means Treat input data as having bits filled from MSB to LSB,
+  -R is the vertical resolution (196 for fine 98 for low), -o is the
+  name of the output file
+
+  One interesting point of this approach is that g3 to tiff conversion
+  is very, very fast (a lot faster the g3 to gif or g3 to pbm).  Once
+  you have generated the tiff file you can place it in a samba share so
+  a PC can access it or you can mail it to a PC user (see
+  samples/new_fax.mime) or any other thing that suits you.  When you
+  have the tiff file on the PC side use wangimg.exe (MS Imaging) to view
+  it (or just doble click on the file). This program developed by Wang
+  has several fancy features that will allow you change page
+  orientation, print several or all pages, annotate...
+
+  22..1144..  HHoowwttoo sseettuupp MMSSNN//ddiissttiinnccttiivvee rriinnggss mmaappppiinnggss
+
+  From: Gert Doering <gert@greenie.muc.de>
+
+  To define the list of msns and map them to the distinctive rings add
+  the parameter msn-list <nrs>+ to mgetty.config, i.e.
+
+         msn-list 35655071 023 025 024
+
+  the list is matched left-to-right, the numbers themselves right-to-
+  left.  The <n>th number in the list will be mapped to dist-ring <n>,
+  for example, a call to 35655025 will be treated as "distinctive ring
+  3".
+
+  (Counting starts from 1, because dist-ring 0 is "unspecified RING").
+
+  22..1155..  HHoowwttoo ccoonnvveerrtt wwaavv''ss ttoo rrmmdd''ss ffoorr mmggeettttyy
+
+  From: Andy Fraser <andy@bramble.force9.co.uk>
+
+  Q: I am trying to convert a file that I have recorded in WAV to the
+  RMD type required by my modem. However, when I convert it using
+  wavtopvf and then pvfspeed to adjust the sampling rate to 7200
+  required by my modem and then listen to the file it sounds as if the
+  message has been slowed down.
+
+  A: Your WAV file may be in stereo and this will mean that it won't
+  convert properly. Simply convert your WAV file to mono and then try
+  the process again.
+
+  22..1166..  WWhheerree ccaann II ggeett hhpp22ppbbmm??
+
+  From: Gert Doering <gert@greenie.muc.de>
+
+  hp2pbm can be found at <URL:ftp://alpha.greenie.net/pub/mgetty/> or at
+  <URL:ftp://ftp.leo.org/pub/comp/os/unix/networking/mgetty/>
+
+  22..1177..  MMyy ((IISSDDNN//ddiiggiittaall)) mmooddeemm ddooeessnn''tt ssaayy RRIINNGG when being called
+
+  From: Jason Spence <thalakan@technologist.com>
+
+  Try ATS0=3.  It used to be a safe assumption that all modems would say
+  "RING", even if auto-answer is turned off.  However, many newer
+  digital modems (like the Digi RasFire series) can tell the switch at
+  your phone company's central office that it's not going to answer the
+  phone, so anyone who tries to call the number your modem is attached
+  to will just get a busy signal.  You MMUUSSTT change the default init
+  string in login.config to ATS0=3 (or some other number > 1).
+
+  This behaviour is almost guaranteed for ISDN PRI (23B + 1D) modem bank
+  cards.
+
+  22..1188..  IIss mmggeettttyy YY22KK ccoommpplliiaanntt??
+
+  From: Gert Doering <gert@greenie.muc.de>
+
+  Yes, mgetty is Y2K compliant. Rationale: Mgetty has no idea what a
+  "date" might be.  All programs use date only for logging, and even
+  then, only mm/dd is used, no year in any form.  Time stamps / time
+  differences are done based on time() values, that is, seconds since
+  the epoch, so there is no calculation based on dates that could go
+  wrong.
+
+  Weird things might happen in 2038 (if the time field used is still 32
+  bits and if fax will still be used).
+
+  33..  PPaarrtt 33:: CCoommppaattiibbiilliittyy IIssssuueess
+
+  33..11..  SSuussppiicciioouuss ffaaxx mmaacchhiinneess
+
+  From: hm@ix.de (Harald Milz)
+
+  I'm collecting all data concerning suspective fax machines, i.e. those
+  which made problems in cooperating with sendfax. The main reason is to
+  find out whether there are specific fax machines that refuse to work
+  with sendfax and/or your fax modem. As a goal, we will be able to
+  track down the bug(s).
+
+  To contribute, please fill in the following template and send it to me
+  (hm@ix.de):
+
+  1. <fax machine's brand and model>
+
+  2. <corresponding fax number> (optional)
+
+  3. <fax modem brand and model>
+
+  4. <fax modem's firmware revision>      # tbd from ATI1
+
+  5. <protocol parameters>          # tbd from Faxlog
+
+  6. <errlog line from Faxlog>              # tbd from Faxlog
+
+  7. <remarks>
+
+  If you encounter problems with a fax machine, please call the
+  receiving party and ask them for their fax machine's brand & model and
+  if they are willing to offer their machine for some (limited) testing.
+
+  The more exact your data is (the first 3 entries aren't too good :-}
+  ), the better the result will be, hopefully.
+
+  This list is posted once a month (automatically) and if five new
+  entries were added to it (manually).
+
+  Here's what's already in the list:
+
+       1. Panasonic Panafax UF311
+       2. +49 89 74824899
+       3. ZyXEL U1496EG+
+       4. U1496EG V 6.10g P
+       5. +FDCS:1,3,0,2,0,0,0,4
+       6. +FHNG:50 (Unspecified Transmit Phase D error)
+       7. when sending 15 pg, connection broke after 6 pg.
+       <p>
+
+       1. NEC Nefax 17
+       2. +49 2242 82114
+       3. ZyXEL U1496EG+
+       4. U1496EG V 6.10g P
+       5. +FDCS:1,3,0,2,1,0,0,4
+       6. +FHNG:50 (Unspecified Transmit Phase D error)
+       7. machine didn't refuse when sending only 3 pages
+          earlier. This time, 15 pg were sent.
+       <p>
+
+       1. Telekom AF-310
+       2. +49 7231 560851
+       3. ZyXEL U1496 E / 6.10a, E+ / 6.01, E+ / 6.11a
+       4.
+       5. +FDCS:1,3,0,2,0,0,0,4
+       6. +FTPS:2 -> page bad, retrain requested
+       7. sendfax hangs up after three tries.
+          received fax shows black and white boxes at the
+          footer, such as,
+          ###   ###   ###   ###   ###
+          ###   ###   ###   ###   ###  ...
+          ###   ###   ###   ###   ###
+
+  33..22..  CCaalllleerr IIDD
+
+  From: the list <mgetty@muc.de>
+
+  This is a delicate issue, as the format for caller id is different
+  from country to country. So, as a rule of thumb, you have to check
+  with the modem-{manual,manufacturer} whether the national format of
+  caller id is supported. Most of the time it will only support the
+  american format for caller id, if not otherwise specified
+
+  33..33..  RReeffeerrrraall ffoorr ZZyyxxeell iinn UUSS
+
+  I've got my Zyxel 1496E modem, after much trouble in locating a
+  vendor.
+
+  So, for your information, if someone asks you about where to get these
+  in the USA, refer them to www.modemstore.com.  Zyxel points to this
+  company also.
+
+  Forrest (Sorry, I don't know the full name of Forrest nor his e-mail
+  address. This quote was forwarded by Marc Schaefer for inclusion)
+
+  44..  PPaarrtt 44:: CCoommppiilliinngg,, iinnssttaalllliinngg aanndd uussiinngg vvggeettttyy
+
+  44..11..  CCoommppiilliinngg vvggeettttyy
+
+  From: Marc Eberhard <marc@poseidon.thphy.uni-duesseldorf.de>, Klaus
+  Lichtenwalder <Lichtenwalder@ACM.org>
+
+  After having set up mgetty for compile (i.e. copying policy.h-dist to
+  policy.h and editing it), you change to the voice/ directory and type
+  make. For installation (make install) be sure to copy voice.conf-dist
+  to the mgetty configuration directory (usually
+  /usr/local/etc/mgetty+sendfax) as voice.conf and edit it, using the
+  comments in that file.
+
+  44..22..  UUSS RRoobboottiiccss vvooiiccee ffoorrmmaatt ccoonnvveerrtteerr
+
+  From: Scott Hutton <shutton@indiana.edu>
+
+  There's a script I wrote in voice/pvftools called "extract_gsm" that
+  extracts the GSM data from a US Robotics "rmd" file.  Once you have
+  that, and you have a version of "sox" that can convert .gsm files in
+  to .au (or other format) files, you're in business.
+
+  I found the necessary patches for sox after a bit of digging:
+
+  http://kbs.cs.tu-berlin.de/ jutta/toast.html
+
+  You'll need the GSM library before you try to apply the sox patches.
+  It's too bad sox doesn't come with GSM support--it seems to have about
+  everything else...
+
+  Also, Thomas Hellstroem (thomas@vtd.volvo.se) had some C programs to
+  extract GSM data and to "pack" GSM data into rmd files off of his
+  page.  Unfortunately, I didn't save the URL.
+
+  -Scott Hutton, UCS Messaging Team, Indiana Univeristy
+
+  (alternatively, here is a a utility converting WAV to GSM and back
+  <http://www2.sienanet.it/users/guido/gsm_6_10.htm>).
+
diff -urP mgetty-1.1.22/faq/TODO mgetty-current/faq/TODO
--- mgetty-1.1.22/faq/TODO	Thu Jan  1 01:00:00 1970
+++ mgetty-current/faq/TODO	Thu Nov 16 11:41:53 2000
@@ -0,0 +1,2 @@
+- Add scripts to recreate HTML and text from SGML; do not distribute
+  HTML
diff -urP mgetty-1.1.22/faq/drafts/ppp mgetty-current/faq/drafts/ppp
--- mgetty-1.1.22/faq/drafts/ppp	Thu Jan  1 01:00:00 1970
+++ mgetty-current/faq/drafts/ppp	Thu Nov 16 11:41:52 2000
@@ -0,0 +1,236 @@
+Subject: Use of mgetty with pppd (FAQ addition, not yet inside official FAQ)
+
+$Id$
+
+[ This is very Linux specific. However, the basics should work
+  with usual pppd configurations on other UNIX systems too
+]
+
++++ The goal is to merge this with the general mgetty FAQ once this
++++ stabilizes and I have understood SGML :)
+
+People like to have users dial in with PPP instead of normal login. This
+can be safer and also easier to use / more powerful. Using pppd with
+mgetty is twoafold: first, you need to make so that pppd is launched one
+way or another. There are two ways:
+
+   1. make so that mgetty auto-detects a PPP frame before
+      (technically: after) even sending the login: prompt.
+      This means thats the people will not have to login first
+      (in clear: no ogin:/sword: chat scripts needed).
+
+   2. make so that the user first logs in with a special user, and
+      then either pppd is the user's shell, or the user launches
+      pppd from there manually.
+
+Although technically possible, method 2 is discouraged and will not be
+described here. Method 1 is the suggested method and will be discussed
+here.
+
+To use method 1, the following are mgetty pre-requisites:
+
+   - mgetty must have been compiled with -DAUTO_PPP (see mgetty's
+     documentation and other FAQ entries)
+   - The /AutoPPP/ demonstration line in login.config must be uncommented,
+     and all arguments checked, such as e.g. path to pppd executable, etc.
+
+Other pre-requisites that will not be detailed here are of course PPP
+support in your OS/kernel, a working pppd, etc.
+
+What do you put on the pppd command line in login.config ?  It really
+depends how you want to handle your incoming PPP connections. Assuming
+you assigned the IP address 192.168.2.1 to your PPP server, and that you
+want some debugging in the system log (on Linux: /var/log/messages),
+you would use something like this:
+
+   /AutoPPP/ -    a_ppp   /usr/sbin/pppd crtscts modem -detach debug 192.168.2.1:
+
+Of course, this doesn't authentify the user, doesn't support
+connecting to other computers than the PPP server, and so on. This
+above examples forces only the server IP address. See below for
+forcing both (only works for one port. For more than one port you need
+either per-user IP addresses, explained below, or per-port IP address,
+explained here (*)).
+
+For authentification, you must add the auth keyword on the pppd command 
+line. Then, you have the following choices:
+
+[
+(*) a ``better'' approach can be to put all those options in /etc/ppp/options.
+    You could create an option file per port your are activating, e.g.
+    if you want to statically set up static addresses per tty, and not
+    per user. WARNING: this is incompatible with the version presented
+                       here. We assume one IP per user, not one IP per port.
+    Example:
+       /etc/ppp/options.ttyS0
+          pppserver:pppserver-ttyS0   # converted by DNS to IP addresses
+          asyncmap 0
+          proxyarp
+          modem
+          auth
+          crtscts
+          require-chap
+          ktune
+          name ppp-server
+          netmask 255.255.255.0
+          ms-dns 192.168.15.1
+          ms-dns 192.168.15.2
+
+    AT LEAST: you should not have some options in /etc/ppp/options, and
+              some more on the command line. Keep everything in the
+              same place.
+]
+
+   - you can use a password database in /etc/ppp/, be it chap-secrets or
+     pap-secrets (chap-secrets contains cleartext passwords, but password
+     hashes only are transmitted in clear; pap-secrets works mostly like
+     UNIX authentification: the crypted password is stored and the
+     unencrypted is transmitted).
+
+        auth -pap +chap
+        auth +pap -chap
+
+   - you can use PAP, but with the /etc/passwd database (or possibly even
+     the PAM authentifications). This is the ``login'' option.
+
+        auth +pap -chap login
+
+Assuming you use PAP, you need to modify the /etc/ppp/pap-secrets, unless
+you used the login option: in that case, valid users in /etc/passwd make
+valid users for PPP. Possibly the IP address is then taken from
+/etc/ppp/pap-secrets, still (but I am not sure of it --- I don't use the
+login option, I use CHAP anyway).
+
+Note that you can force an IP address for the client either by listing it
+on the right of the /etc/ppp/chap-secrets or /etc/ppp/pap-secrets, or in
+the command line (192.168.2.1:192.168.2.2 forces 192.168.2.2 as client).
+
+Of course, forcing for both only works either if you have only one
+PPP dialup line, or if you assigned specific configurations/addresses
+per tty (see the bracketed comments above about /etc/ppp/options.ttySx).
+
+Note that if the client not only authentifies itself to the server but
+also requests authentification from the PPP server, things get more
+complicated. In most setups you don't need this, so do not use auth
+keyword on the pppd client.
+
+Some users report that some distributions ship pppd without the
+execute bit set. This will even prevent root from executing it.
+
+   chmod 555 `which pppd`
+   chown root.root `which pppd`
+
+You don't need the setuid or setgid or any other things when
+running from mgetty login.config.
+
+Other users reported that pppd version 2.3.7 has a bug which causes
+not passing of utmp parameters with /AutoPPP/, ``hence you will never
+get a login using /etc/passwd''. Versions 2.3.8 and 2.3.9 seem
+unaffected.  Well, I don't really understand why utmp should be
+related to that problem.
+
+To allow the newly connected user to connect to any computer of the local
+network where the PPP server is located, you need this:
+
+   - The IP addresses must be in the same routing zone as the ones from
+     the local network. This means: if the Ethernet network uses
+     192.168.2.X (or 192.168.2.0/24 as people like to write it), your
+     PPP server and the PPP users must get assigned addresses in this
+     zone too.
+
+   - You must add the ``proxyarp'' option to the AutoPPP line above. This
+     tells pppd that it should advertises the user PPP connected address
+     on the Ethernet.
+
+   - Your kernel must have IP forwarding on, and in some cases the option
+     ktune should also be given to pppd so it can set it for that
+     interface (assuming you don't forward by default).
+
+Alternatively, you can set up your PPP server with completely different
+addresses, but then you need to either have all computers on the Ethernet
+to have default route on the PPP server or to have specific routing.
+
+That will not make proprietary non-routable protocols such as NetBEUI
+work: typically the ``Network neighbourhood'' of MS-WINDOWS'* will fail.
+For that to work, you need to have a WINS server on the network (be it on
+the Ethernet or the PPP server itself), and reference it in hard in the
+dial-in clients (it works better that way it seems).
+
+You may also want to configure your /etc/ppp/options file, e.g. for
+supporting extensions such as the Microsoft DNS or WINS handshake.
+
+Typical problems that can happen:
+   - /var/log/messages complaining about some ppp-* modules not found
+        Edit /etc/conf.modules
+           alias ppp-compress-21 bsd_comp
+           alias ppp-compress-24 ppp_deflate
+           alias ppp-compress-26 ppp_deflate
+        Check that you have those modules in /lib/modules/VERSION/net/.
+
+Typical questions:
+   Q: What are supported pppd versions ?
+   A: I don't really know. I use ppp-2.2.0f, which is damn old.
+
+   Q: Can you explain the mgetty/pppd interactions ?
+   A: Basically, mgetty never runs when pppd (or login, or uucico, or
+      a shell after login) runs. mgetty will be relaunched by init when
+      the last child dies (be it the shell, pppd, etc).
+
+      In more details:
+	 1 the user dials the number, the modem returns CONNECT, mgetty
+	   has the modem line on the other end.
+
+	 2 mgetty probes the line for a
+	      - fidonet prompt
+	      - PPP sequence
+	   If the appropriate sequence is received, the appropriate program 
+	   is launched (depending on login.conf /AutoPPP/ and /fido/ I think. 
+	   Else, a login: prompt is sent.
+
+	 3 Based on the login received and login.conf, the appropriate login
+	   program is launched.
+
+	Basically, the call is no longer mgetty's business either at the
+        reception of the PPP frame, fido frame, or login name. That's why
+        we don't like to do PPP support in the mgetty mailing-list.
+
+	Now, if you don't want to use AutoPPP, you can well have a special   
+	username launching pppd in login.conf, or even a special user, a
+	password, and pppd as login shell in a way it works (this involves
+        suid root, special groups, etc). But all this means you need the
+        client to not just send a PPP frame, but to send a chatting sequence
+        --- much more complicated.
+
+	CHAP or PAP is an additional authentification. You don't need it if
+        you use a special user + password (no AutoPPP). If you use AutoPPP,
+        you are advised to also have CHAP or PAP since else your system is
+        open to any dialer without any authentification (same if the account
+        has no password, or is specified in login.conf)
+
+   Q: How do you tell if my mgetty precompiled binary is recent/contains
+      support for AutoPPP or other features.
+   A: I will give typical commands and their results
+
+         grep getlogname /var/log/vgetty.ttyS0
+         -> 10/25 15:22:29 yS0   getlogname (FIDO AUTO_PPP), read:~[ff]}#[c0]!
+
+         rpm -q -f `which mgetty`
+
+         /usr/lib/mgetty/mgetty -V
+        
+Typical configuration example (one which is used):
+
+If after all this, you still have a problem with pppd and mgetty, post to
+the mailing-list, but make sure that you:
+
+   - show clearly if mgetty does launch pppd or not (ie if it's a mgetty
+     or pppd problem)
+   - show an excerpt from the system pppd log.
+
+Maybe you should also try linux-ppp or other mailing-lists if mgetty
+seems to NOT be the issue.
+
+
+
+
+
diff -urP mgetty-1.1.22/fax/faxspool.in mgetty-current/fax/faxspool.in
--- mgetty-1.1.22/fax/faxspool.in	Sun Aug  6 20:06:21 2000
+++ mgetty-current/fax/faxspool.in	Thu Nov 16 11:41:40 2000
@@ -3,7 +3,7 @@
 # faxspool - sample script how to spool fax input data to a spool
 #            directory, creating jobs to be run by faxrunq
 #
-# sccsid: $Id$ (c) Gert Doering
+# sccsid: $Id$ (c) Gert Doering
 #
 # syntax: faxspool [flags] <phone-number> <job(s)>
 #
@@ -26,6 +26,9 @@
 #  3.10.93: use "hp2hig3" for hp-pcl4-files (cl)
 # 19.10.93: phone directories (caz)
 # $Log$
+# Revision 4.18  2000/10/11 10:06:41  gert
+# fix combination of "copy_sorce" and "faxspool.rules" (command line destroyed)
+#
 # Revision 4.17  2000/08/06 18:06:21  gert
 # make wording of success message clearer for -t <hh:mm> case
 #
@@ -850,7 +853,7 @@
 if [ ! -z "$copy_source" ] ; then
     $echo "\nCopy source files (for printing, if faxing fails)..."
     mkdir $spooldir/.source-files
-    for file
+    for file in $input_data
     do
 	b=`basename $file`
 	cp $file $spooldir/.source-files/$b
Only in mgetty-1.1.22/frontends: Makefile
Only in mgetty-1.1.22/frontends: README
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: COPYING
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: ChangeLog
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: Imakefile
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: Makefile
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: README
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: faxexpand.c
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: faxexpand.h
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: faxinit.c
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: faxinput.c
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: g3hack.c
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: viewfax.c
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: viewfax.man
Only in mgetty-1.1.22/frontends/X11/viewfax-2.4: viewfax.tif
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/COPYING mgetty-current/frontends/X11/viewfax-2.5/COPYING
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/COPYING	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/COPYING	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                          675 Mass Ave, Cambridge, MA 02139, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/ChangeLog mgetty-current/frontends/X11/viewfax-2.5/ChangeLog
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/ChangeLog	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/ChangeLog	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,341 @@
+--------------------
+Version 2.5 released
+--------------------
+
+2000-08-26  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Imakefile: cleaned up defaults.
+
+	* viewfax.man: updated URLs.
+
+2000-08-25  Paul Eggert  <eggert@twinsun.com>
+
+	* viewfax.c (drawline): Don't overrun the buffer.
+	
+1999-03-07  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* faxexpand.c (MHexpand): byte alignment at end of line was
+	broken (Marc Boucher).
+
+	* faxinput.c (getstrip), viewfax.c (GetImage): protect against
+ 	zero-length strip (Didier Gautheron).
+
+Thu Jun 12 12:11:58 1997  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* viewfax.c (drawline): protect against a damaged fax expanding to
+		  more lines than claimed by the height parameter.
+
+--------------------
+Version 2.4 released
+--------------------
+
+Wed Nov 13 22:40:52 1996  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* viewfax.c (NewImage): Set bitmap_unit to 32.  (Fixes garbled
+	  images on some 8/16-bit oriented servers - found by
+	  bod@tyndall.com.au (Brendan O'Dea)).
+
+Thu May  9 16:16:36 1996  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* All files: FSF address changed.
+
+	* viewfax.man: add URL for faxview.
+
+	* faxinput.c: need to include <sys/types.h>
+
+	* faxexpand.c (SKIP_EOL): eat one bit at a time while scanning for
+	EOL (reported by twells@cp10.es.xerox.com (Terry Wells)).
+
+--------------------
+Version 2.3 released
+--------------------
+
+Sun Oct 15 11:23:01 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* viewfax.c (drawline): interpret LineNum parameter within strip.
+	(GetImage): iterate over strips of multistrip image.
+
+	* faxinput.c (notetiff): grab whole directory into memory.  Don't
+	treat non-fax tiffs as raw files.  Put strip info in an array
+	rather than a linked list.  Accept compression mode 2 (MH).
+	(getstrip): was getpage.
+
+	* faxinit.c: initialise table entries for extension codes.
+
+	* faxexpand.h: change strips in pagenode from list to array.
+	Declare MHexpand, getstrip.
+
+	* faxexpand.c (expand1d): detect and warn about extension codes.
+	   (I chickened out of actually processing them).
+	(expand2d): correct bug in EOL handling.
+	(MHexpand): new routine.
+	(g31expand, g32expand, g4expand): loop limit is rowsperstrip, mot
+	height.
+	(g4expand): semi-fix RTC detection (still does not allow for
+	padding).
+
+Sat Oct 14 11:27:03 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* viewfax.man: faxview.tcl was viewfax.tcl (got hit by a global
+	replace).  Added Shift-Q, L, M, U keys.
+
+	* Imakefile: add definition for MANDIR.  The helpfile is nonexec.
+	Don't define local directories if freebsd.
+
+	* viewfax.c (ShowLoop): New keypress meanings:
+	Shift-Q - terminate with prejudice (requested by Ralph Schleicher).
+	Shift-L,M,U - rotate this and all following pages (requested by
+	Viet Hoang).
+
+--------------------
+Version 2.2 released
+--------------------
+
+Mon Sep 11 10:21:17 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* viewfax.c (GetImage): this routine must return a status
+	indicating if getpage() failed.  Its callers must try again until
+	it succeeds (to deal with missing pages).
+
+Sun Sep 10 17:31:39 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* viewfax.man: update to reflect new functionality.
+
+	* viewfax.c (main): TIFF is no longer optional (the help page is a
+	tiff file).
+	(ShowLoop): display help page if requested.  Accept BackSpace key
+	for previous page.  Mirror image if requested.
+	(ZoomImage): the pb1 pointer could overrun the end of the Big
+	image by one word if an odd number of Big words fit in a Small
+	line.
+	(MirrorImage): new routine.
+
+	* faxexpand.h: keep a list of strip offsets in pagenodes instead
+	of a single offset to the fax data in a file.  Add the
+	mirror-image orientation flag.  Remove WITH_TIFF.
+
+	* faxinput.c (notetiff): handle all 8 orientations.  Handle
+        multi-strip tiff images.  Remove WITH_TIFF.
+
+	* faxexpand.c (SKIP_EOL): don't set a0 = lastx after an error, it
+	is a lie that prevents the line being properly filled out.
+	(g31expand & g32expand): report incorrect line length if verbose.
+
+	* Makefile (CFLAGS): remove -DWITH_TIFF - it is no longer
+	optional.  Add g3hack and the HELPFILE.  Add -ansi -pedantic to
+	gcc flags.
+
+	* Imakefile: remove WITH_TIFF, add HELPFILE.
+
+	* README: make / make depend in wrong order.  Remove comment about
+	WITH_TIFF.
+
+Wed Jun 21 09:44:25 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Updated the FSF address in all file headers.
+
+--------------------
+Version 2.1 released
+--------------------
+
+Wed Apr 12 11:24:34 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* faxexpand.c: simpified access to raw data by preprocessing it
+	into 16-bit lsb-first chunks.  Ensure all macros are either
+	expressions or statements (not blocks).
+
+	* faxinit.c: build tables for access with lsb-first bit order.
+
+	* faxinput.c: new source file containing routines moved from
+	viewfax.c.
+
+	* viewfax.c: moved the input file processing to a separate source
+	file (faxinput.c) in preparation for use with other utilities.
+	Eliminated G3desc and made the expansion routines use pagenodes.
+
+----------------------------------------------------------------
+Renamed again due to name conflict with hylafax/contrib/faxview.
+Now call viewfax.
+----------------------------------------------------------------
+
+Fri Apr  7 18:10:35 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 2.0 released.
+
+	* faxexpand.c: new expansion routines g32expand() and g4expand().
+	Caller provides a pointer to the line drawing routine for future
+	flexibility.
+
+	* faxview.c (main): new options -2 and -4.
+	(drawline): moved out of faxexpand.c.
+
+	* README: Mention g4, WITH_TIFF.
+
+----------------------------------------------------------------
+Renamed from g3view to faxview to reflect new functionality.
+----------------------------------------------------------------
+
+Sat Apr  1 21:06:55 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 1.9 released to testers.
+
+	* g3view.man: mention tiff and hylafax.  Document new keys for
+	previous/next page.
+
+	* g3view.c (notetiff): new function which figures out where the
+	raw image data is in a tiff file.
+
+Fri Mar 31 12:17:53 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* g3view.c (usleep): added to the list of systems which have
+	usleep in libc.
+	(SetupDisplay): restrict the initial window size to the physical
+	screen size even if the virtual root is bigger.
+	(ShowLoop): allow '-' as a synonym for previous page and '+' and
+	space as synonyms for next page.
+
+Sun Feb 26 15:31:53 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 1.8 released.
+
+	* g3view.c (getpage): report memused (in verbose mode) after
+	generating the new image.
+	(SetupDisplay): fixed problems with negative geometry coordinates.
+	(ShowLoop): improved the handling of user window-movement and
+	resizing.  Maintain image position when it is zoomed in a
+	constrained window size.
+
+Thu Feb 16 12:18:38 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* g3view.c: #define XLIB_ILLEGAL_ACCESS is required by SCO- (and
+	maybe other) systems in order to access the contents of the
+	Display structure.
+	(RotImage): fixed boundary problem.
+	(main): allow any abbreviation of -display and -geometry.
+	(ShowLoop): process all pending key- and button-presses before
+	updating display.  Ignore key and button presses while the window
+	is changing size, otherwise the image size and window size can get
+	out of sync.
+	(ShowLoop): don't jump to the top left if -geometry constrains
+	size but not position.
+
+Wed Feb 15 13:21:36 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 1.6 released.
+
+	* g3expand.c (G3init): finally killed the gentab -> g3tables
+	precomputing step, in favour of run-time initialisation.  Time for
+	G3init is down in the profiling noise.
+
+	* g3view.c (SetupDisplay): use the size of the root window rather
+	than the size of the screen as the maximum possible geometry.
+	(ShowLoop): use the user-specified geometry (default: entire root
+	window) to constrain the area available to g3view.
+
+	* g3view.man: get rid of -x and talk about window managers.
+
+Tue Feb 14 20:55:57 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* g3view.c (ShowLoop): another change to the window resizing
+	logic.  It now works as desired with all window managers except
+	fvwm.  Use g3view -x25 under fvwm until fvwm gets fixed.
+
+	* g3view.man: documented -r and -x
+
+Sun Feb 12 18:45:28 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* g3view.c: added command-line-settable display and geometry
+	values, dynamic bit-reversal of input files and warning bell
+	(audible/visible) when attempting to move to non-existent page.
+	Removed -m and -x window-manager kludges.  -m now gives limit to
+	image-memory cache size.
+	(getpage): delete the mmap() version.  We now always suck the
+	input file into memory so we can optionally bit-reverse it and so
+	we can add zeros at the end to prevent the expansion algorithm
+	over-running without having to check each byte.  Also survive
+	unreadable or empty files by removing them from the file list.
+	(GetVRoot): took this function from the comp.windows.x FAQ.  I
+	can't test it 'cos I don't have the solbourne virtual WM around
+	here.
+	(SetupDisplay): process user's geometry spec.
+	(ShowLoop): try to cooperate with the window manager by tracking
+	Reparent and Configure events.  Use NewImage() and FreeImage() to
+	manage cache size.  Give warning when there is no previous/next
+	page.  Allow zooming with z/Z.
+	(RotImage): provide faster version which does 4 rows at a time.
+
+	* g3expand.c: removed the compile-time REVERSE option (we now have
+	an equivalent at run-time). Removed 2D states from debug list.
+	(G3expand): Added line number to error messages.  Tightened up
+	end-of-data detection to prevent core dumps.
+	(G3count): Continue counting after spurious EOLs (for
+	efax-mutilated digifax files).
+
+	* g3.h: removed unused 2D state definitions.
+
+	* README: recommend Imakefile.
+
+	* Makefile: $(HAVE) is no longer needed.  Added -Wno-uninitialized
+	to suppress uninteresting warnings in new RotImage() code.  Added
+	Imakefile to FILES.
+
+	* g3view.man: renamed from g3view.1 to comply with Imake
+	convention.  Added documentation of new features.
+
+Mon Feb  6 12:42:14 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 1.4 released.
+
+	* Makefile: don't need _HAVE_XSETWMPROTOCOLS any more.
+
+	* g3view.c: added -m and -x flags.  Avoid using SetWMProtocols for
+	compatibility with ancient installations.  Release non-essential
+	memory and retry if a malloc or Xcall fails.
+
+	* g3view.1: documented -m and -x flags.
+
+Sat Feb  4 12:43:50 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* g3expand.c (G3expand): fixed a malloc bug (not enough memory
+	requested for run-length list).
+
+Fri Feb  3 11:10:48 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* g3view.c: Support a list of files on the command line rather
+	than just a single page.
+
+	* g3view.1: Updated to reflect new functionality.
+
+	* g3view.c (ZoomImage): still didn't work on little-endian
+	hosts. It now operates on 32 bit words and should be
+	architecture-independent (and faster).  Three versions are
+	available via #ifdef.
+	(SetupDisplay): it is unnecessary to constrain the minimum window
+	size.
+	(ShowLoop): changed the image scrolling method (middle mouse
+	button) to actively chew through the event queue instead of
+	waiting for motion hints.  The old method is still available if
+	USE_MOTIONHINT is defined.
+	(SetupDisplay): fix a rounding problem with the initial window
+	size.
+
+Thu Feb  2 23:00:00 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 1.2 released.
+
+	* Makefile: tar and shar targets added.
+
+	* g3view.1: update to reflect changed middle button handling.
+
+	* g3view.c: added version number and "COPYING" reference to usage
+	and verbose messages.  Removed arguments from getopt() prototype
+	(there is no consensus about if, where and how it is declared).
+	Fixed problem with window size constraints when running under mwm.
+	(ZoomImage): corrected packing order on little-endian hosts.
+	(ShowLoop): improved middle button handling (now it drags the
+	image rather than making it jump).
+	
+
+Tue Jan 31 18:00:00 1995  Frank D. Cringle  <fdc@cliwe.ping.de>
+
+	* Version 1.0 released.
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/Imakefile mgetty-current/frontends/X11/viewfax-2.5/Imakefile
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/Imakefile	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/Imakefile	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,19 @@
+# Imakefile for viewfax
+
+#if 0
+define these if the defaults are unsuitable
+BINDIR = /usr/local/bin		/* where you want the binary installed */
+MANDIR = /usr/local/man/man1	/* where you want the man file installed */
+HELPDIR = /usr/local/lib	/* where you want the help file installed */
+#endif
+
+HELPDIR = ${USRLIBDIR}/X11
+DEFINES = -DHELPFILE=\"$(HELPDIR)/viewfax.tif\"
+
+SRCS = viewfax.c faxinput.c faxinit.c faxexpand.c
+OBJS = viewfax.o faxinput.o faxinit.o faxexpand.o
+SYS_LIBRARIES = $(XLIB)
+DEPLIBS = $(DEPXLIB)
+
+ComplexProgramTarget(viewfax)
+InstallNonExec(viewfax.tif,$(HELPDIR))
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/Makefile mgetty-current/frontends/X11/viewfax-2.5/Makefile
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/Makefile	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/Makefile	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,84 @@
+# Makefile for viewfax
+# Copyright (C) 1990, 1995  Frank D. Cringle.
+
+# This file is part of viewfax - g3/g4 fax processing software.
+#      
+# viewfax is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2 of the License, or (at your
+# option) any later version.
+#      
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#      
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+VERS = 2.5
+
+####### Site-specific definitions #######
+# Destination directories and installation program for make install
+BINDIR = /usr/local/bin
+LIBDIR = /usr/local/lib
+MANDIR	= /usr/local/man/man1
+INSTALL = /usr/ucb/install
+RM = rm -f
+# Location of help file
+HELP = \"$(LIBDIR)/viewfax.tif\"
+# optimisation level, debug etc
+OPT = -g -O2 -Wno-uninitialized -ansi -pedantic
+# C compiler and libraries
+# vanilla sysv
+#CC = cc
+#CFLAGS = $(OPT) -DHELPFILE=$(HELP)
+#LDFLAGS = $(OPT)
+#LIBS = -lsocket
+# vanilla BSD
+#CC = cc
+#CFLAGS = -DBSD $(OPT) -DHELPFILE=$(HELP)
+#LDFLAGS = $(OPT)
+#LIBS =
+# sun solaris2 with gcc on supersparc:
+CC = gcc
+CFLAGS = -Wall $(OPT) -DHELPFILE=$(HELP) -msupersparc -I/usr/openwin/include
+LDFLAGS = $(OPT) -L/usr/openwin/lib -R/usr/openwin/lib
+LIBS =
+
+####### End of configurable definitions #######
+OBJS = viewfax.o faxinput.o faxinit.o faxexpand.o
+
+viewfax:	$(OBJS)
+	$(CC) $(LDFLAGS) -o viewfax $(OBJS) -lX11 $(LIBS)
+
+g3hack:		g3hack.c
+
+install: viewfax
+	$(INSTALL) -s -m 755 viewfax $(BINDIR)
+	$(INSTALL) -m 644 viewfax.man $(MANDIR)/viewfax.1
+	$(INSTALL) -m 644 viewfax.tif $(LIBDIR)
+
+D = viewfax-$(VERS)
+FILES = $D/README $D/COPYING $D/ChangeLog $D/Imakefile $D/Makefile \
+	$D/faxexpand.c $D/faxexpand.h $D/faxinput.c $D/faxinit.c \
+	$D/viewfax.c $D/viewfax.man $D/viewfax.tif $D/g3hack.c
+
+viewfax.tif:	viewfax.ps g3hack
+	gs -sDEVICE=faxg3 -sOutputFile=viewfax.g3 -dNOPAUSE -q -dSAFER viewfax.ps -c quit
+	./g3hack -n 100 -o viewfax.g3s viewfax.g3
+	fax2tiff -M -4 -o viewfax.tif viewfax.g3s
+	$(RM) viewfax.g3 viewfax.g3s
+
+tar:;	(cd ..; tar cf - $(FILES) | gzip -9 >$D/$D.tar.gz)
+
+shar:;	(cd ..; shar -a -n$D -M -sfdc@cliwe.ping.de -c -o $D/part -l64 $(FILES))
+
+clean:;	$(RM) *.o *~ core
+
+viewfax.o:	faxexpand.h
+faxinput.o:	faxexpand.h
+faxinit.o:	faxexpand.h
+faxexpand.o:	faxexpand.h
+faxcompress.o:	faxexpand.h
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/README mgetty-current/frontends/X11/viewfax-2.5/README
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/README	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/README	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,22 @@
+This directory contains viewfax, a tool for displaying fax files
+in an X Window.
+
+Viewfax can display raw, digifax or tiff files containing g3 (T.4)
+and/or g4 (T.6) coded fax pages.
+
+To install viewfax you need an ansi C compiler on a machine
+supporting X11.  No toolkit is required, just Xlib.
+
+If you have a correctly installed imake, type:
+
+    xmkmf
+    make depend
+    make
+    make install
+    make install.man
+
+If you do not want to use imake you will need to adjust the Makefile
+for your environment.
+
+--
+Frank Cringle (fdc@cliwe.ping.de)
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/faxexpand.c mgetty-current/frontends/X11/viewfax-2.5/faxexpand.c
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/faxexpand.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/faxexpand.c	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,729 @@
+/* Expand one page of fax data
+   Copyright (C) 1990, 1995  Frank D. Cringle.
+
+This file is part of viewfax - g3/g4 fax processing software.
+     
+viewfax is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2 of the License, or (at your
+option) any later version.
+     
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+     
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include "faxexpand.h"
+
+/* Note that NeedBits() only works for n <= 16 */
+#define NeedBits(n) do {						\
+    if (BitsAvail < (n)) {						\
+	BitAcc |= *sp++ << BitsAvail;					\
+	BitsAvail += 16;						\
+    }									\
+} while (0)
+#define GetBits(n)	(BitAcc & ((1<<(n))-1))
+#define ClrBits(n) do {							\
+    BitAcc >>= (n);							\
+    BitsAvail -= (n);							\
+} while (0)
+
+#ifdef DEBUG
+#define DEBUG_SHOW putchar(BitAcc & (1 << t) ? '1' : '0')
+#define LOOKUP(wid,tab)	do {						\
+    int t;								\
+    NeedBits(wid);							\
+    TabEnt = tab + GetBits(wid);					\
+    printf("%08lX/%d: %s%5d\t", BitAcc, BitsAvail,			\
+	   StateNames[TabEnt->State], TabEnt->Param);			\
+    for (t = 0; t < TabEnt->Width; t++)					\
+	DEBUG_SHOW;							\
+    putchar('\n');							\
+    fflush(stdout);							\
+    ClrBits(TabEnt->Width);						\
+} while (0)
+
+#define SETVAL(x) do {							\
+    *pa++ = RunLength + (x);						\
+    printf("SETVAL: %d\t%d\n", RunLength + (x), a0);			\
+    a0 += x;								\
+    RunLength = 0;							\
+} while (0)
+
+char *StateNames[] = {
+    "Null   ",
+    "Pass   ",
+    "Horiz  ",
+    "V0     ",
+    "VR     ",
+    "VL     ",
+    "Ext    ",
+    "TermW  ",
+    "TermB  ",
+    "MakeUpW",
+    "MakeUpB",
+    "MakeUp ",
+    "EOL    ",
+};
+
+#else
+#define LOOKUP(wid,tab)	do {						\
+    NeedBits(wid);							\
+    TabEnt = tab + GetBits(wid);					\
+    ClrBits(TabEnt->Width);						\
+} while (0)
+
+#define SETVAL(x) do {							\
+    *pa++ = RunLength + (x);						\
+    a0 += x;								\
+    RunLength = 0;							\
+} while (0)
+#endif
+
+#define dumpruns(runs) do {						\
+    printf("-------------------- %d\n", LineNum);			\
+    for (pa = runs, a0 = 0; a0 < lastx; a0 += *pa++)			\
+	printf("%4d %d\n", a0, *pa);					\
+} while (0)
+
+#define EndOfData(pn)	(sp >= pn->data + pn->length/sizeof(*pn->data))
+
+/* This macro handles coding errors in G3 data.
+   We redefine it below for the G4 case */
+#define SKIP_EOL do {							\
+    while (!EndOfData(pn)) {						\
+	NeedBits(11);							\
+	if (GetBits(11) == 0)						\
+	    break;							\
+	ClrBits(1);							\
+    }									\
+    ClrBits(11);							\
+    goto EOL;								\
+} while (0)
+#define eol2lab	EOL2:
+
+/* the line expanders are written as macros so that they can be reused
+   (twice each) but still have direct access to the local variables of
+   the "calling" function */
+#define expand1d() do {							\
+    while (a0 < lastx) {						\
+	int done = 0;							\
+	while (!done) {		/* white first */			\
+	    LOOKUP(12, WhiteTable);					\
+	    switch (TabEnt->State) {					\
+	    case S_EOL:							\
+		EOLcnt = 1;						\
+		goto EOL;						\
+	    case S_TermW:						\
+		SETVAL(TabEnt->Param);					\
+		done = 1;						\
+		break;							\
+	    case S_MakeUpW:						\
+	    case S_MakeUp:						\
+		a0 += TabEnt->Param;					\
+		RunLength += TabEnt->Param;				\
+		break;							\
+	    case S_Ext:							\
+		unexpected("Extension code", LineNum);			\
+		SKIP_EOL;						\
+		break;							\
+	    default:							\
+		unexpected("WhiteTable", LineNum);			\
+		SKIP_EOL;						\
+		break;							\
+	    }								\
+	}								\
+	done = a0 >= lastx;						\
+	while (!done) {		/* then black */			\
+	    LOOKUP(13, BlackTable);					\
+	    switch (TabEnt->State) {					\
+	    case S_EOL:							\
+		EOLcnt = 1;						\
+		goto EOL;						\
+	    case S_TermB:						\
+		SETVAL(TabEnt->Param);					\
+		done = 1;						\
+		break;							\
+	    case S_MakeUpB:						\
+	    case S_MakeUp:						\
+		a0 += TabEnt->Param;					\
+		RunLength += TabEnt->Param;				\
+		break;							\
+	    case S_Ext:							\
+		unexpected("Extension code", LineNum);			\
+		SKIP_EOL;						\
+		break;							\
+	    default:							\
+		unexpected("BlackTable", LineNum);			\
+		SKIP_EOL;						\
+		break;							\
+	    }								\
+	}								\
+    }									\
+ EOL: ;									\
+} while (0)
+
+#define CHECK_b1 do {							\
+    if (pa != thisrun) while (b1 <= a0 && b1 < lastx) {			\
+	b1 += pb[0] + pb[1];						\
+	pb += 2;							\
+    }									\
+} while (0)
+
+#define expand2d(eolab) do {						\
+    while (a0 < lastx) {						\
+	LOOKUP(7, MainTable);						\
+	switch (TabEnt->State) {					\
+	case S_Pass:							\
+	    CHECK_b1;							\
+	    b1 += *pb++;						\
+	    RunLength += b1 - a0;					\
+	    a0 = b1;							\
+	    b1 += *pb++;						\
+	    break;							\
+	case S_Horiz:							\
+	    if ((pa-run0)&1) {						\
+		int done = 0;						\
+		while (!done) { /* black first */			\
+		    LOOKUP(13, BlackTable);				\
+		    switch (TabEnt->State) {				\
+		    case S_TermB:					\
+			SETVAL(TabEnt->Param);				\
+			done = 1;					\
+			break;						\
+		    case S_MakeUpB:					\
+		    case S_MakeUp:					\
+			a0 += TabEnt->Param;				\
+			RunLength += TabEnt->Param;			\
+			break;						\
+		    default:						\
+			unexpected("BlackTable", LineNum);		\
+			SKIP_EOL;					\
+			break;						\
+		    }							\
+		}							\
+		done = 0;						\
+		while (!done) { /* then white */			\
+		    LOOKUP(12, WhiteTable);				\
+		    switch (TabEnt->State) {				\
+		    case S_TermW:					\
+			SETVAL(TabEnt->Param);				\
+			done = 1;					\
+			break;						\
+		    case S_MakeUpW:					\
+		    case S_MakeUp:					\
+			a0 += TabEnt->Param;				\
+			RunLength += TabEnt->Param;			\
+			break;						\
+		    default:						\
+			unexpected("WhiteTable", LineNum);		\
+			SKIP_EOL;					\
+			break;						\
+		    }							\
+		}							\
+	    }								\
+	    else {							\
+		int done = 0;						\
+		while (!done) { /* white first */			\
+		    LOOKUP(12, WhiteTable);				\
+		    switch (TabEnt->State) {				\
+		    case S_TermW:					\
+			SETVAL(TabEnt->Param);				\
+			done = 1;					\
+			break;						\
+		    case S_MakeUpW:					\
+		    case S_MakeUp:					\
+			a0 += TabEnt->Param;				\
+			RunLength += TabEnt->Param;			\
+			break;						\
+		    default:						\
+			unexpected("WhiteTable", LineNum);		\
+			SKIP_EOL;					\
+			break;						\
+		    }							\
+		}							\
+		done = 0;						\
+		while (!done) { /* then black */			\
+		    LOOKUP(13, BlackTable);				\
+		    switch (TabEnt->State) {				\
+		    case S_TermB:					\
+			SETVAL(TabEnt->Param);				\
+			done = 1;					\
+			break;						\
+		    case S_MakeUpB:					\
+		    case S_MakeUp:					\
+			a0 += TabEnt->Param;				\
+			RunLength += TabEnt->Param;			\
+			break;						\
+		    default:						\
+			unexpected("BlackTable", LineNum);		\
+			SKIP_EOL;					\
+			break;						\
+		    }							\
+		}							\
+	    }								\
+	    CHECK_b1;							\
+	    break;							\
+	case S_V0:							\
+	    CHECK_b1;							\
+	    SETVAL(b1 - a0);						\
+	    b1 += *pb++;						\
+	    break;							\
+	case S_VR:							\
+	    CHECK_b1;							\
+	    SETVAL(b1 - a0 + TabEnt->Param);				\
+	    b1 += *pb++;						\
+	    break;							\
+	case S_VL:							\
+	    CHECK_b1;							\
+	    SETVAL(b1 - a0 - TabEnt->Param);				\
+	    b1 -= *--pb;						\
+	    break;							\
+	case S_Ext:							\
+	    *pa++ = lastx - a0;						\
+	    if (verbose)						\
+		fprintf(stderr, "Line %d: extension code\n", LineNum);	\
+	    SKIP_EOL;							\
+	    break;							\
+	case S_EOL:							\
+	    *pa++ = lastx - a0;						\
+	    NeedBits(4);						\
+	    if (GetBits(4) && verbose) /* already seen 7 zeros */	\
+		fprintf(stderr, "Line %d: Bad EOL\n", LineNum);		\
+	    ClrBits(4);							\
+	    EOLcnt = 1;							\
+	    goto eolab;							\
+	    break;							\
+	default:							\
+	    unexpected("MainTable", LineNum);				\
+	    SKIP_EOL;							\
+	    break;							\
+	}								\
+    }									\
+    if (RunLength) {							\
+	if (RunLength + a0 < lastx) {					\
+	    /* expect a final V0 */					\
+	    NeedBits(1);						\
+	    if (!GetBits(1)) {						\
+		unexpected("MainTable", LineNum);			\
+		SKIP_EOL;						\
+	    }								\
+	    ClrBits(1);							\
+	}								\
+	SETVAL(0);							\
+    }									\
+ eol2lab ;								\
+} while (0)
+
+static void
+unexpected(char *what, int LineNum)
+{
+    if (verbose)
+	fprintf(stderr, "Line %d: Unexpected state in %s\n",
+		LineNum, what);
+}
+
+/* Expand tiff modified huffman data (g3-1d without EOLs) */
+void
+MHexpand(struct pagenode *pn, drawfunc df)
+{
+    int a0;			/* reference element */
+    int lastx = pn->width;	/* copy line width to register */
+    t32bits BitAcc;		/* bit accumulator */
+    int BitsAvail;		/* # valid bits in BitAcc */
+    int RunLength;		/* Length of current run */
+    t16bits *sp;		/* pointer into compressed data */
+    pixnum *pa;			/* pointer into new line */
+    int EOLcnt;			/* number of consecutive EOLs */
+    int	LineNum;		/* line number */
+    pixnum *runs;		/* list of run lengths */
+    struct tabent *TabEnt;
+
+    sp = pn->data;
+    BitAcc = 0;
+    BitsAvail = 0;
+    lastx = pn->width;
+    runs = (pixnum *) xmalloc(lastx * sizeof(pixnum));
+    for (LineNum = 0; LineNum < pn->rowsperstrip; ) {
+#ifdef DEBUG
+	printf("\nBitAcc=%08lX, BitsAvail = %d\n", BitAcc, BitsAvail);
+	printf("-------------------- %d\n", LineNum);
+	fflush(stdout);
+#endif
+	RunLength = 0;
+	pa = runs;
+	a0 = 0;
+	EOLcnt = 0;
+	if (BitsAvail & 7)	/* skip to byte boundary */
+	    ClrBits(BitsAvail & 7);
+	expand1d();
+	if (RunLength)
+	    SETVAL(0);
+	if (a0 != lastx) {
+	    if (verbose)
+		fprintf(stderr, "Line %d: length is %d (expected %d)\n", LineNum, a0, lastx);
+	    while (a0 > lastx)
+		a0 -= *--pa;
+	    if (a0 < lastx) {
+		if ((pa - runs) & 1)
+		    SETVAL(0);
+		SETVAL(lastx - a0);
+	    }
+	}
+	(*df)(runs, LineNum++, pn);
+    }
+    free(runs);
+}
+
+/* Expand group-3 1-dimensional data */
+void
+g31expand(struct pagenode *pn, drawfunc df)
+{
+    int a0;			/* reference element */
+    int lastx = pn->width;	/* copy line width to register */
+    t32bits BitAcc;		/* bit accumulator */
+    int BitsAvail;		/* # valid bits in BitAcc */
+    int RunLength;		/* Length of current run */
+    t16bits *sp;		/* pointer into compressed data */
+    pixnum *pa;			/* pointer into new line */
+    int EOLcnt;			/* number of consecutive EOLs */
+    int	LineNum;		/* line number */
+    pixnum *runs;		/* list of run lengths */
+    struct tabent *TabEnt;
+
+    sp = pn->data;
+    BitAcc = 0;
+    BitsAvail = 0;
+    lastx = pn->width;
+    runs = (pixnum *) xmalloc(lastx * sizeof(pixnum));
+    EOLcnt = 0;
+    for (LineNum = 0; LineNum < pn->rowsperstrip; ) {
+#ifdef DEBUG
+	printf("\nBitAcc=%08lX, BitsAvail = %d\n", BitAcc, BitsAvail);
+	printf("-------------------- %d\n", LineNum);
+	fflush(stdout);
+#endif
+	if (EOLcnt == 0)
+	    while (!EndOfData(pn)) {
+		/* skip over garbage after a coding error */
+		NeedBits(11);
+		if (GetBits(11) == 0)
+		    break;
+		ClrBits(1);
+	    }
+	for (EOLcnt = 1; !EndOfData(pn); EOLcnt++) {
+	    /* we have seen 11 zeros, which implies EOL,
+	       skip possible fill bits too */
+	    while (1) {
+		NeedBits(8);
+		if (GetBits(8))
+		    break;
+		ClrBits(8);
+	    }
+	    while (GetBits(1) == 0)
+		ClrBits(1);
+	    ClrBits(1);		/* the eol flag */
+	    NeedBits(11);
+	    if (GetBits(11))
+		break;
+	    ClrBits(11);
+	}
+	if (EOLcnt > 1 && EOLcnt != 6 && verbose)
+	    fprintf(stderr, "Line %d: bad RTC (%d EOLs)\n", LineNum, EOLcnt);
+	if (EOLcnt >= 6 || EndOfData(pn)) {
+	    free(runs);
+	    return;
+	}
+	RunLength = 0;
+	pa = runs;
+	a0 = 0;
+	EOLcnt = 0;
+	expand1d();
+	if (RunLength)
+	    SETVAL(0);
+	if (a0 != lastx) {
+	    if (verbose)
+		fprintf(stderr, "Line %d: length is %d (expected %d)\n", LineNum, a0, lastx);
+	    while (a0 > lastx)
+		a0 -= *--pa;
+	    if (a0 < lastx) {
+		if ((pa - runs) & 1)
+		    SETVAL(0);
+		SETVAL(lastx - a0);
+	    }
+	}
+	(*df)(runs, LineNum++, pn);
+    }
+    free(runs);
+}
+
+/* Expand group-3 2-dimensional data */
+void
+g32expand(struct pagenode *pn, drawfunc df)
+{
+    int RunLength;		/* Length of current run */
+    int a0;			/* reference element */
+    int b1;			/* next change on previous line */
+    int lastx = pn->width;	/* copy line width to register */
+    pixnum *run0, *run1;	/* run length arrays */
+    pixnum *thisrun, *pa, *pb;	/* pointers into runs */
+    t16bits *sp;		/* pointer into compressed data */
+    t32bits BitAcc;		/* bit accumulator */
+    int BitsAvail;		/* # valid bits in BitAcc */
+    int EOLcnt;			/* number of consecutive EOLs */
+    int	refline = 0;		/* 1D encoded reference line */
+    int	LineNum;		/* line number */
+    struct tabent *TabEnt;
+
+    sp = pn->data;
+    BitAcc = 0;
+    BitsAvail = 0;
+    /* allocate space for 2 runlength arrays */
+    run0 = (pixnum *) xmalloc(2 * ((lastx+5)&~1) * sizeof(pixnum));
+    run1 = run0 + ((lastx+5)&~1);
+    run1[0] = lastx;
+    run1[1] = 0;
+    EOLcnt = 0;
+    for (LineNum = 0; LineNum < pn->rowsperstrip; ) {
+#ifdef DEBUG
+	printf("\nBitAcc=%08lX, BitsAvail = %d\n", BitAcc, BitsAvail);
+	printf("-------------------- %d\n", LineNum);
+	fflush(stdout);
+#endif
+	if (EOLcnt == 0)
+	    while (!EndOfData(pn)) {
+		/* skip over garbage after a coding error */
+		NeedBits(11);
+		if (GetBits(11) == 0)
+		    break;
+		ClrBits(1);
+	    }
+	for (EOLcnt = 1; !EndOfData(pn); EOLcnt++) {
+	    /* we have seen 11 zeros, which implies EOL,
+	       skip possible fill bits too */
+	    while (1) {
+		NeedBits(8);
+		if (GetBits(8))
+		    break;
+		ClrBits(8);
+	    }
+	    while (GetBits(1) == 0)
+		ClrBits(1);
+	    ClrBits(1);		/* the eol flag */
+	    NeedBits(12);
+	    refline = GetBits(1); /* 1D / 2D flag */
+	    ClrBits(1);
+	    if (GetBits(11))
+		break;
+	    ClrBits(11);
+	}
+	if (EOLcnt > 1 && EOLcnt != 6 && verbose)
+	    fprintf(stderr, "Line %d: bad RTC (%d EOLs)\n", LineNum, EOLcnt);
+	if (EOLcnt >= 6 || EndOfData(pn)) {
+	    free(run0);
+	    return;
+	}
+	if (LineNum == 0 && refline == 0 && verbose)
+	    fprintf(stderr, "First line is 2-D encoded\n");
+	RunLength = 0;
+	if (LineNum & 1) {
+	    pa = run1;
+	    pb = run0;
+	}
+	else {
+	    pa = run0;
+	    pb = run1;
+	}
+	thisrun = pa;
+	EOLcnt = 0;
+	a0 = 0;
+	b1 = *pb++;
+
+	if (refline) {
+	    expand1d();
+	}
+	else {
+	    expand2d(EOL2);
+	}
+	if (RunLength)
+	    SETVAL(0);
+	if (a0 != lastx) {
+	    if (verbose)
+		fprintf(stderr, "Line %d: length is %d (expected %d)\n", LineNum, a0, lastx);
+	    while (a0 > lastx)
+		a0 -= *--pa;
+	    if (a0 < lastx) {
+		if ((pa - run0) & 1)
+		    SETVAL(0);
+		SETVAL(lastx - a0);
+	    }
+	}
+	SETVAL(0);	/* imaginary change at end of line for reference */
+	(*df)(thisrun, LineNum++, pn);
+    }
+    free(run0);
+}
+
+/* Redefine the "skip to eol" macro.  We cannot recover from coding
+   errors in G4 data */
+#undef SKIP_EOL
+#undef eol2lab
+#define SKIP_EOL do {							\
+    if (verbose)							\
+	fprintf(stderr, "Line %d: G4 coding error\n", LineNum);		\
+    free(run0);								\
+    return;								\
+} while (0)
+#define eol2lab
+
+/* Expand group-4 data */
+void
+g4expand(struct pagenode *pn, drawfunc df)
+{
+    int RunLength;		/* Length of current run */
+    int a0;			/* reference element */
+    int b1;			/* next change on previous line */
+    int lastx = pn->width;	/* copy line width to register */
+    pixnum *run0, *run1;	/* run length arrays */
+    pixnum *thisrun, *pa, *pb;	/* pointers into runs */
+    t16bits *sp;		/* pointer into compressed data */
+    t32bits BitAcc;		/* bit accumulator */
+    int BitsAvail;		/* # valid bits in BitAcc */
+    int	LineNum;		/* line number */
+    int EOLcnt;
+    struct tabent *TabEnt;
+
+    sp = pn->data;
+    BitAcc = 0;
+    BitsAvail = 0;
+    /* allocate space for 2 runlength arrays */
+    run0 = (pixnum *) xmalloc(2 * ((lastx+5)&~1) * sizeof(pixnum));
+    run1 = run0 + ((lastx+5)&~1);
+    run1[0] = lastx;		/* initial reference line */
+    run1[1] = 0;
+
+    for (LineNum = 0; LineNum < pn->rowsperstrip; ) {
+#ifdef DEBUG
+	printf("\nBitAcc=%08lX, BitsAvail = %d\n", BitAcc, BitsAvail);
+	printf("-------------------- %d\n", LineNum);
+	fflush(stdout);
+#endif
+	RunLength = 0;
+	if (LineNum & 1) {
+	    pa = run1;
+	    pb = run0;
+	}
+	else {
+	    pa = run0;
+	    pb = run1;
+	}
+	thisrun = pa;
+	a0 = 0;
+	b1 = *pb++;
+	expand2d(EOFB);
+	if (a0 < lastx) {
+	    if ((pa - run0) & 1)
+		SETVAL(0);
+	    SETVAL(lastx - a0);
+	}
+	SETVAL(0);	/* imaginary change at end of line for reference */
+	(*df)(thisrun, LineNum++, pn);
+	continue;
+    EOFB:
+	NeedBits(13);
+	if (GetBits(13) != 0x1001 && verbose)
+	    fputs("Bad RTC\n", stderr);
+	break;
+    }
+    free(run0);
+}
+
+static unsigned char zerotab[256] = {
+	0x88, 0x07, 0x16, 0x06, 0x25, 0x05, 0x15, 0x05,
+	0x34, 0x04, 0x14, 0x04, 0x24, 0x04, 0x14, 0x04,
+	0x43, 0x03, 0x13, 0x03, 0x23, 0x03, 0x13, 0x03,
+	0x33, 0x03, 0x13, 0x03, 0x23, 0x03, 0x13, 0x03,
+	0x52, 0x02, 0x12, 0x02, 0x22, 0x02, 0x12, 0x02,
+	0x32, 0x02, 0x12, 0x02, 0x22, 0x02, 0x12, 0x02,
+	0x42, 0x02, 0x12, 0x02, 0x22, 0x02, 0x12, 0x02,
+	0x32, 0x02, 0x12, 0x02, 0x22, 0x02, 0x12, 0x02,
+	0x61, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x31, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x41, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x31, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x51, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x31, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x41, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x31, 0x01, 0x11, 0x01, 0x21, 0x01, 0x11, 0x01,
+	0x70, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x40, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x50, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x40, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x60, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x40, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x50, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x40, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00,
+	0x30, 0x00, 0x10, 0x00, 0x20, 0x00, 0x10, 0x00
+};
+
+#define check(v) do {							\
+    prezeros = zerotab[v];						\
+    postzeros = prezeros & 15;						\
+    prezeros >>= 4;							\
+    if (prezeros == 8) {						\
+	zeros += 8;							\
+	continue;							\
+    }									\
+    if (zeros + prezeros < 11) {					\
+	empty = 0;							\
+	zeros = postzeros;						\
+	continue;							\
+    }									\
+    zeros = postzeros;							\
+    if (empty)								\
+	EOLcnt++;							\
+    lines++;								\
+    empty = 1;								\
+} while (0)
+
+/* count fax lines */
+int
+G3count(struct pagenode *pn, int twoD)
+{
+    t16bits *p = pn->data;
+    t16bits *end = p + pn->length/sizeof(*p);
+    int lines = 0;		/* lines seen so far */
+    int zeros = 0;		/* number of consecutive zero bits seen */
+    int EOLcnt = 0;		/* number of consecutive EOLs seen */
+    int empty = 1;		/* empty line */
+    int prezeros, postzeros;
+
+    while (p < end && EOLcnt < 6) {
+	t16bits bits = *p++;
+	check(bits&255);
+	if (twoD && (prezeros + postzeros == 7)) {
+	    if (postzeros || ((bits & 0x100) == 0))
+		zeros--;
+	}
+	check(bits>>8);
+	if (twoD && (prezeros + postzeros == 7)) {
+	    if (postzeros || ((p < end) && ((*p & 1) == 0)))
+		zeros--;
+	}
+    }
+    return lines - EOLcnt;	/* don't count trailing EOLs */
+}
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/faxexpand.h mgetty-current/frontends/X11/viewfax-2.5/faxexpand.h
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/faxexpand.h	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/faxexpand.h	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,146 @@
+/* Include file for fax routines
+   Copyright (C) 1990, 1995  Frank D. Cringle.
+
+This file is part of viewfax - g3/g4 fax processing software.
+     
+viewfax is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2 of the License, or (at your
+option) any later version.
+     
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+     
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#include <limits.h>
+
+#if ULONG_MAX == 4294967295UL
+typedef unsigned long t32bits;
+#elif UINT_MAX == 4294967295UL
+typedef unsigned int t32bits;
+#else
+#error need a 32-bit unsigned type
+/* if you see the above error, add an #elif case for your architecture
+   and tell fdc@cliwe.ping.de about it */
+#endif
+
+#if USHRT_MAX == 65535
+typedef unsigned short t16bits;
+#elif UINT_MAX == 65535
+typedef unsigned int t16bits;
+#else
+#error need a 16-bit unsigned type
+/* if you see the above error, add an #elif case for your architecture
+   and tell fdc@cliwe.ping.de about it */
+#endif
+typedef t16bits pixnum;
+
+struct pagenode;
+
+/* drawfunc() points to a function which processes a line of the
+   expanded image described as a list of run lengths.
+   run is the base of an array of lengths, starting with a
+   (possibly empty) white run for line number linenum.
+   pn points to the page descriptor */
+typedef void (*drawfunc)(pixnum *run, int linenum, struct pagenode *pn);
+
+struct strip {			/* tiff strip descriptor */
+    off_t offset;		/* offset in file */
+    off_t size;			/* size of this strip */
+};
+
+struct pagenode {		/* compressed page descriptor */
+    struct pagenode *prev, *next; /* list links */
+    char *name;			/* basename of file */
+    char *pathname;		/* full name of file */
+    int	nstrips;		/* number of strips */
+    int rowsperstrip;		/* number of rows per strip */
+    int stripnum;		/* current strip while expanding */
+    struct strip *strips;	/* array of strips containing fax data in file */
+    t16bits *data;		/* in-memory copy of strip */
+    size_t length;		/* length of data */
+    pixnum width;		/* width of page in pixels */
+    pixnum height;		/* height of page in lines */
+    char inverse;		/* black <=> white */
+    char lsbfirst;		/* bit order is lsb first */
+    char orient;		/* orientation - upsidedown, landscape, mirrored */
+    char vres;			/* vertical resolution: 1 = fine  */
+    void (*expander)(struct pagenode *, drawfunc);
+    void *extra;		/* used for Ximage */
+};
+extern struct pagenode *firstpage, *lastpage, *thispage;
+extern struct pagenode defaultpage;
+
+/* page orientation flags */
+#define TURN_U	1
+#define TURN_L	2
+#define TURN_M	4
+
+extern char *ProgName;
+
+/* fsm state codes */
+#define S_Null		0
+#define S_Pass		1
+#define S_Horiz		2
+#define S_V0		3
+#define S_VR		4
+#define S_VL		5
+#define S_Ext		6
+#define S_TermW		7
+#define S_TermB		8
+#define S_MakeUpW	9
+#define S_MakeUpB	10
+#define S_MakeUp	11
+#define S_EOL		12
+
+/* state table entry */
+struct tabent {
+    unsigned char State;
+    unsigned char Width;	/* width of code in bits */
+    pixnum Param;		/* run length */
+};
+
+extern struct tabent MainTable[]; 	/* 2-D state table */
+extern struct tabent WhiteTable[];	/* White run lengths */
+extern struct tabent BlackTable[];	/* Black run lengths */
+
+extern int verbose;
+
+void MHexpand(struct pagenode *pn, drawfunc df);
+void g31expand(struct pagenode *pn, drawfunc df);
+void g32expand(struct pagenode *pn, drawfunc df);
+void g4expand(struct pagenode *pn, drawfunc df);
+
+unsigned char * getstrip(struct pagenode *pn, int strip);
+struct pagenode *notefile(char *name);
+int notetiff(char *name);
+
+/* initialise code tables */
+extern void faxinit(void);
+/* count lines in image */
+extern int G3count(struct pagenode *pn, int twoD);
+
+/* get memory or abort if none available */
+extern char *xmalloc(unsigned int size);
+
+#ifdef linux
+#define _HAVE_USLEEP
+#endif
+
+#if defined(BSD) || defined(__FreeBSD__) || defined(_BSD_SOURCE)
+#define _HAVE_USLEEP
+#ifndef rindex
+#define rindex strrchr
+#endif
+#ifndef bcmp
+#define memcmp bcmp
+#endif
+#define memclr(p,n)	bzero(p,n)
+#else  /* not BSD */
+#define memclr(p,n)	memset(p,0,n)
+#endif
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/faxinit.c mgetty-current/frontends/X11/viewfax-2.5/faxinit.c
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/faxinit.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/faxinit.c	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,337 @@
+/* Initialise fax decoder tables
+   Copyright (C) 1990, 1995  Frank D. Cringle.
+
+This file is part of viewfax - g3/g4 fax processing software.
+     
+viewfax is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2 of the License, or (at your
+option) any later version.
+     
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+     
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#include <sys/types.h>
+#include "faxexpand.h"
+
+struct tabent MainTable[128];
+struct tabent WhiteTable[4096];
+struct tabent BlackTable[8192];
+
+struct proto {
+    t16bits code;		/* right justified, lsb-first, zero filled */
+    t16bits val;		/* (pixel count)<<4 + code width  */
+};
+
+static struct proto Pass[] = {
+{ 0x0008, 4 },
+{ 0, 0 }
+};
+
+static struct proto Horiz[]  = {
+{ 0x0004, 3 },
+{ 0, 0 }
+};
+
+static struct proto V0[]  = {
+{ 0x0001, 1 },
+{ 0, 0 }
+};
+
+static struct proto VR[]  = {
+{ 0x0006, (1<<4)+3 },
+{ 0x0030, (2<<4)+6 },
+{ 0x0060, (3<<4)+7 },
+{ 0, 0 }
+};
+
+static struct proto VL[]  = {
+{ 0x0002, (1<<4)+3 },
+{ 0x0010, (2<<4)+6 },
+{ 0x0020, (3<<4)+7 },
+{ 0, 0 }
+};
+
+static struct proto ExtV[]  = {
+{ 0x0040, 7 },
+{ 0, 0 }
+};
+
+static struct proto EOLV[]  = {
+{ 0x0000, 7 },
+{ 0, 0 }
+};
+
+static struct proto MakeUpW[] = {
+{ 0x001b, 1029 },
+{ 0x0009, 2053 },
+{ 0x003a, 3078 },
+{ 0x0076, 4103 },
+{ 0x006c, 5128 },
+{ 0x00ec, 6152 },
+{ 0x0026, 7176 },
+{ 0x00a6, 8200 },
+{ 0x0016, 9224 },
+{ 0x00e6, 10248 },
+{ 0x0066, 11273 },
+{ 0x0166, 12297 },
+{ 0x0096, 13321 },
+{ 0x0196, 14345 },
+{ 0x0056, 15369 },
+{ 0x0156, 16393 },
+{ 0x00d6, 17417 },
+{ 0x01d6, 18441 },
+{ 0x0036, 19465 },
+{ 0x0136, 20489 },
+{ 0x00b6, 21513 },
+{ 0x01b6, 22537 },
+{ 0x0032, 23561 },
+{ 0x0132, 24585 },
+{ 0x00b2, 25609 },
+{ 0x0006, 26630 },
+{ 0x01b2, 27657 },
+{ 0, 0 }
+};
+
+static struct proto MakeUpB[] = {
+{ 0x03c0, 1034 },
+{ 0x0130, 2060 },
+{ 0x0930, 3084 },
+{ 0x0da0, 4108 },
+{ 0x0cc0, 5132 },
+{ 0x02c0, 6156 },
+{ 0x0ac0, 7180 },
+{ 0x06c0, 8205 },
+{ 0x16c0, 9229 },
+{ 0x0a40, 10253 },
+{ 0x1a40, 11277 },
+{ 0x0640, 12301 },
+{ 0x1640, 13325 },
+{ 0x09c0, 14349 },
+{ 0x19c0, 15373 },
+{ 0x05c0, 16397 },
+{ 0x15c0, 17421 },
+{ 0x0dc0, 18445 },
+{ 0x1dc0, 19469 },
+{ 0x0940, 20493 },
+{ 0x1940, 21517 },
+{ 0x0540, 22541 },
+{ 0x1540, 23565 },
+{ 0x0b40, 24589 },
+{ 0x1b40, 25613 },
+{ 0x04c0, 26637 },
+{ 0x14c0, 27661 },
+{ 0, 0 }
+};
+
+static struct proto MakeUp[] = {
+{ 0x0080, 28683 },
+{ 0x0180, 29707 },
+{ 0x0580, 30731 },
+{ 0x0480, 31756 },
+{ 0x0c80, 32780 },
+{ 0x0280, 33804 },
+{ 0x0a80, 34828 },
+{ 0x0680, 35852 },
+{ 0x0e80, 36876 },
+{ 0x0380, 37900 },
+{ 0x0b80, 38924 },
+{ 0x0780, 39948 },
+{ 0x0f80, 40972 },
+{ 0, 0 }
+};
+
+static struct proto TermW[] = {
+{ 0x00ac, 8 },
+{ 0x0038, 22 },
+{ 0x000e, 36 },
+{ 0x0001, 52 },
+{ 0x000d, 68 },
+{ 0x0003, 84 },
+{ 0x0007, 100 },
+{ 0x000f, 116 },
+{ 0x0019, 133 },
+{ 0x0005, 149 },
+{ 0x001c, 165 },
+{ 0x0002, 181 },
+{ 0x0004, 198 },
+{ 0x0030, 214 },
+{ 0x000b, 230 },
+{ 0x002b, 246 },
+{ 0x0015, 262 },
+{ 0x0035, 278 },
+{ 0x0072, 295 },
+{ 0x0018, 311 },
+{ 0x0008, 327 },
+{ 0x0074, 343 },
+{ 0x0060, 359 },
+{ 0x0010, 375 },
+{ 0x000a, 391 },
+{ 0x006a, 407 },
+{ 0x0064, 423 },
+{ 0x0012, 439 },
+{ 0x000c, 455 },
+{ 0x0040, 472 },
+{ 0x00c0, 488 },
+{ 0x0058, 504 },
+{ 0x00d8, 520 },
+{ 0x0048, 536 },
+{ 0x00c8, 552 },
+{ 0x0028, 568 },
+{ 0x00a8, 584 },
+{ 0x0068, 600 },
+{ 0x00e8, 616 },
+{ 0x0014, 632 },
+{ 0x0094, 648 },
+{ 0x0054, 664 },
+{ 0x00d4, 680 },
+{ 0x0034, 696 },
+{ 0x00b4, 712 },
+{ 0x0020, 728 },
+{ 0x00a0, 744 },
+{ 0x0050, 760 },
+{ 0x00d0, 776 },
+{ 0x004a, 792 },
+{ 0x00ca, 808 },
+{ 0x002a, 824 },
+{ 0x00aa, 840 },
+{ 0x0024, 856 },
+{ 0x00a4, 872 },
+{ 0x001a, 888 },
+{ 0x009a, 904 },
+{ 0x005a, 920 },
+{ 0x00da, 936 },
+{ 0x0052, 952 },
+{ 0x00d2, 968 },
+{ 0x004c, 984 },
+{ 0x00cc, 1000 },
+{ 0x002c, 1016 },
+{ 0, 0 }
+};
+
+static struct proto TermB[] = {
+{ 0x03b0, 10 },
+{ 0x0002, 19 },
+{ 0x0003, 34 },
+{ 0x0001, 50 },
+{ 0x0006, 67 },
+{ 0x000c, 84 },
+{ 0x0004, 100 },
+{ 0x0018, 117 },
+{ 0x0028, 134 },
+{ 0x0008, 150 },
+{ 0x0010, 167 },
+{ 0x0050, 183 },
+{ 0x0070, 199 },
+{ 0x0020, 216 },
+{ 0x00e0, 232 },
+{ 0x0030, 249 },
+{ 0x03a0, 266 },
+{ 0x0060, 282 },
+{ 0x0040, 298 },
+{ 0x0730, 315 },
+{ 0x00b0, 331 },
+{ 0x01b0, 347 },
+{ 0x0760, 363 },
+{ 0x00a0, 379 },
+{ 0x0740, 395 },
+{ 0x00c0, 411 },
+{ 0x0530, 428 },
+{ 0x0d30, 444 },
+{ 0x0330, 460 },
+{ 0x0b30, 476 },
+{ 0x0160, 492 },
+{ 0x0960, 508 },
+{ 0x0560, 524 },
+{ 0x0d60, 540 },
+{ 0x04b0, 556 },
+{ 0x0cb0, 572 },
+{ 0x02b0, 588 },
+{ 0x0ab0, 604 },
+{ 0x06b0, 620 },
+{ 0x0eb0, 636 },
+{ 0x0360, 652 },
+{ 0x0b60, 668 },
+{ 0x05b0, 684 },
+{ 0x0db0, 700 },
+{ 0x02a0, 716 },
+{ 0x0aa0, 732 },
+{ 0x06a0, 748 },
+{ 0x0ea0, 764 },
+{ 0x0260, 780 },
+{ 0x0a60, 796 },
+{ 0x04a0, 812 },
+{ 0x0ca0, 828 },
+{ 0x0240, 844 },
+{ 0x0ec0, 860 },
+{ 0x01c0, 876 },
+{ 0x0e40, 892 },
+{ 0x0140, 908 },
+{ 0x01a0, 924 },
+{ 0x09a0, 940 },
+{ 0x0d40, 956 },
+{ 0x0340, 972 },
+{ 0x05a0, 988 },
+{ 0x0660, 1004 },
+{ 0x0e60, 1020 },
+{ 0, 0 }
+};
+
+static struct proto ExtH[] = {
+{ 0x0100, 9 },
+{ 0, 0 }
+};
+
+static struct proto EOLH[] = {
+{ 0x0000, 11 },
+{ 0, 0 }
+};
+
+static void
+FillTable(struct tabent *T, int Size, struct proto *P, int State)
+{
+    int limit = 1 << Size;
+
+    while (P->val) {
+	int width = P->val & 15;
+	int param = P->val >> 4;
+	int incr = 1 << width;
+	int code;
+	for (code = P->code; code < limit; code += incr) {
+	    struct tabent *E = T+code;
+	    E->State = State;
+	    E->Width = width;
+	    E->Param = param;
+	}
+	P++;
+    }
+}
+
+/* initialise the huffman code tables */
+void
+faxinit(void)
+{
+    FillTable(MainTable, 7, Pass, S_Pass);
+    FillTable(MainTable, 7, Horiz, S_Horiz);
+    FillTable(MainTable, 7, V0, S_V0);
+    FillTable(MainTable, 7, VR, S_VR);
+    FillTable(MainTable, 7, VL, S_VL);
+    FillTable(MainTable, 7, ExtV, S_Ext);
+    FillTable(MainTable, 7, EOLV, S_EOL);
+    FillTable(WhiteTable, 12, MakeUpW, S_MakeUpW);
+    FillTable(WhiteTable, 12, MakeUp, S_MakeUp);
+    FillTable(WhiteTable, 12, TermW, S_TermW);
+    FillTable(WhiteTable, 12, ExtH, S_Ext);
+    FillTable(WhiteTable, 12, EOLH, S_EOL);
+    FillTable(BlackTable, 13, MakeUpB, S_MakeUpB);
+    FillTable(BlackTable, 13, MakeUp, S_MakeUp);
+    FillTable(BlackTable, 13, TermB, S_TermB);
+    FillTable(BlackTable, 13, ExtH, S_Ext);
+    FillTable(BlackTable, 13, EOLH, S_EOL);
+}
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/faxinput.c mgetty-current/frontends/X11/viewfax-2.5/faxinput.c
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/faxinput.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/faxinput.c	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,447 @@
+/* Fax file input processing
+   Copyright (C) 1990, 1995  Frank D. Cringle.
+
+This file is part of viewfax - g3/g4 fax processing software.
+     
+viewfax is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2 of the License, or (at your
+option) any later version.
+     
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+     
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <fcntl.h>
+#include "faxexpand.h"
+
+#define	FAXMAGIC	"\000PC Research, Inc\000\000\000\000\000\000"
+
+/* Enter an argument in the linked list of pages */
+struct pagenode *
+notefile(char *name)
+{
+    struct pagenode *new = (struct pagenode *) xmalloc(sizeof *new);
+
+    *new = defaultpage;
+    if (firstpage == NULL)
+	firstpage = new;
+    new->prev = lastpage;
+    new->next = NULL;
+    if (lastpage != NULL)
+	lastpage->next = new;
+    lastpage = new;
+    new->pathname = name;
+    if ((new->name = strrchr(new->pathname, '/')) != NULL)
+	new->name++;
+    else
+	new->name = new->pathname;
+
+    if (new->width == 0)
+	new->width = 1728;
+    if (new->vres < 0)
+	new->vres = !(new->name[0] == 'f' && new->name[1] == 'n');
+    new->extra = NULL;
+    return new;
+}
+
+static t32bits
+get4(unsigned char *p, int endian)
+{
+    return endian ? (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3] :
+	p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
+}
+
+static int
+get2(unsigned char *p, int endian)
+{
+    return endian ? (p[0]<<8)|p[1] : p[0]|(p[1]<<8);
+}
+
+/* generate pagenodes for the images in a tiff file */
+int
+notetiff(char *name)
+{
+    FILE *tf;
+    unsigned char header[8];
+    static const char littleTIFF[4] = "\x49\x49\x2a\x00";
+    static const char bigTIFF[4] = "\x4d\x4d\x00\x2a";
+    int endian;
+    t32bits IFDoff;
+    struct pagenode *pn = NULL;
+
+    if ((tf = fopen(name, "r")) == NULL) {
+	perror(name);
+	return 0;
+    }
+
+    if (fread(header, 8, 1, tf) == 0) {
+    nottiff:
+	fclose(tf);
+	(void) notefile(name);
+	return 0;
+    }
+    if (memcmp(header, &littleTIFF, 4) == 0)
+	endian = 0;
+    else if (memcmp(header, &bigTIFF, 4) == 0)
+	endian = 1;
+    else
+	goto nottiff;
+    IFDoff = get4(header+4, endian);
+    if (IFDoff & 1)
+	goto nottiff;
+    do {			/* for each page */
+	unsigned char buf[8];
+	unsigned char *dir = NULL;
+	unsigned char *dp;
+	int ndirent;
+	pixnum iwidth = defaultpage.width ? defaultpage.width : 1728;
+	pixnum iheight = defaultpage.height ? defaultpage.height : 2339;
+	int inverse = defaultpage.inverse;
+	int lsbfirst = 0;
+	int t4opt = 0, comp = 0;
+	int orient = defaultpage.orient;
+	double yres = defaultpage.vres ? 196.0 : 98.0;
+	struct strip *strips = NULL;
+	unsigned long rowsperstrip = 0;
+	int nstrips = 1;
+
+	if (fseek(tf, IFDoff, SEEK_SET) < 0) {
+	realbad:
+	    fprintf(stderr, "%s:%s: invalid tiff file\n", ProgName, name);
+	bad:
+	    if (strips)
+		free(strips);
+	    if (dir)
+		free(dir);
+	    fclose(tf);
+	    return 1;
+	}
+	if (fread(buf, 2, 1, tf) == 0)
+	    goto realbad;
+	ndirent = get2(buf, endian);
+	dir = (unsigned char *) xmalloc(12*ndirent+4);
+	if (fread(dir, 12*ndirent+4, 1, tf) == 0)
+	    goto realbad;
+	for (dp = dir; ndirent; ndirent--, dp += 12) {
+	    /* for each directory entry */
+	    int tag, ftype;
+	    t32bits count, value = 0;
+	    tag = get2(dp, endian);
+	    ftype = get2(dp+2, endian);
+	    count = get4(dp+4, endian);
+	    switch(ftype) {	/* value is offset to list if count*size > 4 */
+	    case 3:		/* short */
+		value = get2(dp+8, endian);
+		break;
+	    case 4:		/* long */
+		value = get4(dp+8, endian);
+		break;
+	    case 5:		/* offset to rational */
+		value = get4(dp+8, endian);
+		break;
+	    }
+	    switch(tag) {
+	    case 256:		/* ImageWidth */
+		iwidth = value;
+		break;
+	    case 257:		/* ImageLength */
+		iheight = value;
+		break;
+	    case 259:		/* Compression */
+		comp = value;
+		break;
+	    case 262:		/* PhotometricInterpretation */
+		inverse ^= (value == 1);
+		break;
+	    case 266:		/* FillOrder */
+		lsbfirst = (value == 2);
+		break;
+	    case 273:		/* StripOffsets */
+		nstrips = count;
+		strips = (struct strip *) xmalloc(count * sizeof *strips);
+		if (count == 1 || (count == 2 && ftype == 3)) {
+		    strips[0].offset = value;
+		    if (count == 2)
+			strips[1].offset = get2(dp+10, endian);
+		    break;
+		}
+		if (fseek(tf, value, SEEK_SET) < 0)
+		    goto realbad;
+		for (count = 0; count < nstrips; count++) {
+		    if (fread(buf, (ftype == 3) ? 2 : 4, 1, tf) == 0)
+			goto realbad;
+		    strips[count].offset = (ftype == 3) ?
+			get2(buf, endian) : get4(buf, endian);
+		}
+		break;
+	    case 274:		/* Orientation */
+		switch(value) {
+		default:	/* row0 at top,    col0 at left   */
+		    orient = 0;
+		    break;
+		case 2:		/* row0 at top,    col0 at right  */
+		    orient = TURN_M;
+		    break;
+		case 3:		/* row0 at bottom, col0 at right  */
+		    orient = TURN_U;
+		    break;
+		case 4:		/* row0 at bottom, col0 at left   */
+		    orient = TURN_U|TURN_M;
+		    break;
+		case 5:		/* row0 at left,   col0 at top    */
+		    orient = TURN_M|TURN_L;
+		    break;
+		case 6:		/* row0 at right,  col0 at top    */
+		    orient = TURN_U|TURN_L;
+		    break;
+		case 7:		/* row0 at right,  col0 at bottom */
+		    orient = TURN_U|TURN_M|TURN_L;
+		    break;
+		case 8:		/* row0 at left,   col0 at bottom */
+		    orient = TURN_L;
+		    break;
+		}
+		break;
+	    case 278:		/* RowsPerStrip */
+		rowsperstrip = value;	
+		break;
+	    case 279:		/* StripByteCounts */
+		if (count != nstrips) {
+		    fprintf(stderr, "%s:%s StripsPerImage tag273=%d, tag279=%ld\n",
+			    ProgName, name, nstrips, count);
+		    goto realbad;
+		}
+		if (count == 1 || (count == 2 && ftype == 3)) {
+		    strips[0].size = value;
+		    if (count == 2)
+			strips[1].size = get2(dp+10, endian);
+		    break;
+		}
+		if (fseek(tf, value, SEEK_SET) < 0)
+		    goto realbad;
+		for (count = 0; count < nstrips; count++) {
+		    if (fread(buf, (ftype == 3) ? 2 : 4, 1, tf) == 0)
+			goto realbad;
+		    strips[count].size = (ftype == 3) ?
+			get2(buf, endian) : get4(buf, endian);
+		}
+		break;
+	    case 283:		/* YResolution */
+		if (fseek(tf, value, SEEK_SET) < 0 ||
+		    fread(buf, 8, 1, tf) == 0)
+		    goto realbad;
+		yres = get4(buf, endian) / get4(buf+4, endian);
+		break;
+	    case 292:		/* T4Options */
+		t4opt = value;
+		break;
+	    case 293:		/* T6Options */
+		/* later */
+		break;
+	    case 296:		/* ResolutionUnit */
+		if (value == 3)
+		    yres *= 2.54;
+		break;
+	    }
+	}
+	IFDoff = get4(dp, endian);
+	free(dir);
+	dir = NULL;
+	if (comp < 2 || comp > 4) {
+	    fprintf(stderr, "%s:%s: this version only handles fax files\n",
+		ProgName, name);
+	    goto bad;
+	}
+	pn = notefile(name);
+	pn->nstrips = nstrips;
+	pn->rowsperstrip = nstrips > 1 ? rowsperstrip : iheight;
+	pn->strips = strips;
+	pn->width = iwidth;
+	pn->height = iheight;
+	pn->inverse = inverse;
+	pn->lsbfirst = lsbfirst;
+	pn->orient = orient;
+	pn->vres = (yres > 150); /* arbitrary threshold for fine resolution */
+	if (comp == 2)
+	    pn->expander = MHexpand;
+	else if (comp == 3)
+	    pn->expander = (t4opt & 1) ? g32expand : g31expand;
+	else
+	    pn->expander = g4expand;
+    } while (IFDoff);
+    fclose(tf);
+    return 1;
+}
+
+/* report error and remove bad file from the list */
+static void
+badfile(struct pagenode *pn)
+{
+    struct pagenode *p;
+
+    if (errno)
+	perror(pn->pathname);
+    if (pn == firstpage) {
+	if (pn->next == NULL)
+	    exit(1);
+	firstpage = thispage = firstpage->next;
+	firstpage->prev = NULL;
+    }
+    else
+	for (p = firstpage; p; p = p->next)
+	    if (p->next == pn) {
+		thispage = p;
+		p->next = pn->next;
+		if (pn->next)
+		    pn->next->prev = p;
+		break;
+	    }
+    if (pn) free(pn);
+}
+
+/* rearrange input bits into t16bits lsb-first chunks */
+static void
+normalize(struct pagenode *pn, int revbits, int swapbytes, size_t length)
+{
+    t32bits *p = (t32bits *) pn->data;
+
+    switch ((revbits<<1)|swapbytes) {
+    case 0:
+	break;
+    case 1:
+	for ( ; length; length -= 4) {
+	    t32bits t = *p;
+	    *p++ = ((t & 0xff00ff00) >> 8) | ((t & 0x00ff00ff) << 8);
+	}
+	break;
+    case 2:
+	for ( ; length; length -= 4) {
+	    t32bits t = *p;
+	    t = ((t & 0xf0f0f0f0) >> 4) | ((t & 0x0f0f0f0f) << 4);
+	    t = ((t & 0xcccccccc) >> 2) | ((t & 0x33333333) << 2);
+	    *p++ = ((t & 0xaaaaaaaa) >> 1) | ((t & 0x55555555) << 1);
+	}
+	break;
+    case 3:
+	for ( ; length; length -= 4) {
+	    t32bits t = *p;
+	    t = ((t & 0xff00ff00) >> 8) | ((t & 0x00ff00ff) << 8);
+	    t = ((t & 0xf0f0f0f0) >> 4) | ((t & 0x0f0f0f0f) << 4);
+	    t = ((t & 0xcccccccc) >> 2) | ((t & 0x33333333) << 2);
+	    *p++ = ((t & 0xaaaaaaaa) >> 1) | ((t & 0x55555555) << 1);
+	}
+    }
+}
+
+
+/* get compressed data into memory */
+unsigned char *
+getstrip(struct pagenode *pn, int strip)
+{
+    int fd, n;
+    size_t offset, roundup;
+    struct stat sbuf;
+    unsigned char *Data;
+    union { t16bits s; unsigned char b[2]; } so;
+#define ShortOrder	so.b[1]
+
+    so.s = 1;
+    if ((fd = open(pn->pathname, O_RDONLY, 0)) < 0) {
+	badfile(pn);
+	return NULL;
+    }
+
+    if (pn->strips == NULL) {
+	if (fstat(fd, &sbuf) != 0) {
+	    close(fd);
+	    badfile(pn);
+	    return NULL;
+	}
+	offset = 0;
+	pn->length = sbuf.st_size;
+    }
+    else if (strip < pn->nstrips) {
+	offset = pn->strips[strip].offset;
+	pn->length = pn->strips[strip].size;
+    }
+    else {
+	fprintf(stderr, "%s:%s: trying to expand too many strips\n",
+		ProgName, pn->pathname);
+	close(fd);
+	badfile(pn);
+	return NULL;
+    }
+    if (!pn->length) {
+	fprintf(stderr, "%s:%s: trying to expand a null strip\n",
+		ProgName, pn->pathname);
+	close(fd);  
+	badfile(pn);
+	return NULL;
+    }
+
+    /* round size to full boundary plus t32bits */
+    roundup = (pn->length + 7) & ~3;
+
+    Data = (unsigned char *) xmalloc(roundup);
+    /* clear the last 2 t32bits, to force the expander to terminate
+       even if the file ends in the middle of a fax line  */
+    *((t32bits *) Data + roundup/4 - 2) = 0;
+    *((t32bits *) Data + roundup/4 - 1) = 0;
+
+    /* we expect to get it in one gulp... */
+    if (lseek(fd, offset, SEEK_SET) < 0 ||
+	(n = read(fd, Data, pn->length)) != pn->length) {
+	fprintf(stderr, "%s: expected %d bytes, got %d\n",
+		pn->pathname, pn->length, n);
+	badfile(pn);
+	free(Data);
+	close(fd);
+	return NULL;
+    }
+    close(fd);
+
+    pn->data = (t16bits *) Data;
+    if (pn->strips == NULL && memcmp(Data, FAXMAGIC, sizeof(FAXMAGIC)) == 0) {
+	/* handle ghostscript / PC Research fax file */
+	if (Data[24] != 1 || Data[25] != 0)
+	    printf("%s: only first page of multipage file %s will be shown\n",
+		   ProgName, pn->pathname);
+	pn->length -= 64;
+	pn->vres = Data[29];
+	pn->data += 32;
+	roundup -= 64;
+    }
+
+    normalize(pn, !pn->lsbfirst, ShortOrder, roundup);
+    if (pn->height == 0)
+	pn->height = G3count(pn, pn->expander == g32expand);
+    if (pn->height == 0) {
+	fprintf(stderr, "%s: no fax found in file %s\n", ProgName,
+		pn->pathname);
+	errno = 0;
+	badfile(pn);
+	free(Data);
+	return NULL;
+    }
+    if (pn->strips == NULL)
+	pn->rowsperstrip = pn->height;
+    if (verbose && strip == 0)
+	printf("%s:\n\twidth = %lu\n\theight = %lu\n\tresolution = %s\n",
+	       pn->name, (unsigned long) pn->width, (unsigned long) pn->height,
+	       pn->vres ? "fine" : "normal");
+    return Data;
+}
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/g3hack.c mgetty-current/frontends/X11/viewfax-2.5/g3hack.c
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/g3hack.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/g3hack.c	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,185 @@
+/* g3hack.c - hack identical lines off the end of a fax
+ *
+ * This program is in the public domain.  If it does not work or
+ * causes you any sort of grief, blame the public, not me.
+ *
+ * fdc@cliwe.ping.de, 1995-06-24
+ *
+ * v2 1995-06-25 - fixed some boundary problems, added named input
+ * v3 1995-06-28 - changed write-error detection
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define VERSION "0.3"
+
+#ifdef BSD
+#define strrchr rindex
+#endif
+
+extern int getopt();
+extern char *optarg;
+extern int optind, opterr;
+
+static char *progname;
+static char *banner = "\n%s version " VERSION "\n\n";
+static char *usage = "\
+usage: %s <-n count> <-h size> -o <outputfile> {inputfile}\n\n\
+Copy a g3-(1d)-fax file from stdin to stdout and delete any\n\
+   more than `count' identical trailing lines (default 10).\n\
+Optionally skip `size'-byte header.\n\
+Optionally named outputfile (else stdout).\n";
+
+#define nxtbit()	((imask>>=1) ? ((ibits&imask)!=0) :		\
+			 ((ibits=getchar()) == EOF) ? -1 :		\
+			 (((imask=0x80)&ibits)!=0))
+#define putbit(b)							\
+    do {								\
+	if (b)								\
+	    obits |= omask;						\
+	if ((omask >>= 1) == 0) {					\
+	    this->line[this->length>>3] = obits;			\
+	    omask = 0x80;						\
+	    obits = 0;							\
+	}								\
+	this->length++;							\
+	if (this->length >= BUFSIZ<<3) {				\
+	    fprintf(stderr, "%s: unreasonably long line\n", progname);	\
+	    exit(1);							\
+	}								\
+    } while (0)
+
+static void
+copy(int nlines)
+{
+    int ibits = 0, imask = 0;	/* input bits and mask */
+    int obits = 0;		/* output bits */
+    int omask = 0x80;		/* output mask */
+    int zeros = 0;		/* number of consecutive zero bits */
+    int thisempty = 1;		/* empty line (so far) */
+    int empties = 0;		/* number of consecutive EOLs */
+    int identcount = 0;		/* number of consecutive identical lines */
+    struct {
+	char line[BUFSIZ];
+	int length;
+    } lines[2], *prev, *this, *temp;
+
+    this = &lines[0];
+    prev = &lines[1];
+    this->length = prev->length = 0;
+    while (1) {
+	int bit = nxtbit();
+	if (bit == -1)
+	    break;		/* end of file */
+	putbit(bit);
+	if (bit == 0) {
+	    zeros++;
+	    continue;
+	}
+	if (zeros < 11) {	/* not eol and not empty */
+	    zeros = 0;
+	    thisempty = 0;
+	    /* Get rid of any accumulated empties.  Should only happen
+	       for the eol at the beginning of the first line (we
+	       switch from the |eol data| to the |data eol|
+	       viewpoint). */
+	    for ( ; empties; empties--)
+		if (fwrite("\0\1", 1, 2, stdout) != 2)
+		    break;
+	    continue;
+	}
+	/* at end of line */
+	zeros = 0;
+	omask = 0x80;
+	obits = 0;
+	if (thisempty) {
+	    empties++;
+	    if (empties >= 5)
+		break;		/* 6 eols in a row */
+	    this->length = 0;
+	    continue;
+	}
+	thisempty = 1;
+	/* at end of non-empty line */
+	this->length = (this->length+7)&~7;
+	this->line[(this->length-1)>>3] = 1; /* byte-align the eol */
+	if (this->length == prev->length &&
+	    memcmp(this->line, prev->line, this->length>>3) == 0) {
+	    identcount++;
+	    this->length = 0;
+	    continue;
+	}
+	/* at end of non-matching line */
+	for ( ; identcount; identcount--)
+	    if (fwrite(prev->line, 1, prev->length>>3, stdout) !=
+		prev->length>>3)
+		break;
+	temp = prev;
+	prev = this;
+	this = temp;
+	identcount = 1;
+	this->length = 0;
+    }
+    if (identcount > nlines)
+	identcount = nlines;
+    for ( ; !ferror(stdout) && identcount; identcount--)
+	    fwrite(prev->line, 1, prev->length>>3, stdout);
+    if (!ferror(stdout) && !thisempty)
+	    fwrite(this->line, 1, this->length>>3, stdout);
+    for ( ; !ferror(stdout) && empties; empties--)
+	fwrite("\0\1", 1, 2, stdout);
+    if (ferror(stdout)) {
+	fprintf(stderr, "%s: write error\n", progname);
+	exit(1);
+    }
+}
+
+int
+main(int argc, char **argv)
+{
+    int c, err = 0;
+    int header = 0;
+    int nlines = 10;
+
+    if ((progname = strrchr(argv[0], '/')) == NULL)
+	progname = argv[0];
+    else
+	progname++;
+    opterr = 0;
+    while ((c = getopt(argc, argv, "h:n:o:v")) != EOF)
+	switch (c) {
+	case 'h':
+	    header = atoi(optarg);
+	    break;
+	case 'n':
+	    nlines = atoi(optarg);
+	    break;
+	case 'o':
+	    if (freopen(optarg, "w", stdout) == NULL) {
+		perror(optarg);
+		exit(1);
+	    }
+	    break;
+	case 'v':
+	    fprintf(stderr, banner, progname);
+	    exit(0);	    
+	case '?':
+	    err++;
+	}
+    if (err || optind < argc-1) {
+	fprintf(stderr, banner, progname);
+	fprintf(stderr, usage, progname);
+	exit(1);
+    }
+    if (optind < argc && freopen(argv[optind], "r", stdin) == NULL) {
+	perror(argv[optind]);
+	exit(1);
+    }
+    while (header--)
+	putchar(getchar());
+    copy(nlines);
+    exit(0);
+}
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/viewfax.c mgetty-current/frontends/X11/viewfax-2.5/viewfax.c
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/viewfax.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/viewfax.c	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,1404 @@
+/* Program to view fax files on an X-window screen
+   Copyright (C) 1990, 1995  Frank D. Cringle.
+
+This file is part of viewfax - g3/g4 fax processing software.
+     
+viewfax is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2 of the License, or (at your
+option) any later version.
+     
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+     
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/time.h>
+/* NewImage() needs to fiddle with the Display structure */
+#define XLIB_ILLEGAL_ACCESS
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xatom.h>
+#include <X11/keysym.h>
+#include <X11/keysymdef.h>
+#include <X11/cursorfont.h>
+#include "faxexpand.h"
+
+#define VERSION "2.5"
+
+/* If moving the image around with the middle mouse button is jerky or
+   slow, try defining USE_MOTIONHINT.  It may help (it may also make
+   things worse - it depends on the server implementation) */
+#undef USE_MOTIONHINT
+
+struct pagenode *firstpage, *lastpage, *thispage, *helppage;
+struct pagenode defaultpage;
+
+/* access the 'extra' field in a pagenode */
+#define Pimage(p)	((XImage *)(p)->extra)
+
+/* getopt declarations */
+extern int getopt();
+extern char *optarg;
+extern int optind, opterr, optopt;
+
+/* forward declarations */
+static XImage *FlipImage(XImage *xi);
+static XImage *MirrorImage(XImage *xi);
+static XImage *NewImage(int w, int h, char *data, int bit_order);
+static XImage *RotImage(XImage *Image);
+static XImage *ZoomImage(XImage *Big);
+static void FreeImage(XImage *Image);
+static int GetImage(struct pagenode *pn);
+static void SetupDisplay(int argc, char **argv);
+static void ShowLoop(void);
+static int release(int quit);
+static char *suffix(char *opt, const char *str);
+
+/* X variables */
+static char *DispName = NULL;
+static char *Geometry = NULL;
+static Display *Disp;
+static Window Root;
+static Window Win;
+static int Default_Screen;
+static GC PaintGC;
+static Cursor WorkCursor;
+static Cursor ReadyCursor;
+static Cursor MoveCursor;
+static Cursor LRCursor;
+static Cursor UDCursor;
+
+char *ProgName;
+int verbose = 0;
+
+static int abell = 0;			/* audio bell */
+static int vbell = 1;			/* visual bell */
+static int zfactor = 0;			/* zoom factor */
+
+static size_t Memused = 0;		/* image memory usage */
+static size_t Memlimit = 4*1024*1024;	/* try not to exceed */
+
+#undef min
+#undef max
+#define min(a,b)	((a)<(b)?(a):(b))
+#define max(a,b)	((a)>(b)?(a):(b))
+
+#ifndef EXIT_FAILURE
+#define EXIT_FAILURE 1
+#endif
+
+/* OK, OK - this is a dreadful hack.  But it adequately distinguishes
+   modern big- and little- endian hosts.  We only need this to set the
+   byte order in XImage structures */
+static union { t32bits i; unsigned char b[4]; } bo;
+#define ByteOrder	bo.b[3]
+
+static char Banner[] =
+"\nviewfax version " VERSION ", Copyright (C) 1990, 1995 Frank D. Cringle.\n"
+"viewfax comes with ABSOLUTELY NO WARRANTY; for details see the\n"
+"file \"COPYING\" in the distribution directory.\n\n";
+
+static char Usage[] =
+"usage: %s <flags> file ...\n"
+"\t-f\tfine resolution (default unless filename begins with 'fn')\n"
+"\t-n\tnormal resolution\n"
+"\t-h\theight (number of fax lines)\n"
+"\t-w\twidth (dots per fax line)\n"
+"\t-l\tturn image 90 degrees (landscape mode)\n"
+"\t-u\tturn image upside down\n"
+"\t-i\tinvert (black/white)\n"
+"\t-d\t(or -display) use an alternate X display\n"
+"\t-g\t(or -geometry) size and position of window\n"
+"\t-b\tuse audio (-ba) or visual (-bv) warning bell\n"
+"\t-m\tmemory usage limit\n"
+"\t-r\tfax data is packed ls-bit first in input bytes\n"
+"\t-v\tverbose messages\n"
+"\t-z\tinitial zoom factor\n"
+"\t-2\traw files are g3-2d\n"
+"\t-4\traw files are g4\n";
+
+int
+main(int argc, char **argv)
+{
+    int c;
+    int err = 0;
+
+    bo.i = 1;
+    defaultpage.vres = -1;
+    defaultpage.expander = g31expand;
+    opterr = 0;			/* suppress getopt error message */
+
+    if ((ProgName = strrchr(argv[0], '/')) == NULL)
+	ProgName = argv[0];
+    else
+	ProgName++;
+    while ((c = getopt(argc, argv, "b:d:fg:h:ilm:nruvw:z:24")) != -1)
+	switch(c) {
+	case 'b':
+	    abell = vbell = 0;
+	    while (*optarg) {
+		abell |= (*optarg == 'a');
+		vbell |= (*optarg == 'v');
+		optarg++;
+	    }
+	    break;
+	case 'd':		/* display name */
+	    if (*(DispName = suffix(optarg, "isplay")) == 0)
+		DispName = argv[optind++];
+	    break;
+	case 'f':		/* fine resolution */
+	    defaultpage.vres = 1;
+	    break;
+	case 'g':		/* geometry */
+	    if (*(Geometry = suffix(optarg, "eometry")) == 0)
+		Geometry = argv[optind++];
+	    break;
+	case 'h':		/* user thinks this is the height */
+	    defaultpage.height = atoi(optarg);
+	    break;
+	case 'i':		/* invert black/white */
+	    defaultpage.inverse = 1;
+	    break;
+	case 'l':		/* landscape */
+	    defaultpage.orient |= TURN_L;
+	    break;
+	case 'm':		/* memory usage limit */
+	    Memlimit = atoi(optarg);
+	    switch(optarg[strlen(optarg)-1]) {
+	    case 'M':
+	    case 'm':
+		Memlimit *= 1024;
+	    case 'K':
+	    case 'k':
+		Memlimit *= 1024;
+	    }
+	    break;
+	case 'n':		/* normal resolution */
+	    defaultpage.vres = 0;
+	    break;
+	case 'r':		/* reverse input bits */
+	    defaultpage.lsbfirst = 1;
+	    break;
+	case 'u':		/* upside down */
+	    defaultpage.orient |= TURN_U;
+	    break;
+	case 'v':		/* verbose messages */
+	    verbose = 1;
+	    break;
+	case 'w':		/* user thinks this is the width */
+	    defaultpage.width = atoi(optarg);
+	    break;
+	case 'z':		/* zoom factor */
+	    c = atoi(optarg);
+	    if (c <= 0)
+		c = 1;
+	    for (zfactor = 1; c > 1; c >>= 1)
+		zfactor <<= 1;	/* constrain to a power of 2 */
+	    break;
+	case '2':
+	    defaultpage.expander = g32expand;
+	    break;
+	case '4':
+	    defaultpage.expander = g4expand;
+	    break;
+	default:
+	    err++;
+	    break;
+	}
+
+    if (defaultpage.expander == g4expand && defaultpage.height == 0) {
+	fputs("-h value is required to interpret raw g4 faxes\n", stderr);
+	err++;
+    }
+
+    if (verbose)
+	fputs(Banner, stdout);
+
+    firstpage = lastpage = thispage = helppage = NULL;
+    for (; optind < argc; optind++)
+	(void) notetiff(argv[optind]);
+
+    if (err || firstpage == NULL) {
+	if (!verbose)
+	    fprintf(stderr, Banner);
+	fprintf(stderr, Usage, ProgName);
+	exit(EXIT_FAILURE);
+    }
+
+    if ((Disp = XOpenDisplay(DispName)) == NULL) {
+	fprintf(stderr, "%s: can't open display %s\n", ProgName,
+		DispName ? DispName : XDisplayName((char *) NULL));
+	exit(EXIT_FAILURE);
+    }
+    Default_Screen = XDefaultScreen(Disp);
+    faxinit();
+    thispage = firstpage;
+    while (!GetImage(firstpage))
+	/* try again */;
+    SetupDisplay(argc, argv);
+    ShowLoop();
+    return 0;
+}
+
+/* return mismatching suffix of option name */
+static char *
+suffix(char *opt, const char *prefix)
+{
+    while (*opt && *opt == *prefix) {
+	opt++; prefix++;
+    }
+    return opt;
+}
+
+/* Change orientation of all following pages */
+static void
+TurnFollowing(int How, struct pagenode *pn)
+{
+    while (pn) {
+	if (Pimage(pn)) {
+	    FreeImage(Pimage(pn));
+	    pn->extra = NULL;
+	}
+	pn->orient ^= How;
+	pn = pn->next;
+    }
+}
+
+static void
+drawline(pixnum *run, int LineNum, struct pagenode *pn)
+{
+    t32bits *p, *p1;		/* p - current line, p1 - low-res duplicate */
+    pixnum *r;			/* pointer to run-lengths */
+    t32bits pix;		/* current pixel value */
+    t32bits acc;		/* pixel accumulator */
+    int nacc;			/* number of valid bits in acc */
+    int tot;			/* total pixels in line */
+    int n;
+
+    LineNum += pn->stripnum * pn->rowsperstrip;
+    if (LineNum >= pn->height) {
+	if (verbose && LineNum == pn->height)
+	    fputs("Height exceeded\n", stderr);
+	return;
+    }
+    p = (t32bits *) (Pimage(pn)->data + LineNum*(2-pn->vres)*Pimage(pn)->bytes_per_line);
+    p1 = pn->vres ? NULL : p + Pimage(pn)->bytes_per_line/sizeof(*p);
+    r = run;
+    acc = 0;
+    nacc = 0;
+    pix = pn->inverse ? ~0 : 0;
+    tot = 0;
+    while (tot < pn->width) {
+	n = *r++;
+	tot += n;
+	/* Watch out for buffer overruns, e.g. when n == 65535.  */
+	if (tot > pn->width)
+	    break;
+	if (pix)
+	    acc |= (~(t32bits)0 >> nacc);
+	else if (nacc)
+	    acc &= (~(t32bits)0 << (32 - nacc));
+	else
+	    acc = 0;
+	if (nacc + n < 32) {
+	    nacc += n;
+	    pix = ~pix;
+	    continue;
+	}
+	*p++ = acc;
+	if (p1)
+	    *p1++ = acc;
+	n -= 32 - nacc;
+	while (n >= 32) {
+	    n -= 32;
+	    *p++ = pix;
+	    if (p1)
+		*p1++ = pix;
+	}
+	acc = pix;
+	nacc = n;
+	pix = ~pix;
+    }
+    if (nacc) {
+	*p++ = acc;
+	if (p1)
+	    *p1++ = acc;
+    }
+}
+
+static int
+GetPartImage(struct pagenode *pn, int n)
+{
+    unsigned char *Data = getstrip(pn, n);
+
+    if (Data == NULL)
+	return 0;
+    pn->stripnum = n;
+    (*pn->expander)(pn, drawline);
+    free(Data);
+    return 1;
+}
+
+static int
+GetImage(struct pagenode *pn)
+{
+    int i;
+    XImage *tp;
+
+    if (pn->strips == NULL) {
+	/* raw file; maybe we don't have the height yet */
+	unsigned char *Data = getstrip(pn, 0);
+	if (Data == NULL)
+	    return 0;
+	pn->extra = NewImage(pn->width, pn->vres ?
+			     pn->height : 2*pn->height, NULL, 1);
+	(*pn->expander)(pn, drawline);
+    }
+    else {
+	/* multi-strip tiff */
+	pn->extra = NewImage(pn->width, pn->vres ?
+			     pn->height : 2*pn->height, NULL, 1);
+	tp = Pimage(pn);
+	pn->stripnum = 0;
+	for (i = 0; i < pn->nstrips; i++) {
+	    if (verbose) printf("\texpanding strip #%d\n", i);
+	    if (GetPartImage(pn, i) == 0) {
+		/* pn may no longer exist */
+		FreeImage(tp);
+		return 0;
+	    }
+	}
+    }
+    if (pn->orient & TURN_U)
+	pn->extra = FlipImage(Pimage(pn));
+    if (pn->orient & TURN_M)
+	pn->extra = MirrorImage(Pimage(pn));
+    if (pn->orient & TURN_L)
+	pn->extra = RotImage(Pimage(pn));
+    if (verbose) printf("\tmemused = %d\n", Memused);
+    return 1;
+}
+
+#ifndef _HAVE_USLEEP
+static int
+usleep(unsigned usecs)
+{
+    struct timeval t;
+
+    t.tv_sec = usecs/10000000;
+    t.tv_usec = usecs%1000000;
+    (void) select(1, NULL, NULL, NULL, &t);
+    return 0;
+}
+#endif
+
+#ifndef REAL_ROOT
+/* Function Name: GetVRoot
+ * Description: Gets the root window, even if it's a virtual root
+ * Arguments: the display and the screen
+ * Returns: the root window for the client
+ *
+ * by David Elliott, taken from the x-faq
+ */
+static Window
+GetVRoot(Display *dpy, int scr)
+{
+    Window rootReturn, parentReturn, *children;
+    unsigned int numChildren;
+    Window root = RootWindow(dpy, scr);
+    Atom __SWM_VROOT = None;
+    int i;
+ 
+    __SWM_VROOT = XInternAtom(dpy, "__SWM_VROOT", False);
+    XQueryTree(dpy, root, &rootReturn, &parentReturn, &children,
+	       &numChildren);
+    for (i = 0; i < numChildren; i++) {
+        Atom actual_type;
+        int actual_format;
+        unsigned long nitems, bytesafter;
+        Window *newRoot = NULL;
+ 
+        if (XGetWindowProperty(dpy, children[i], __SWM_VROOT, 0, 1,
+			       False, XA_WINDOW, &actual_type,
+			       &actual_format, &nitems, &bytesafter,
+			       (unsigned char **) &newRoot)
+					== Success && newRoot) {
+	    if (children) XFree(children);
+	    return *newRoot;
+	}
+    }
+    return root;
+}
+#endif
+
+static Atom wm_delete_window;
+
+/* Area the user would like us to use, derived from -geometry */
+static struct {
+    int v, x, y;
+    unsigned int w, h;
+} Area = {0, 0, 0};
+
+/* nominal border width */
+#define BW 4
+
+/* Figure out the zoom factor needed to fit the fax on the available display */
+static void
+SetupDisplay(int argc, char **argv)
+{
+    int Width, Height, i;
+    XSetWindowAttributes Attr;
+    XSizeHints size_hints;
+    Atom wm_protocols;
+    int faxh = Pimage(thispage)->height;
+    int faxw = Pimage(thispage)->width;
+
+#ifdef REAL_ROOT
+    Root = RootWindow(Disp, Default_Screen);
+    Width = Area.w = DisplayWidth(Disp, Default_Screen);
+    Height = Area.h = DisplayHeight(Disp, Default_Screen);
+#elif TVTWM_BIGWINDOW
+    XWindowAttributes RootWA;
+    Root = GetVRoot(Disp, Default_Screen);
+    XGetWindowAttributes(Disp, Root, &RootWA);
+    Width = Area.w = RootWA.width;
+    Height = Area.h = RootWA.height;
+#else
+    Root = GetVRoot(Disp, Default_Screen);
+    Width = Area.w = DisplayWidth(Disp, Default_Screen);
+    Height = Area.h = DisplayHeight(Disp, Default_Screen);
+#endif
+    if (Geometry)
+	Area.v = XParseGeometry(Geometry, &Area.x, &Area.y,
+				&Area.w, &Area.h);
+    Area.w = max(64, Area.w);
+    Area.h = max(64, Area.h);
+
+    if (zfactor == 0)
+	for (zfactor = 1;
+	     faxw / zfactor > Area.w ||
+	     faxh / zfactor > Area.h;
+	     zfactor *= 2)
+	    ;
+    Attr.background_pixel = WhitePixel(Disp, Default_Screen);
+    Attr.border_pixel = BlackPixel(Disp, Default_Screen);
+
+    for (size_hints.width = faxw, i = 1; i < zfactor; i *= 2)
+	size_hints.width = (size_hints.width + 1) /2;
+    for (size_hints.height = faxh, i = 1; i < zfactor; i *= 2)
+	size_hints.height = (size_hints.height + 1) /2;
+
+    switch (Area.v & (XValue|XNegative)) {
+    case XValue:
+	size_hints.x = Area.x + BW;
+	break;
+    case XValue|XNegative:
+	Area.x = Width + Area.x - 2*BW - Area.w;
+	size_hints.x = Area.x + Area.w - size_hints.width;
+	break;
+    default:
+	size_hints.x = Area.x + (Area.w - size_hints.width)/2;
+    }
+    switch (Area.v & (YValue|YNegative)) {
+    case YValue:
+	size_hints.y = Area.y + BW;
+	break;
+    case YValue|YNegative:
+	Area.y = Height + Area.y - 2*BW - Area.h;
+	size_hints.y = Area.y + Area.h - size_hints.height;
+	break;
+    default:
+	size_hints.y = Area.y + (Area.h - size_hints.height)/2;
+    }
+
+    size_hints.max_width = size_hints.width;
+    size_hints.max_height = size_hints.height;
+    size_hints.flags = PSize|PMaxSize;
+    if (Area.v & (XValue|YValue)) size_hints.flags |= USPosition;
+    if (Area.v & (HeightValue|WidthValue)) size_hints.flags |= USSize;
+	
+    Win = XCreateWindow(Disp, Root, size_hints.x, size_hints.y,
+			size_hints.width, size_hints.height,
+			BW, 0, InputOutput, CopyFromParent,
+			CWBackPixel|CWBorderPixel, &Attr);
+#ifdef PWinGravity
+{
+    XWMHints wm_hints;
+    XClassHint class_hints;
+    XTextProperty windowName, iconName;
+
+    if (!XStringListToTextProperty(&thispage->name, 1, &windowName) ||
+	!XStringListToTextProperty(&ProgName, 1, &iconName)) {
+	fprintf(stderr, "%s: can't make window/icon name\n", ProgName);
+	exit(EXIT_FAILURE);
+    }
+    wm_hints.initial_state = NormalState;
+    wm_hints.input = True;
+    wm_hints.flags = StateHint|InputHint;
+    class_hints.res_name = ProgName;
+    class_hints.res_class = "Faxview";
+    XSetWMProperties(Disp, Win, &windowName, &iconName, argv, argc,
+		     &size_hints, &wm_hints, &class_hints);
+}
+#else
+    XSetStandardProperties(Disp, Win, thispage->name, ProgName,
+			   None, argv, argc, &size_hints);
+#endif
+
+    PaintGC = XCreateGC(Disp, Win, 0L, (XGCValues *) NULL);
+    XSetForeground(Disp, PaintGC, BlackPixel(Disp, Default_Screen));
+    XSetBackground(Disp, PaintGC, WhitePixel(Disp, Default_Screen));
+    XSetFunction(Disp, PaintGC, GXcopy);
+    WorkCursor = XCreateFontCursor(Disp, XC_watch);
+    ReadyCursor = XCreateFontCursor(Disp, XC_plus);
+    MoveCursor = XCreateFontCursor(Disp, XC_fleur);
+    LRCursor = XCreateFontCursor(Disp, XC_sb_h_double_arrow);
+    UDCursor = XCreateFontCursor(Disp, XC_sb_v_double_arrow);
+    XSelectInput(Disp, Win, Button2MotionMask | ButtonPressMask |
+		 ButtonReleaseMask | ExposureMask | KeyPressMask |
+		 SubstructureNotifyMask | OwnerGrabButtonMask |
+#ifdef USE_MOTIONHINT
+		 PointerMotionHintMask |
+#endif
+		 StructureNotifyMask);
+    wm_protocols = XInternAtom(Disp, "WM_PROTOCOLS", False);
+    wm_delete_window = XInternAtom(Disp, "WM_DELETE_WINDOW", False);
+    XChangeProperty(Disp, Win, wm_protocols, XA_ATOM, 32,
+                    PropModeAppend, (unsigned char * ) &wm_delete_window, 1);
+    XMapRaised(Disp, Win);
+}
+
+#define MAXZOOM	10
+
+/* After requesting a window size change, we throw away key and button presses
+   until we get the notification that the size has changed.  If for some
+   reason the notification does not come, we resume processing as normal after
+   PATIENCE milliseconds */
+#define PATIENCE 10000
+
+static void
+ShowLoop(void)
+{
+    XEvent Event;
+
+    /* centre of image within window */
+    int x = 0, ox = 0, offx = 0, nx;	/* x, old x, offset x, new x */
+    int y = 0, oy = 0, offy = 0, ny;	/* y, old y, offset y, new y */
+
+    int oz, Resize = 0, Refresh = 0;	/* old zoom, window size changed,
+					   needs updating */
+    int PaneWidth, PaneHeight;		/* current size of our window */
+    int AbsX, AbsY;		/* absolute position of centre of window */
+    int FrameWidth, FrameHeight, FrameX, FrameY;/* size/offset of decoration */
+    int Oversize = 0;		/* window manager insists on oversize window */
+    int Reparented = 0;
+    int i;
+    XImage *Image, *Images[MAXZOOM];
+    struct pagenode *viewpage = NULL;	/* page viewed when help requested */
+    XSizeHints size_hints;
+    Time Lasttime = 0;		/* time of last accepted key/button press */
+    int ExpectConfNotify = 1;
+
+    XDefineCursor(Disp, Win, WorkCursor);
+    XFlush(Disp);
+    for (oz = 0; oz < MAXZOOM; oz++)
+	Images[oz] = NULL;
+    Image = Images[0] = Pimage(thispage);
+    for (oz = 0; oz < MAXZOOM && zfactor > (1 << oz); oz++)
+	Images[oz+1] = ZoomImage(Images[oz]);
+    Image = Images[oz];
+
+    /* some reasonable values,
+       just in case we do not get a configurenotify first */
+    AbsX = Area.w/2;
+    AbsY = Area.h/2;
+    FrameWidth = FrameHeight = FrameX = FrameY = 0;
+    PaneWidth = Image->width;
+    PaneHeight = Image->height;
+
+    XDefineCursor(Disp, Win, ReadyCursor);
+
+    for (;;) {
+	XNextEvent(Disp, &Event);
+	do {
+	    switch(Event.type) {
+	    case MappingNotify:
+		XRefreshKeyboardMapping((XMappingEvent *)(&Event));
+		break;
+	    case ClientMessage:
+		if (Event.xclient.data.l[0] == wm_delete_window) {
+		    XCloseDisplay(Disp);
+		    exit(EXIT_FAILURE);
+		}
+		break;
+	    case Expose:
+	    {
+		XExposeEvent *p = (XExposeEvent *) &Event;
+		XPutImage(Disp, Win, PaintGC, Image,
+			  p->x + x - PaneWidth/2,
+			  p->y + y - PaneHeight/2,
+			  p->x, p->y,
+			  p->width, p->height);
+	    }
+		break;
+	    case ReparentNotify:
+	    {
+		Window Myroot = Root;
+		Window Parent = Event.xreparent.parent;
+		Window Frame = Parent;	/* I should be so lucky! */
+		Window *Mykids;
+		unsigned int Nkids;
+		XWindowAttributes MyWA, FrameWA;
+
+		if (Parent != Root)
+		    do {
+			Frame = Parent;
+			while (!XQueryTree(Disp, Frame, &Myroot,
+					   &Parent, &Mykids, &Nkids))
+			    release(1);
+			if (Mykids) XFree(Mykids);
+		    } while (Parent != Root);
+		while (!XGetWindowAttributes(Disp, Win, &MyWA))
+		    release(1);
+		while (!XGetWindowAttributes(Disp, Frame, &FrameWA))
+		    release(1);
+		/* if area is partly constrained, stay where the WM put you */
+		if ((Area.v & (XValue|WidthValue)) == WidthValue) {
+		    Area.v |= XValue;
+		    Area.x = FrameWA.x;
+		}
+		if ((Area.v & (YValue|HeightValue)) == HeightValue) {
+		    Area.v |= YValue;
+		    Area.y = FrameWA.y;
+		}
+		XTranslateCoordinates(Disp, Win, Frame, 0, 0,
+				      &FrameX, &FrameY, &Parent);
+		FrameWidth = FrameWA.width - MyWA.width;
+		FrameHeight = FrameWA.height - MyWA.height;
+		Reparented = ExpectConfNotify = 1;
+	    }
+		break;
+	    case ConfigureNotify:
+	    {
+		XConfigureEvent *p = (XConfigureEvent *) &Event;
+		int NewX = AbsX;
+		int NewY = AbsY;
+#ifdef REAL_ROOT
+		if (p->send_event || !Reparented) {
+		    NewX = p->x + p->width/2;
+		    NewY = p->y + p->height/2;
+		}
+#else
+		/* support tvtwm */
+		if (!Reparented) {
+		    NewX = p->x + p->border_width + p->width/2;
+		    NewY = p->y + p->border_width + p->height/2;
+		}
+		else if (p->send_event) {
+		    /* the event info is viewport-relative, we need absolute */
+		    Window w;
+		    XTranslateCoordinates(Disp, Win, Root, 0, 0,
+					  &NewX, &NewY, &w);
+		    NewX += p->width/2;
+		    NewY += p->height/2;
+		}
+#endif
+		if (!ExpectConfNotify) {
+		    /* user intervention */
+		    if (PaneWidth != p->width)
+			Area.w = p->width + FrameWidth;
+		    if (PaneHeight != p->height)
+			Area.h = p->height + FrameHeight;
+		    if (NewX != AbsX || NewY != AbsY) {
+			Area.x = NewX - p->width/2 - FrameX;
+			Area.y = NewY - p->height/2 - FrameY;
+		    }
+		}
+		AbsX = NewX; AbsY = NewY;
+		PaneWidth = p->width;
+		PaneHeight = p->height;
+		Oversize = PaneWidth > Image->width ||
+		    PaneHeight > Image->height;
+		ExpectConfNotify = 0;
+	    }
+		break;
+	    case KeyPress:
+		if (ExpectConfNotify &&
+		    (Event.xkey.time < (Lasttime + PATIENCE)))
+		    break;
+		Lasttime = Event.xkey.time;
+		ExpectConfNotify = 0;
+		switch(XKeycodeToKeysym(Disp, Event.xkey.keycode, 0)) {
+		case XK_Help:
+		case XK_h:
+		    if (helppage == NULL) {
+			if (!notetiff(HELPFILE))
+			    goto nopage;
+			else {
+			    helppage = lastpage;
+			    lastpage = helppage->prev;
+			    lastpage->next = helppage->prev = NULL;
+			}
+		    }
+		    viewpage = thispage;
+		    thispage = helppage;
+		    goto newpage;
+		    break;
+		case XK_m:
+		    XDefineCursor(Disp, Win, WorkCursor);
+		    XFlush(Disp);
+		    thispage->extra = Images[0] = MirrorImage(Images[0]);
+		    thispage->orient ^= TURN_M;
+		    for (i = 1; Images[i]; i++) {
+			FreeImage(Images[i]);
+			Images[i] = ZoomImage(Images[i-1]);
+		    }
+		    Image = Images[oz];
+		    if (Event.xkey.state & ShiftMask)
+			TurnFollowing(TURN_M, thispage->next);
+		    XPutImage(Disp, Win, PaintGC, Image,
+			      x-PaneWidth/2, y-PaneHeight/2,
+			      0, 0, PaneWidth, PaneHeight);
+		    XDefineCursor(Disp, Win, ReadyCursor);
+		    break;
+		case XK_z:
+		    if (Event.xkey.state & ShiftMask)
+			goto Zoomout;
+		    else
+			goto Zoomin;
+		case XK_Up:
+		    y -= PaneHeight / 2;
+		    break;
+		case XK_Down:
+		    y += PaneHeight / 2;
+		    break;
+		case XK_Left:
+		    x -= PaneWidth / 2;
+		    break;
+		case XK_Right:
+		    x += PaneWidth / 2;
+		    break;
+		case XK_Home:
+		case XK_R7:		/* sun4 keyboard */
+		    if (Event.xkey.state & ShiftMask) {
+			thispage = firstpage;
+			goto newpage;
+		    }
+		    x = 0;
+		    y = 0;
+		    break;
+		case XK_End:
+		case XK_R13:
+		    if (Event.xkey.state & ShiftMask) {
+			thispage = lastpage;
+			goto newpage;
+		    }
+		    x = Image->width;
+		    y = Image->height;
+		    break;
+		case XK_l:
+		    XDefineCursor(Disp, Win, WorkCursor);
+		    XFlush(Disp);
+		    thispage->extra = Image = RotImage(Images[0]);
+		    thispage->orient ^= TURN_L;
+		    for (i = 1; Images[i]; i++) {
+			FreeImage(Images[i]);
+			Images[i] = NULL;
+		    }
+		    Images[0] = Image;
+		    for (i = 1; i <= oz; i++)
+			Images[i] = ZoomImage(Images[i-1]);
+		    Image = Images[oz];
+		    if (Event.xkey.state & ShiftMask)
+			TurnFollowing(TURN_L, thispage->next);
+		{ int t = x; x = y; y = t; }
+		    Refresh = Resize = 1;
+		    XDefineCursor(Disp, Win, ReadyCursor);
+		    break;
+		case XK_p:
+		case XK_minus:
+		case XK_Prior:
+		case XK_R9:
+		case XK_BackSpace:
+		    if (thispage->prev == NULL)
+			goto nopage;
+		    thispage = thispage->prev;
+		    goto newpage;
+		case XK_n:
+		case XK_plus:
+		case XK_space:
+		case XK_Next:
+		case XK_R15:
+		    if (thispage->next == NULL) {
+		    nopage:
+			if (abell) {
+			    putchar('\a');
+			    fflush(stdout);
+			}
+			if (vbell) {
+			    XAddPixel(Image, 1);
+			    XPutImage(Disp, Win, PaintGC, Image,
+				      x-PaneWidth/2, y-PaneHeight/2,
+				      0, 0, PaneWidth, PaneHeight);
+			    XSync(Disp, 0);
+			    (void) usleep(200000);
+			    XAddPixel(Image, 1);
+			    XPutImage(Disp, Win, PaintGC, Image,
+				      x-PaneWidth/2, y-PaneHeight/2,
+				      0, 0, PaneWidth, PaneHeight);
+			}
+			break;
+		    }
+		    thispage = thispage->next;
+		newpage:
+		    XDefineCursor(Disp, Win, WorkCursor);
+		    XFlush(Disp);
+		    /* if old image was not resized by the user, fit new one */
+		    Resize = ((PaneWidth == Image->width ||
+			       PaneWidth == Area.w - FrameWidth) &&
+			      (PaneHeight == Image->height ||
+			       PaneHeight == Area.h - FrameHeight));
+		    for (i = 1; Images[i]; i++) {
+			FreeImage(Images[i]);
+			Images[i] = NULL;
+		    }
+		    if (Pimage(thispage) == NULL)
+			while (!GetImage(thispage))
+			    /* try again */;
+		    Images[0] = Pimage(thispage);
+		    XStoreName(Disp, Win, thispage->name);
+		    for (i = 1; i <= oz; i++)
+			Images[i] = ZoomImage(Images[i-1]);
+		    Image = Images[oz];
+		    Refresh = 1;
+		    XDefineCursor(Disp, Win, ReadyCursor);
+		    break;
+		case XK_u:
+		    XDefineCursor(Disp, Win, WorkCursor);
+		    XFlush(Disp);
+		    thispage->extra = Images[0] = FlipImage(Images[0]);
+		    thispage->orient ^= TURN_U;
+		    for (i = 1; Images[i]; i++) {
+			FreeImage(Images[i]);
+			Images[i] = ZoomImage(Images[i-1]);
+		    }
+		    Image = Images[oz];
+		    if (Event.xkey.state & ShiftMask)
+			TurnFollowing(TURN_U, thispage->next);
+		    XPutImage(Disp, Win, PaintGC, Image,
+			      x-PaneWidth/2, y-PaneHeight/2,
+			      0, 0, PaneWidth, PaneHeight);
+		    XDefineCursor(Disp, Win, ReadyCursor);
+		    break;
+		case XK_q:
+		    if (viewpage) {
+			thispage = viewpage;
+			viewpage = NULL;
+			goto newpage;
+		    }
+		    XCloseDisplay(Disp);
+#ifdef xmalloc
+		    malloc_shutdown();
+#endif
+		    exit((Event.xkey.state & ShiftMask) ? EXIT_FAILURE : 0);
+		}
+		break;
+	    case ButtonPress:
+		if (ExpectConfNotify &&
+		    (Event.xbutton.time < (Lasttime + PATIENCE)))
+		    break;
+		Lasttime = Event.xbutton.time;
+		ExpectConfNotify = 0;
+		switch (Event.xbutton.button) {
+		case Button1:
+		Zoomout:
+		    if (oz > 0) {
+			Image = Images[--oz];
+			zfactor >>= 1;
+			x *= 2;
+			y *= 2;
+			Resize = Refresh = 1;
+		    }
+		    break;
+		case Button2:
+		    switch (((Image->width > PaneWidth)<<1) |
+			    (Image->height > PaneHeight)) {
+		    case 0:
+			break;
+		    case 1:
+			XDefineCursor(Disp, Win, UDCursor);
+			break;
+		    case 2:
+			XDefineCursor(Disp, Win, LRCursor);
+			break;
+		    case 3:
+			XDefineCursor(Disp, Win, MoveCursor);
+		    }
+		    XFlush(Disp);
+		    offx = Event.xbutton.x;
+		    offy = Event.xbutton.y;
+		    break;
+		case Button3:
+		Zoomin:
+		    if (oz < MAXZOOM && Image->width >= 64 && zfactor < 32) {
+			Image = Images[++oz];
+			zfactor <<= 1;
+			x /= 2;
+			y /= 2;
+			Resize = Refresh = 1;
+		    }
+		    break;
+		}
+		if (Image == NULL) {
+		    for (i = oz; i && (Images[i] == NULL); i--)
+			;
+		    for (; i != oz; i++)
+			Images[i+1] = ZoomImage(Images[i]);
+		    Image = Images[oz];
+		}
+		break;
+	    case MotionNotify:
+#ifdef USE_MOTIONHINT
+	    {
+		unsigned int Junk;
+		Window JunkW;
+		XQueryPointer(Disp, Event.xmotion.window, &JunkW, &JunkW,
+			      &Junk, &Junk, &nx, &ny, &Junk);
+	    }
+#else
+		do {
+		    nx = Event.xmotion.x;
+		    ny = Event.xmotion.y;
+		} while (XCheckTypedEvent(Disp, MotionNotify, &Event));
+#endif
+		x += offx - nx;
+		y += offy - ny;
+		offx = nx;
+		offy = ny;
+		break;
+	    case ButtonRelease:
+		if (Event.xbutton.button == Button2) {
+		    XDefineCursor(Disp, Win, ReadyCursor);
+		    XFlush(Disp);
+		}
+	    }
+	} while (XCheckWindowEvent(Disp, Win,
+				   KeyPressMask|ButtonPressMask, &Event));
+
+	/* if someone thinks we should resize the window and it is not
+	   already the right size, or if the window is too big and we
+	   have not already tried to make it smaller ... */
+	if ((Resize && !(Image->width == PaneWidth &&
+			 Image->height == PaneHeight)) ||
+	    (!Oversize && (Image->width < PaneWidth ||
+			   Image->height < PaneHeight))) {
+	    int PosX = AbsX - PaneWidth/2 - FrameX;
+	    int PosY = AbsY - PaneHeight/2 - FrameY;
+	    XWindowChanges New;
+	    int ChangeMask = 0;
+
+	    New.width = min(Area.w - FrameWidth, Image->width);
+	    New.height = min(Area.h - FrameHeight, Image->height);
+	    /* expect an expose if size must change */
+	    Refresh &= (New.width == PaneWidth && New.height == PaneHeight);
+	    New.x = max(Area.x, AbsX-New.width/2-FrameX);
+	    New.x = min(New.x, Area.w-(New.width+FrameWidth)+Area.x);
+	    New.y = max(Area.y, AbsY-New.height/2-FrameY);
+	    New.y = min(New.y, Area.h-(New.height+FrameHeight)+Area.y);
+
+	    /* mwm takes max_size very seriously! */
+	    size_hints.flags = 0;
+	    XSetNormalHints(Disp, Win, &size_hints);
+
+	    size_hints.flags = PMaxSize;
+	    size_hints.x = PosX;
+	    size_hints.y = PosY;
+	    size_hints.width = PaneWidth;
+	    size_hints.height = PaneHeight;
+	    /* only move a coordinate if the ideal new value is different
+	       from the current value and either the other dimension has
+	       changed or the current value is out of area */
+	    if (PosX != New.x &&
+		(New.height != PaneHeight || PosX < Area.x || 
+		 PosX > Area.w-New.width-FrameWidth-Area.x)) {
+		ChangeMask |= CWX;
+		size_hints.x = New.x;
+		size_hints.flags |= PPosition;
+	    }
+	    if (PosY != New.y &&
+		(New.width != PaneWidth || PosY < Area.y ||
+		 PosY > Area.h-New.height-FrameHeight-Area.y)) {
+		ChangeMask |= CWY;
+		size_hints.y = New.y;
+		size_hints.flags |= PPosition;
+	    }
+	    if (New.width != PaneWidth) {
+		ChangeMask |= CWWidth;
+		size_hints.width = New.width;
+		size_hints.flags |= PSize;
+		ExpectConfNotify = Reparented;
+	    }
+	    if (New.height != PaneHeight) {
+		ChangeMask |= CWHeight;
+		size_hints.height = New.height;
+		size_hints.flags |= PSize;
+		ExpectConfNotify = Reparented;
+	    }
+	    New.border_width = 1;	/* ICCCM 4.1.5 */
+	    ChangeMask |= CWBorderWidth;
+	    XConfigureWindow(Disp, Win, ChangeMask, &New);
+	    size_hints.max_width = Image->width;
+	    size_hints.max_height = Image->height;
+	    XSetNormalHints(Disp, Win, &size_hints);
+	}
+	x = max(x, PaneWidth/2);
+	x = min(x, Image->width-PaneWidth/2);
+	y = max(y, PaneHeight/2);
+	y = min(y, Image->height-PaneHeight/2);
+	if (x != ox || y != oy || Refresh)
+	    XPutImage(Disp, Win, PaintGC, Image,
+		      x-PaneWidth/2, y-PaneHeight/2,
+		      0, 0, PaneWidth, PaneHeight);
+	ox = x;
+	oy = y;
+	Resize = Refresh = 0;
+    }
+}
+
+/* run this region through perl to generate the zoom table:
+$lim = 1;
+@c = ("0", "1", "1", "2");
+print "static unsigned char Z[] = {\n";
+for ($i = 0; $i < 16; $i++) {
+    for ($j = 0; $j < 16; $j++) {
+	$b1 = ($c[$j&3]+$c[$i&3]) > $lim;
+	$b2 = ($c[($j>>2)&3]+$c[($i>>2)&3]) > $lim;
+	printf " %X,", ($b2 << 1) | $b1;
+    }
+    print "\n";
+}
+print "};\n";
+*/
+static unsigned char Z[] = {
+ 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 2, 2, 2, 3,
+ 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 2, 3, 3, 3,
+ 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 2, 3, 3, 3,
+ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3,
+ 0, 0, 0, 1, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3,
+ 0, 1, 1, 1, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
+ 0, 1, 1, 1, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
+ 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+ 0, 0, 0, 1, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3,
+ 0, 1, 1, 1, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
+ 0, 1, 1, 1, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
+ 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+ 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3, 2, 2, 2, 3,
+ 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
+ 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
+ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+};
+
+#define nib(n,w)	(((w)>>((n)<<2))&15)
+#define zak(a,b)	Z[(a<<4)|b]
+
+/* 2 -> 1 zoom, 4 pixels -> 1 pixel
+   if #pixels <= $lim (see above), new pixel is white,
+   else black.
+*/
+static XImage *
+ZoomImage(XImage *Big)
+{
+    XImage *Small;
+    int w, h;
+    int i, j;
+
+    XDefineCursor(Disp, Win, WorkCursor);
+    XFlush(Disp);
+    w = (Big->width+1) / 2;
+    h = (Big->height+1) / 2;
+    Small = NewImage(w, h, NULL, Big->bitmap_bit_order);
+    Small->xoffset = (Big->xoffset+1)/2;
+    for (i = 0; i < Big->height; i += 2) {
+	t32bits *pb0 = (t32bits *) (Big->data + i * Big->bytes_per_line);
+	t32bits *pb1 = pb0 + ((i == Big->height-1) ? 0 : Big->bytes_per_line/4);
+	t32bits *ps = (t32bits *) (Small->data + i * Small->bytes_per_line / 2);
+	for (j = 0; j < Big->bytes_per_line/8; j++) {
+	    t32bits r1, r2;
+	    t32bits t0 = *pb0++;
+	    t32bits t1 = *pb1++;
+	    r1 = (zak(nib(7,t0),nib(7,t1))<<14) |
+		 (zak(nib(6,t0),nib(6,t1))<<12) |
+		 (zak(nib(5,t0),nib(5,t1))<<10) |
+		 (zak(nib(4,t0),nib(4,t1))<<8) |
+		 (zak(nib(3,t0),nib(3,t1))<<6) |
+		 (zak(nib(2,t0),nib(2,t1))<<4) |
+		 (zak(nib(1,t0),nib(1,t1))<<2) |
+		 (zak(nib(0,t0),nib(0,t1)));
+	    t0 = *pb0++;
+	    t1 = *pb1++;
+	    r2 = (zak(nib(7,t0),nib(7,t1))<<14) |
+		 (zak(nib(6,t0),nib(6,t1))<<12) |
+		 (zak(nib(5,t0),nib(5,t1))<<10) |
+		 (zak(nib(4,t0),nib(4,t1))<<8) |
+		 (zak(nib(3,t0),nib(3,t1))<<6) |
+		 (zak(nib(2,t0),nib(2,t1))<<4) |
+		 (zak(nib(1,t0),nib(1,t1))<<2) |
+		 (zak(nib(0,t0),nib(0,t1)));
+	    *ps++ = (Big->bitmap_bit_order) ?
+		(r1<<16)|r2 : (r2<<16)|r1;
+	}
+	for ( ; j < Small->bytes_per_line/4; j++) {
+	    t32bits r1;
+	    t32bits t0 = *pb0++;
+	    t32bits t1 = *pb1++;
+	    r1 = (zak(nib(7,t0),nib(7,t1))<<14) |
+		 (zak(nib(6,t0),nib(6,t1))<<12) |
+		 (zak(nib(5,t0),nib(5,t1))<<10) |
+		 (zak(nib(4,t0),nib(4,t1))<<8) |
+		 (zak(nib(3,t0),nib(3,t1))<<6) |
+		 (zak(nib(2,t0),nib(2,t1))<<4) |
+		 (zak(nib(1,t0),nib(1,t1))<<2) |
+		 (zak(nib(0,t0),nib(0,t1)));
+	    *ps++ = (Big->bitmap_bit_order) ?
+		(r1<<16) : r1;
+	}
+    }
+    XDefineCursor(Disp, Win, ReadyCursor);
+    return Small;
+}
+
+static XImage *
+FlipImage(XImage *Image)
+{
+    XImage *New = NewImage(Image->width, Image->height,
+			   Image->data, !Image->bitmap_bit_order);
+    t32bits *p1 = (t32bits *) Image->data;
+    t32bits *p2 = (t32bits *) (Image->data + Image->height *
+			     Image->bytes_per_line - 4);
+
+    /* the first shall be last ... */
+    while (p1 < p2) {
+	t32bits t = *p1;
+	*p1++ = *p2;
+	*p2-- = t;
+    }
+
+    /* let Xlib twiddle the bits */
+    New->xoffset = 32 - (Image->width & 31) - Image->xoffset;
+    New->xoffset &= 31;
+
+    Image->data = NULL;
+    FreeImage(Image);
+    return New;
+}
+
+static XImage *
+MirrorImage(XImage *Image)
+{
+    int i;
+    XImage *New = NewImage(Image->width, Image->height,
+			   Image->data, !Image->bitmap_bit_order);
+
+    /* reverse order of 32-bit words in each line */
+    for (i = 0; i < Image->height; i++) {
+	t32bits *p1 = (t32bits *) (Image->data + Image->bytes_per_line * i);
+	t32bits *p2 = p1 + Image->bytes_per_line/4 - 1;
+	while (p1 < p2) {
+	    t32bits t = *p1;
+	    *p1++ = *p2;
+	    *p2-- = t;
+	}
+    }
+
+    /* let Xlib twiddle the bits */
+    New->xoffset = 32 - (Image->width & 31) - Image->xoffset;
+    New->xoffset &= 31;
+
+    Image->data = NULL;
+    FreeImage(Image);
+    return New;
+}
+
+static XImage *
+RotImage(XImage *Image)
+{
+    XImage *New;
+    int w = Image->height;
+    int h = Image->width;
+    int i, j, k, shift;
+    int order = Image->bitmap_bit_order;
+    int offs = h+Image->xoffset-1;
+
+    New = NewImage(w, h, NULL, 1);
+
+    k = (32 - Image->xoffset) & 3;
+    for (i = h - 1; i && k; i--, k--) {
+	t32bits *sp = (t32bits *) Image->data + (offs-i)/32;
+	t32bits *dp = (t32bits *) (New->data+i*New->bytes_per_line);
+	t32bits d0;
+	shift = (offs-i)&31;
+	if (order) shift = 31-shift;
+	for (j = 0; j < w; j++) {
+	    t32bits t = *sp;
+	    sp += Image->bytes_per_line/4;
+	    d0 |= ((t >> shift) & 1);
+	    if ((j & 31) == 31)
+		*dp++ = d0;
+	    d0 <<= 1;;
+	}
+	if (j & 31)
+	    *dp++ = d0<<(31-j);
+    }
+    for ( ; i >= 3; i-=4) {
+	t32bits *sp = (t32bits *) Image->data + (offs-i)/32;
+	t32bits *dp0 = (t32bits *) (New->data+i*New->bytes_per_line);
+	t32bits *dp1 = dp0 - New->bytes_per_line/4;
+	t32bits *dp2 = dp1 - New->bytes_per_line/4;
+	t32bits *dp3 = dp2 - New->bytes_per_line/4;
+	t32bits d0, d1, d2, d3;
+	shift = (offs-i)&31;
+	if (order) shift = 28-shift;
+	for (j = 0; j < w; j++) {
+	    t32bits t = *sp >> shift;
+	    sp += Image->bytes_per_line/4;
+	    d0 |= t & 1; t >>= 1;
+	    d1 |= t & 1; t >>= 1;
+	    d2 |= t & 1; t >>= 1;
+	    d3 |= t & 1; t >>= 1;
+	    if ((j & 31) == 31) {
+		if (order) {
+		    *dp0++ = d3;
+		    *dp1++ = d2;
+		    *dp2++ = d1;
+		    *dp3++ = d0;
+		}
+		else {
+		    *dp0++ = d0;
+		    *dp1++ = d1;
+		    *dp2++ = d2;
+		    *dp3++ = d3;
+		}
+	    }
+	    d0 <<= 1; d1 <<= 1; d2 <<= 1; d3 <<= 1;
+	}
+	if (j & 31) {
+	    if (order) {
+		*dp0++ = d3<<(31-j);
+		*dp1++ = d2<<(31-j);
+		*dp2++ = d1<<(31-j);
+		*dp3++ = d0<<(31-j);
+	    }
+	    else {
+		*dp0++ = d0<<(31-j);
+		*dp1++ = d1<<(31-j);
+		*dp2++ = d2<<(31-j);
+		*dp3++ = d3<<(31-j);
+	    }
+	}
+    }
+    for (; i >= 0; i--) {
+	t32bits *sp = (t32bits *) Image->data + (offs-i)/32;
+	t32bits *dp = (t32bits *) (New->data+i*New->bytes_per_line);
+	t32bits d0;
+	shift = (offs-i)&31;
+	if (order) shift = 31-shift;
+	for (j = 0; j < w; j++) {
+	    t32bits t = *sp;
+	    sp += Image->bytes_per_line/4;
+	    d0 |= ((t >> shift) & 1);
+	    if ((j & 31) == 31)
+		*dp++ = d0;
+	    d0 <<= 1;;
+	}
+	if (j & 31)
+	    *dp++ = d0<<(31-j);
+    }
+    FreeImage(Image);
+    return New;
+}
+
+/* release some non-essential memory or abort */
+#define Try(n)								\
+    if (n && n != thispage && n->extra) {				\
+	FreeImage(n->extra);						\
+	n->extra = NULL;						\
+	return 1;							\
+    }
+
+static int
+release(int quit)
+{
+    struct pagenode *pn;
+
+    if (thispage) {
+	/* first consider "uninteresting" pages */
+	for (pn = firstpage->next; pn; pn = pn->next)
+	    if (pn->extra && pn != thispage && pn != thispage->prev &&
+		pn != thispage->next && pn != lastpage) {
+		FreeImage(Pimage(pn));
+		pn->extra = NULL;
+		return 1;
+	    }
+	Try(lastpage);
+	Try(firstpage);
+	Try(thispage->prev);
+	Try(thispage->next);
+    }
+    if (!quit)
+	return 0;
+    fprintf(stderr, "%s(release): insufficient memory\n", ProgName);
+    exit(EXIT_FAILURE);
+}
+
+static XImage *
+NewImage(int w, int h, char *data, int bit_order)
+{
+    XImage *new;
+    /* This idea is taken from xwud/xpr.  Use a fake display with the
+       desired bit/byte order to get the image routines initialised
+       correctly */
+    Display fake;
+
+    fake = *Disp;
+    if (data == NULL)
+	data = xmalloc(((w + 31) & ~31) * h / 8);
+    fake.byte_order = ByteOrder;
+    fake.bitmap_unit = 32;
+    fake.bitmap_bit_order = bit_order;
+
+    while ((new = XCreateImage(&fake, DefaultVisual(Disp, Default_Screen),
+			       1, XYBitmap, 0, data, w, h, 32, 0)) == NULL)
+	(void) release(1);
+    Memused += new->bytes_per_line * new->height;
+    return new;
+}
+
+static void
+FreeImage(XImage *Image)
+{
+    if (Image->data)
+	Memused -= Image->bytes_per_line * Image->height;
+    XDestroyImage(Image);
+}
+
+#ifndef xmalloc
+char *
+xmalloc(unsigned int size)
+{
+    char *p;
+
+    while (Memused + size > Memlimit && release(0))
+	;
+    while ((p = malloc(size)) == NULL)
+	(void) release(1);
+    return p;
+}
+#endif
diff -urP mgetty-1.1.22/frontends/X11/viewfax-2.5/viewfax.man mgetty-current/frontends/X11/viewfax-2.5/viewfax.man
--- mgetty-1.1.22/frontends/X11/viewfax-2.5/viewfax.man	Thu Jan  1 01:00:00 1970
+++ mgetty-current/frontends/X11/viewfax-2.5/viewfax.man	Thu Nov 16 11:41:41 2000
@@ -0,0 +1,265 @@
+.TH viewfax 1 "14 October 1995" "Frank\'s Hacks" "Local commands"
+.UC 4
+.SH NAME
+viewfax \- display fax files in an X11 window
+.SH SYNOPSIS
+.PU
+.ll +8
+.B viewfax
+.RB [ -fnluirv24 ]
+.RB [ -h\fIheight ]
+.RB [ -w\fIwidth ]
+.RB [ -z\fIzoom ]
+.RB [ -d\fIdisplay ]
+.RB [ -g\fIwxh+x+y ]
+.RB [ -b\fIbell ]
+.RB [ -m\fImemory ]
+.I filename...
+.ll -8
+.br
+.SH DESCRIPTION
+.B viewfax
+displays one or more fax files in an X11 window.  The input
+files may be either raw, single-page faxes received by a fax modem
+with a program such as
+.B mgetty(1),
+or tiff files such as those used by
+.B hylafax.
+The first (or only) page of "PC-Research"-style (DigiFAX) files
+produced by the
+.B ghostscript
+dfaxhigh or dfaxlow drivers can also be displayed.
+
+Input files using any common fax encoding such as group 3 (1 and 2
+dimensional) and group 4 can be displayed.
+
+The fax images are rendered at full resolution and then successively
+scaled down by a linear factor of 2 prior to display, until they fit
+on the screen.  The display can be controlled interactively using
+mouse and keyboard commands.  The left mouse button expands the image
+by a factor of two and the right button reduces it by the same factor.
+If the image is bigger than the available window size, the middle
+mouse button can be used to reposition it within the window.  Hold
+down the middle button while dragging the image to its new position.
+
+Further interaction is controlled by single-key commands:
+.TP
+.B
+h or Help
+displays a page of help information.  Type 'q' to return to the
+original document.
+.TP
+.B
+p or Prior or PgUP or - or BackSpace
+displays the previous page from the command-line list.
+.TP
+.B
+n or Next or PgDn or + or space
+displays the next page from the command-line list.
+.TP
+.B Shift HOME
+displays the first page from the command-line list.
+.TP
+.B Shift END
+displays the last page from the command-line list.
+.TP
+.B z
+zoom in (same as right mouse button).
+.TP
+.B Shift Z
+zoom out (same as left mouse button).
+.TP
+.B u
+turns the image upside down, which is useful if the fax was originally
+fed the wrong way into the machine.
+.TP
+.B Shift U
+turns this and all following pages upside down.
+.TP
+.B l
+turns the image through 90 degrees, to view landscape text.
+.TP
+.B Shift L
+turns this and all following pages sideways.
+.TP
+.B m
+produce a left/right mirror image of the page.
+.TP
+.B Shift M
+mirror this and all following pages.
+.TP
+.B cursor arrows
+reposition the displayed image if it exceeds the window size.
+.TP
+.B HOME
+repositions so that the top left corner is visible.
+.TP
+.B END
+makes the bottom right corner visible.
+.TP
+.B q
+terminates the program.
+.TP
+.B Shift Q
+terminates the program with non-zero exit status.  Can be used to
+abort a shell script, e.g. when the user is previewing an outbound fax
+and decides not to send it.
+.SH OPTIONS
+.B viewfax
+is designed to "do the right thing" when given just a filename.
+Special cases can be handled with the following options.  (Note that
+tiff-files contain a header which overrides the \fB-f, -n, -h, -w, -l,
+-m, \fRand \fB-u \fRflags.)
+.TP
+.B -f
+indicates that raw input files are fine resolution (7.7 lines/mm)
+faxes.  This is the default unless the filename begins with "fn".
+Tiff and "PC-Research" (DigiFAX) files are self-specifying.
+.TP
+.B -n
+indicates that raw input files are normal resolution (3.85 lines/mm)
+faxes.  Each fax line is duplicated in the displayed image to give
+approximately equal vertical and horizontal scales.
+.TP
+.B -h\fIheight
+specifies the number of fax lines.  If this option is missing,
+.B viewfax
+counts the number of lines in the input file.
+.TP
+.B -w\fIwidth
+specifies the number of pixels in each scan-line.  The default value is 1728.
+.TP
+.B -l
+display in landscape mode.
+.TP
+.B -u
+turn the image upside down.
+.TP
+.B -i
+invert pixels (black/white).
+.TP
+.B -b
+preferred warning style: 'a' for audible bell (console beep), 'v' for
+visible bell (flash the window), 'n' for neither.  'v' is the default.
+.TP
+.B -d or -display
+use specified X server
+.TP
+.B -g or -geometry
+the preferred size and position of the window, specified as
+\fIwidth\fRx\fIheight\fR+\fIx\fR+\fIy\fR.  If a position is given (x
+and y values),
+.B viewfax
+asks the window manager to place the window there.  The initial size
+of the window is constrained to be at most \fIwidth\fRx\fIheight\fR.
+
+If the window is subsequently resized due to the user zooming in or
+out, the geometry is taken as a constraint on the screen area which
+may be used by
+.B viewfax.
+
+If you do not supply a geometry value, everything works fine with
+ICCCM-compliant window managers like \fBolwm, mwm, twm, \fRand
+\fBtvtwm\fR.  When fully zoomed out the
+.B viewfax
+window will occupy the entire screen.
+
+Users of
+.B fvwm
+will notice that the title bar and left border are moved off screen when
+.B viewfax
+repositions the window to (0,0).  A workaround is to use -geometry
++5+23 when using
+.B fvwm.
+The proper fix would be for someone to update the routine
+HandleConfigureRequest() in fvwm/events.c to correspond to the code in
+twm/events.c.
+.TP
+.B -m\fImemory limit
+each page is kept in memory after being fetched and expanded, which
+saves time if the user returns to it in the same session.  To prevent
+viewfax from using all the available swap space, a limit is placed on
+the total size of cached images.  This defaults to 4 MBytes, enough
+for about 6 typical pages.  If the memory limit is exceeded, old images
+are discarded and must be reloaded from disk if the user returns to
+them.  The operation of this mechanism is transparent apart from the
+occasional delays due to reloading.  The value specified on the
+command line can be suffixed
+.B k
+or
+.B m
+for kilo- or megabytes.
+.TP
+.B -r
+the bit order of the bytes in the input file is reversed.  The fax
+specification deals only with serial data transmission.  Modem
+manufacturers have to decide whether the first bit received should be
+placed in the most significant or the least significant position in a
+byte.  The consensus is to pack most significant first, but the -r
+flag is available to deal with the opposite order.
+.TP
+.B -v
+produce some informative messages (verbose mode).
+.TP
+.B -z\fIzoom
+specifies an initial zoom factor.  A full-scale fax will usually not
+fit on the screen.  If the
+.B -z
+option is not specified,
+.B viewfax
+scales the image by a power of 2 such that it is fully visible at a
+reduced size.  The user can then use the mouse buttons (see above) to
+view expanded portions of the image.
+.TP
+.B -2
+Assume that raw input files use group 3 two dimensional coding.
+.TP
+.B -4
+Assume that raw input files use group 4 coding.  The number of fax
+lines (-h option) is required in this case.
+.SH SEE ALSO
+.B mgetty
+(http://alpha.greenie.net/mgetty/) controls data/fax/voice modems.
+
+.B hylafax
+(ftp://sgi.com/sgi/fax) is a full-function fax client/server system.
+
+.B g3topbm(1)
+and
+.B xv(1)
+can be used in a pipeline to view faxes.  This will usually be slower
+than using
+.B viewfax,
+but
+.B xv
+has many capabilities for manipulating the image and saving it
+in other formats.
+
+.B xli(1)
+can display a wide variety of image formats, including g3 faxes.
+Version 1.15 has difficulty recognising damaged fax files.
+
+.B faxview.tcl,
+(ftp://ftp.leo.org/pub/comp/os/unix/networking/mgetty/faxview.tcl.gz)
+a simple dialog for viewing FAX messages by Ralph Schleicher
+(rs@purple.in-ulm.de).  This is a useful tool which provides a file
+menu from which incoming faxes can be selected for display with
+.B viewfax.
+
+
+CCITT (now ITU) Recommendation T.4,
+.I Standardization of Group 3 Facsimile Apparatus for Document
+.I Transmission. 
+
+CCITT (now ITU) Recommendation T.6,
+.I Facsimile Coding Schemes and Coding Control Functions for Group 4
+.I Facsimile Apparatus.
+.SH BUGS
+The user interface does not comply with any known style guide.
+.br
+The help text looks moth-eaten because it is encoded as a fax.  This
+avoids dealing with X11 fonts.
+.br
+The program does not refer to the X resources database.
+.SH AUTHOR
+Frank D. Cringle (fdc@cliwe.ping.de).
Binary files mgetty-1.1.22/frontends/X11/viewfax-2.5/viewfax.tif and mgetty-current/frontends/X11/viewfax-2.5/viewfax.tif differ
Only in mgetty-1.1.22/frontends/X11: wosch.note
Only in mgetty-1.1.22/frontends/X11: xforms.note
Only in mgetty-1.1.22/frontends: emacs
Only in mgetty-1.1.22/frontends: fax-by-lpr.txt
Only in mgetty-1.1.22/frontends: faxdvi-1.1.tar.gz
Only in mgetty-1.1.22/frontends: faxit.README
Only in mgetty-1.1.22/frontends: faxmail
Only in mgetty-1.1.22/frontends: faxpr.README
Only in mgetty-1.1.22/frontends: gfax.README
Only in mgetty-1.1.22/frontends: mail2fax
Only in mgetty-1.1.22/frontends: mmdf-mail2fax
Only in mgetty-1.1.22/frontends: network
Only in mgetty-1.1.22/frontends/perl-tk: FileSelector.pm
Only in mgetty-1.1.22/frontends/perl-tk: Makefile
Only in mgetty-1.1.22/frontends/perl-tk: XYListbox.pm
Only in mgetty-1.1.22/frontends/perl-tk: faxman.doc
Only in mgetty-1.1.22/frontends/perl-tk: faxman.pl
Only in mgetty-1.1.22/frontends/perl-tk: handle_commands.pl
Only in mgetty-1.1.22/frontends/perl-tk: xfax.pl
Only in mgetty-1.1.22/frontends: smail-direct.cfg
Only in mgetty-1.1.22/frontends/tcl: faxview-0.2
Only in mgetty-1.1.22/frontends: windows
Only in mgetty-1.1.22/frontends: winword
Only in mgetty-1.1.22/frontends: winword2
Only in mgetty-1.1.22/frontends/www: INSTALL.README
Only in mgetty-1.1.22/frontends: xtexsh
diff -urP mgetty-1.1.22/g3/g3split.c mgetty-current/g3/g3split.c
--- mgetty-1.1.22/g3/g3split.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/g3/g3split.c	Thu Nov 16 11:41:43 2000
@@ -0,0 +1,131 @@
+/* g3split.c
+ *
+ * program to split multi-page digifax files into single-page files
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+/* Digifax Header
+ *   Preamble is static ("magic bytes")
+ *   Byte 24+25 mark total number of pages (lo/hi byte)
+ *   Byte 26+27 mark current pages number (lo/hi byte)
+ *   Byte 45+29 are used for lo res (0/0) vs. hi res (0x40/0x01)
+ */
+static char hdr[64] = "\000PC Research, Inc\000\000\000\000\000\000";
+
+int exit_usage(char * p )
+{
+    fprintf( stderr, "%s: syntax error\n", p );
+    fprintf( stderr, "usage: %s input.g3 output<%%d>.g3\n", p );
+    exit(1);
+}
+
+int main( int argc, char ** argv )
+{
+int pagecount;
+char name[PATH_MAX];
+
+FILE * in;
+FILE * out;
+
+char wbuf[8192];		/* "transit" buffer */
+int  w;				/* write buffer counter */
+int ch;
+int hcnt;			/* "header match" counter */
+
+    /* too few/too many arguments */
+    if ( argc != 3 ) { exit_usage( argv[0] ); }
+
+    /* target path too long */
+    if ( strlen( argv[2] ) + 20 > sizeof( name ) ) { exit_usage( argv[0]); }
+
+    if ( ( in = fopen( argv[1], "r" ) ) == NULL )
+    {
+	fprintf( stderr, "%s: can't read '%s': %s\n", argv[0], argv[1],
+		 strerror(errno) );
+	exit(2);
+    }
+
+    pagecount = 0;
+
+    w=0;			/* output buffer write pointer */
+    hcnt=0;			/* "header comparison" counter */
+
+    while( ( ch = fgetc( in ) ) != EOF )
+    {
+	wbuf[w++] = ch;			/* save to output buffer */
+
+	if ( ch == hdr[hcnt] ) 		/* found matching char.  */
+	    hcnt++;
+	else				/* mismatch -> reset ctr.*/
+	    hcnt=0;
+
+#ifdef DEBUG
+	fprintf( stderr, "%02x w=%d hcnt=%d pc=%d\n", ch, w, hcnt, pagecount );
+#endif
+
+	if ( hcnt > 20 )			/* found "enough" header */
+	{					/* to start new file */
+	    pagecount++;
+	    if ( pagecount != 1 )		/* not first file */
+	    {					/* -> flush buffer */
+		if ( fwrite( wbuf, 1, w-hcnt, out ) != w-hcnt )
+		{
+		    fprintf( stderr, "%s: can't write all %d bytes to %s: %s", argv[0], w-hcnt, name, strerror(errno) );
+		    exit(4);
+		}
+		fclose( out );
+
+		/* copy "what's left in the buffer" to "start of buffer"
+		 */
+		memmove( wbuf, &wbuf[w-hcnt], hcnt );
+		w=hcnt;
+	    }
+	    hcnt=0;
+
+	    /* and open next output file
+	     */
+	    sprintf( name, argv[2], pagecount );
+	    if ( ( out = fopen( name, "w" ) ) == NULL )
+	    {
+		fprintf( stderr, "%s: can't open '%s' for writing: %s\n", 
+			 argv[0], name, strerror(errno) );
+		exit(3);
+	    }
+	}
+
+	/* buffer more than 50% full -> flush out first 4K */
+	if ( w > sizeof(wbuf)/2 )
+	{
+	    if ( pagecount == 0 )	/* no file open! */
+			    { break; }
+
+	    if ( fwrite( wbuf, 1, sizeof(wbuf)/2, out ) != sizeof(wbuf)/2 )
+	    {
+		fprintf( stderr, "%s: can't write all %d bytes to %s: %s", argv[0], (int) sizeof(wbuf)/2, name, strerror(errno) );
+		exit(4);
+	    }
+	    w -= sizeof(wbuf)/2;
+	    memcpy( wbuf, wbuf+sizeof(wbuf)/2, w );
+	}
+    }
+
+    /* end of input file -> flush buffer to output file */
+    if ( pagecount == 0 )	/* no file open! */
+    {
+	fprintf( stderr, "%s: input file %s is no digifax file\n", argv[0], argv[1] );
+	exit(2);
+    }
+    if ( fwrite( wbuf, 1, w, out ) != w )
+    {
+	fprintf( stderr, "%s: can't write all %d bytes to %s: %s", argv[0], w, name, strerror(errno) );
+	exit(4);
+    }
+    fclose(out);
+    fclose(in);
+
+    return 0;
+}
+
diff -urP mgetty-1.1.22/mg_m_init.c mgetty-current/mg_m_init.c
--- mgetty-1.1.22/mg_m_init.c	Sat Mar 13 20:21:42 1999
+++ mgetty-current/mg_m_init.c	Thu Nov 16 11:41:38 2000
@@ -1,4 +1,4 @@
-#ident "$Id$ Copyright (c) Gert Doering"
+#ident "$Id$ Copyright (c) Gert Doering"
 
 /* mg_m_init.c - part of mgetty+sendfax
  *
@@ -18,6 +18,8 @@
 #endif
 
 #ifdef linux
+# include <sys/types.h>
+typedef u_int32_t __u32;
 # include <linux/serial.h>
 #endif
 
diff -urP mgetty-1.1.22/mgetty.h mgetty-current/mgetty.h
--- mgetty-1.1.22/mgetty.h	Mon May 24 15:35:06 1999
+++ mgetty-current/mgetty.h	Thu Nov 16 11:41:38 2000
@@ -1,7 +1,7 @@
 #ifndef ___MGETTY_H
 #define ___MGETTY_H
 
-#ident "$Id$ Copyright (c) Gert Doering"
+#ident "$Id$ Copyright (c) Gert Doering"
 
 /* mgetty.h
  *
@@ -168,7 +168,7 @@
  * union to use "void *" and "long", instead of "int" (see config.h).
  * Same for Sparc Ultra machines [at least with SparcLinux]
  */
-#if defined(__alpha__) || defined(__sparc64__)
+#if defined(__alpha__) || defined(__sparc64__) || defined(__ia64__)
 # define PTR_IS_LONG
 #endif
 
diff -urP mgetty-1.1.22/tap/Makefile mgetty-current/tap/Makefile
--- mgetty-1.1.22/tap/Makefile	Thu Jan  1 01:00:00 1970
+++ mgetty-current/tap/Makefile	Thu Nov 16 11:41:44 2000
@@ -0,0 +1,13 @@
+#
+# $Id$
+#
+CC=gcc
+CFLAGS=-I.. -Wall
+LIBS=-lsocket
+
+OBJ=../tio.o ../logfile.o ../io.o ../modem.o ../locks.o ../config.o
+
+all: tap
+
+tap: tap.o $(OBJ)
+	$(CC) -o tap tap.o $(OBJ) $(LIBS)
diff -urP mgetty-1.1.22/tap/README mgetty-current/tap/README
--- mgetty-1.1.22/tap/README	Thu Jan  1 01:00:00 1970
+++ mgetty-current/tap/README	Thu Nov 16 11:41:44 2000
@@ -0,0 +1,6 @@
+This is a very early cut at a "send stuff to paging services" program.
+
+It can send messages to paging providers using the IXO/TAP protocol
+(e.g. E+ and D1 in Germany) or the UCP protocol (D2 in Germany).
+
+No useful documentation is available right now :-)
diff -urP mgetty-1.1.22/tap/mail mgetty-current/tap/mail
--- mgetty-1.1.22/tap/mail	Thu Jan  1 01:00:00 1970
+++ mgetty-current/tap/mail	Thu Nov 16 11:41:44 2000
@@ -0,0 +1,589 @@
+From prozac.eeap.cwru.edu!wes Tue Jan  6 20:35:21 1998
+Return-Path: <wes@prozac.eeap.cwru.edu>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xpemN-000A6hC@greenie.muc.de>; Tue, 6 Jan 98 20:35 MET
+Received: (from wes@localhost) by prozac.eeap.cwru.edu (8.8.5/8.6.12) id OAA09383 for gert@greenie.muc.de; Tue, 6 Jan 1998 14:35:00 -0500
+From: Wes Brown <wes@prozac.eeap.cwru.edu>
+Message-Id: <199801061935.OAA09383@prozac.eeap.cwru.edu>
+Subject: Some pager information for you
+To: gert@greenie.muc.de
+Date: Tue, 6 Jan 1998 14:34:59 -0500 (EST)
+X-URL: http://prozac.student.cwru.edu/wes/About.me.html
+X-Mailer: ELM [version 2.4 PL24]
+MIME-Version: 1.0
+Content-Type: text/plain; charset=US-ASCII
+Content-Transfer-Encoding: 7bit
+Status: ROr
+
+I found a very informative page on protocols used to send alpha pages.  The
+man that writes the pages works for a member of the paging industry.
+
+His page can be found at
+http://village.ios.com/~braddye/index.html
+
+Wes
+--- 
+Wes Brown
+ewb4@po.cwru.edu		wes@prozac.cwru.edu
+http://prozac.cwru.edu/wes/About.me.html
+KB8TGR
+
+From unixpc.germany.tandem.com!jojo Mon Jan 19 09:22:38 1998
+Return-Path: <jojo@unixpc.germany.tandem.com>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xuCQK-0001VMC@greenie.muc.de>; Mon, 19 Jan 98 09:19 MET
+Received: from unixpc.germany.tandem.com (jojo@unixpc.germany.tandem.com [168.87.29.119])
+	by Tandem.com (8.8.8/2.0.1) with ESMTP id AAA01036;
+	Mon, 19 Jan 1998 00:19:02 -0800 (PST)
+Received: (from jojo@localhost)
+	by unixpc.germany.tandem.com (8.8.7/8.8.7) id IAA12986;
+	Mon, 19 Jan 1998 08:19:56 +0100
+From: Joachim Schmitz <jojo@unixpc.germany.tandem.com>
+Message-Id: <199801190719.IAA12986@unixpc.germany.tandem.com>
+Subject: Re: SMS?
+To: pfeiffer@pds.de (Thomas Pfeiffer)
+Date: Mon, 19 Jan 1998 08:19:55 +0100 (CET)
+Cc: gert@greenie.muc.de, isdn4linux@hub-wue.franken.de
+In-Reply-To: <199801190757.IAA07366@pdsinter.pds.de> from "Thomas Pfeiffer" at Jan 19, 98 08:57:19 am
+Organization: Tandem Computers GmbH
+Content-Type: text
+Status: RO
+
+Hi Thomas
+
+> > Sollte aber jemand ISDN-Zugaenge & das verwendete Protokoll kennen, waere
+> > ich fuer diese Info sehr verbunden [bastele gerade an einem "SMS-Sende-
+> > Tool" fuer allgemeine Unix-Varianten, also via Modem, ISDN, whatever].
+> D1 ist ueber X.75/T.70 (mit 2 byte header :) zu erreichen 09116633936
+> D2 ueber V.110 (die trottel haben terminaladapter 8-) 01722278000
+D2 geht auch ueber 01722278010 mit X.75 und ohne patches.
+
+-- 
+Tschoe,	Jojo
+
+email:
+work SCHMITZ_JOACHIM@Tandem.COM, Joachim.Schmitz@Compaq.COM
+home Joachim_Schmitz@D.maus.de (no mails >64k please)
+
+From ruhr-uni-bochum.de!Martin.H.Ludwig Mon Jan 19 09:45:19 1998
+Return-Path: <Martin.H.Ludwig@ruhr-uni-bochum.de>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xuCpa-0001VMC@greenie.muc.de>; Mon, 19 Jan 98 09:45 MET
+Received: (qmail 7634 invoked from network); 19 Jan 1998 08:45:16 -0000
+Received: from dialppp-1-156.rz.ruhr-uni-bochum.de (HELO biggy.ma.net) (root@134.147.1.156)
+  by mailhost.rz.ruhr-uni-bochum.de with SMTP; 19 Jan 1998 08:45:16 -0000
+Received: from winnie.ma.net (win.ma.net [10.1.2.6]) by biggy.ma.net (8.7/8.6.12) with SMTP id IAA27344 for <gert@greenie.muc.de>; Mon, 19 Jan 1998 08:56:13 +0100
+Message-Id: <199801190756.IAA27344@biggy.ma.net>
+Comments: Authenticated sender is <malu@biggy.ma.net>
+From: Martin.H.Ludwig@ruhr-uni-bochum.de
+To: gert@greenie.muc.de (Gert Doering)
+Date: Mon, 19 Jan 1998 08:52:20 +0000
+MIME-Version: 1.0
+Content-type: text/plain; charset=ISO-8859-1
+Content-transfer-encoding: Quoted-printable
+Subject: Re: SMS?
+Priority: normal
+In-reply-to: <En02DE.LMB@greenie.muc.de>
+X-mailer: Pegasus Mail for Win32 (v2.53DE/R1)
+Status: ROr
+
+Hallo Gert!
+
+Bevor Du da viel Zeit investierst, schau die mal yaps an (ein Hinweis
+darauf mit Quellenangabe war vor kurzem auf der isdn4linux-Liste).
+Es ist gaube ich genau das, was Du entwickeln willst. ISDN-Zug=E4nge
+klappen zumindest mit D1 und D2 (Zugangsnummern:
+D1: 01712521001 Protokoll TAP
+D2: 01722278000 Protokoll UCP
+
+Martin
+
+
+Martin H. Ludwig
+E-Mail:
+  MaNet: malu@biggy.ma.net
+  Internet: IngBueroLudwig@gmx.de
+Snail-Mail
+  Zur Post 5
+  44879 Bochum
+Tel: 0234 / 9 49 02 04
+Fax: 0234 / 9 40 02 05
+
+From akademie.de!kirsch Mon Jan 19 14:45:43 1998
+Return-Path: <kirsch@akademie.de>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xuHWI-0003r2C@greenie.muc.de>; Mon, 19 Jan 98 14:45 MET
+Received: from clooney(really [195.37.36.143]) by mail.akademie1.de
+	via sendmail with smtp
+	id <m0xuH1J-000mIiC@mail.akademie1.de>
+	for <gert@greenie.muc.de>; Mon, 19 Jan 1998 14:13:41 +0100 (MET)
+	(Smail-3.2.0.92 1997-Feb-9 #9 built DST-Jun-16)
+Message-ID: <34C3524A.AC0@akademie.de>
+Date: Mon, 19 Jan 1998 14:16:58 +0100
+From: Christian Kirsch <kirsch@akademie.de>
+Reply-To: kirsch@akademie.de
+Organization: HRP GmbH
+X-Mailer: Mozilla 3.01 [de] (WinNT; I)
+MIME-Version: 1.0
+To: Gert Doering <gert@greenie.muc.de>
+Subject: Re: SMS?
+References: <34BA2E02.6337@akademie.de> <En02DE.LMB@greenie.muc.de>
+Content-Type: text/plain; charset=iso-8859-1
+Content-Transfer-Encoding: 8bit
+Status: RO
+
+Gert Doering wrote:
+> 
+> Christian Kirsch <kirsch@akademie.de> writes:
+> 
+> >Wei jemand, ob und ggfs. wie man per isdn4linux eine SMS-Nachricht
+> >verschicken kann? Naiverweise denke ich, da man einfach die
+> >entsprechende Nummer des Netzes whlt und dann die Meldung "irgendwie"
+> >dranhngt.
+> >Das "irgendwie" ist natrlich das spannende. Oder ist das wg.
+> >PiepFurzKnack genauso unmglich wie G3-Faxen?
+> 
+> Mir sind bisher nur analoge Zugaenge zu den jeweiligen SMS-Centers bekannt
+> (D1, D2, E+, Quix, Cityruf).
+
+Hallo Gert,
+
+D1 hat seit Ende Dezember ISDN (01712521001, wenn ich mich recht
+erinnere).
+D2 hat jemand anders schon gepostet (Danke!)
+E+ will das zur CeBit anbieten. 
+
+Gre
+
+From hq.seicom.net!udesign!lukas Tue Jan 20 00:33:07 1998
+Return-Path: <udesign!lukas@hq.seicom.net>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xuQgf-00015iC@greenie.muc.de>; Tue, 20 Jan 98 00:33 MET
+Received: from udesign.UUCP by hq.seicom.net (8.8.5/8.8.3) with UUCP id AAA26304 for greenie.muc.de!gert; Tue, 20 Jan 1998 00:24:22 +0100 (CET)
+Received: by reactor.design.de
+	id m0xuQiQ-000BijC
+	(Debian Smail-3.2 1996-Jul-4 #2); Tue, 20 Jan 1998 00:34:50 +0100 (MET)
+Message-ID: <19980120003450.24501@reactor>
+Date: Tue, 20 Jan 1998 00:34:50 +0100
+From: Lukas Wunner <lukas@design.de>
+To: gert@greenie.muc.de
+Subject: SMS...
+Mime-Version: 1.0
+Content-Type: text/plain; charset=iso-8859-1
+X-Mailer: Mutt 0.88
+Content-Transfer-Encoding: quoted-printable
+X-MIME-Autoconverted: from 8bit to quoted-printable by hq.seicom.net id AAA26304
+Status: ROr
+
+Hi Gert,
+
+Habe von Winni eine Nachricht von Dir auf der isdn4linux ML geforwardet
+bekommen. Du sagst Du hackst an einem Programm das =FCber Modem/ISDN/what=
+ever
+SMSe rausheizen kann. Hast Du da schon was f=FCr das Siemens M1-Modul?
+Wenn nicht, kannst Du da was brauchen? Habe ein rudiment=E4res Perl Scrip=
+t
+gehackt mit dem geht es. Kennst Du Dich mit diesem PDU-Zeug aus? Bin
+mir nicht sicher ob das irgendwie im GSM-Standard verankert ist oder was
+propriet=E4res von Siemens. Jedenfalls sieht es so aus da=DF man SMSe ver=
+schickt
+indem man dem M1-Modul eine PDU gibt (langer Hex-String). Ist bischen
+friemelig. Was vor allem d=E4mlich ist: die Nachricht wird defaultm=E4=DF=
+ig
+in einem 7-Bit Alphabet kodiert, und zwar stuffed er die 7 Bits der
+Zeichen zusammen so da=DF man 160 statt nur 140 Zeichen Nachrichten in
+eine PDU quetschen kann. Total idiotische Codierung, die Telefonnummer
+will er in BCD. Haben sich irgendwelche Cobol-Hacker ausgedacht oder
+ich wei=DF es nicht.  Man kann aber auch ein 8-Bit Alphabet
+selektieren (via Option im PDU-Header). Aber ich wei=DF nicht wie das
+Alphabet aussieht. In der Doku steht nur "you can relate to the
+INTEL ASCII-HEX table". Toll. Wo finde ich den? Habe das jetzt einfach
+so gemacht da=DF er die Nummer jedes Ascii-Zeichens nimmt, nach Hex
+kodiert und fertig. Auf Winnis Handy (ich denke ein Siemens) zeigt er das
+dann richtig an, bei einem Kollegen auf dem Handy (Sony) kommt nur
+Datenm=FCll an. Sehr omin=F6s. Irgendne Idee? Vielleicht irgendwelchen
+Code der solches PDU-Zeug handlet? Ach ja falls Du das M1-Modul nicht
+kennst, das ist praktisch ein Handy mit Modem, aber ohne Mikro+Lautsprech=
+er.
+Das kann man z.B. im Auto verwenden um Telemetrie-Daten rauszuheizen etc.
+Oder wie bei uns im station=E4ren Einsatz um Nachrichten rauszuheizen auc=
+h
+wenn die Telekom s=E4mtliche Anschl=FCsse geschlachtet hat (sehr n=FCtzli=
+ch!).
+Ach ja: darf ich Dir in den n=E4chsten Tagen mal eine Testnachricht auf
+Dein Handy schicken, ich habe n=E4mlich noch nicht getestet ob das Script
+auch mit Nachrichten an e-plus Teilnehmer funzt (kenne sonst niemand der
+bei e-plus ist)?
+
+Sorry f=FCr den =DCberfall. :-)
+
+Ciao,
+	Lukas.
+
+PS: schon mal versucht ein USR Courier zum faxen oder SMS verschicken zu
+bewegen? *=C4tzend!!* In die Tonne mit dem Mistzeug!
+
+PPS: noch was wegen Analog-Leitungen: aufm CCC hab ich mit Achim Astel
+(noris network =3D=3D Xlink POP Nbg) gesprochen. Die betreiben auch Analo=
+g-
+Leitungen mit xDSL und zwar in OZ2! Das magische Wort bei der Bestellung
+hei=DFt "analoge Leitungsf=FChrung" (telekom-deutsch f=FCr "galvanisch ve=
+rbunden").
+
+--=20
+lukas wunner         unix, internetworking and security engineer
+lukas@wunner.de      LW26-RIPE      http://www.wunner.de/~lukas/
+Funkmodems mit 2.4GHz FAQ      http://www.wunner.de/~lukas/funk/
+
+From pds.de!pfeiffer Mon Jan 19 08:57:42 1998
+Return-Path: <pfeiffer@pds.de>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xuC5E-0001VMC@greenie.muc.de>; Mon, 19 Jan 98 08:57 MET
+Received: from pdsinter.pds.de (root@ns.pds.de [194.163.247.10])
+   by mail.maz.net (971021.1) with ESMTP id <IAA09418>
+   (for multiple receipients); Mon, 19 Jan 1998 08:57:19 +0100 (MET)
+Received: from thomas (thomas [192.68.2.18])
+	by pdsinter.pds.de (8.8.5/8.8.5) with SMTP id IAA07366;
+	Mon, 19 Jan 1998 08:57:19 +0100
+Message-Id: <199801190757.IAA07366@pdsinter.pds.de>
+Comments: Authenticated sender is <pfeiffer@[192.68.2.130]>
+From: "Thomas Pfeiffer" <pfeiffer@pds.de>
+Organization: PDS GmbH
+To: isdn4linux@hub-wue.franken.de
+Date: Mon, 19 Jan 1998 08:57:19 +0100
+MIME-Version: 1.0
+Content-type: text/plain; charset=ISO-8859-1
+Content-transfer-encoding: Quoted-printable
+Subject: Re: SMS?
+CC: gert@greenie.muc.de (Gert Doering)
+Priority: normal
+In-reply-to: <En02DE.LMB@greenie.muc.de>
+X-mailer: Pegasus Mail for Win32 (v2.52)
+Status: RO
+
+> >Wei=AF jemand, ob und ggfs. wie man per isdn4linux eine SMS-Nachricht
+> >verschicken kann? Naiverweise denke ich, da=AF man einfach die
+> >entsprechende Nummer des Netzes w=F5hlt und dann die Meldung "irgendwie=
+"
+> >dranh=F5ngt. 
+> >Das "irgendwie" ist nat=B3rlich das spannende. Oder ist das wg.
+> >PiepFurzKnack genauso unm=F7glich wie G3-Faxen?
+> 
+> Mir sind bisher nur analoge Zugaenge zu den jeweiligen SMS-Centers bekan=
+nt
+> (D1, D2, E+, Quix, Cityruf).
+> 
+> Sollte aber jemand ISDN-Zugaenge & das verwendete Protokoll kennen, waer=
+e
+> ich fuer diese Info sehr verbunden [bastele gerade an einem "SMS-Sende-
+> Tool" fuer allgemeine Unix-Varianten, also via Modem, ISDN, whatever].
+D1 ist ueber X.75/T.70 (mit 2 byte header :) zu erreichen 09116633936
+D2 ueber V.110 (die trottel haben terminaladapter 8-) 01722278000
+
+anmerkung:
+fuer beides solltest du meine patches (http://pds.de/i4l) verwenden.
+das T.70 fuer T-online funktioniert nicht, V.110 ist noch im beta-stadium.
+sms ueber D1 haben wir hier schon ueber hylafax am laufen, mit D2 kommt's =
+noch
+----------------------------------------------------------------------
+Thomas Pfeiffer (pfeiffer@pds.de), PDS - Programm + Datenservice GmbH
+http://www.pds.de/qfs.html, Tel: 49 4261 855 614, Fax: 49 4261 855 675
+----------------------------------------------------------------------
+
+From gert Tue Dec 16 18:07:57 1997
+Return-Path: <gert>
+Received: by greenie.muc.de (/\==/\ Smail3.1.24.1 #24.2)
+	id <m0xi0TN-0004NRC@greenie.muc.de>; Tue, 16 Dec 97 18:07 MET
+Message-Id: <m0xi0TN-0004NRC@greenie.muc.de>
+Date: Tue, 16 Dec 97 18:07 MET
+From: gert (Gert Doering)
+To: gert
+Subject: SMS_Client 2.0.3
+Status: RO
+
+
+>Path: greenie!news.muc.de!news.space.net!newsfeed.ecrc.net!195.74.75.15.MISMATCH!fci-se!fci!newsfeed.sunet.se!news99.sunet.se!news01.sunet.se!128.214.248.135.MISMATCH!newsfeed1.funet.fi!news2.funet.fi!news.funet.fi!news.helsinki.fi!not-for-mail
+>From: Angelo Masci <angelo@styx.demon.co.uk>
+>Newsgroups: comp.os.linux.announce
+>Subject: SMS_Client 2.0.3
+>Followup-To: comp.os.linux.misc
+>Date: Tue, 16 Dec 1997 12:52:55 GMT
+>Organization: none
+>Lines: 72
+>Approved: linux-announce@news.ornl.gov (Mikko Rauhala)
+>Message-ID: <pycola.882276775.1711@laulujoutsen.pc.helsinki.fi>
+>NNTP-Posting-Host: laulujoutsen.pc.helsinki.fi
+>Old-Date: Sun, 14 Dec 1997 05:25:43 +0000 (GMT)
+>X-No-Archive: yes
+>X-Auth: PGPMoose V1.1 PGP comp.os.linux.announce
+>	iQCVAgUBNJZ5p1rUI/eHXJZ5AQGIigP9E4NNkDQyR8UU4+KRQRZnB3YULkhJspmP
+>	tnvm2wTTTH9Lt/BWmcgthPAv870+jBz+XwAPGxS87LZRzEKNvrWx0n0hnB1I2Q9c
+>	BlSwWu0tztWZn5uH8FGbmjxHNT835F8K7BRYmK9ZzY8isDTsWLlDMJIyTpm7wPhW
+>	1wlwbJ0JkbY=
+>	=fl3D
+
+-----BEGIN PGP SIGNED MESSAGE-----
+
+
+SMS Client - 
+A simple client implementation for the GSM Short
+Message Service using TAP and non TAP protocols. 
+Allowing you to send short messages to mobile phones 
+and pagers.
+
+Version 2.0.0 Release new features:
+
+        Additional support for following services using non
+        TAP protocols:
+
+                Vodafone
+                Orange
+                PageOne currently in ALPHA
+
+        Better loggin facilities at different levels<BR>
+        New sms resource file format<BR>
+        New Drivers modularization allowing for plugin driver support
+
+The software has just be uploaded into sunsite. If you can't find
+it there, be patient or look in /incoming
+
+An LSM Entry follows.
+
+
+Begin3
+Title:          sms_client - send messages to mobiles and pagers
+Version:        2.0.3
+Entered-date:   13 Dec 1997
+Description:    A simple client implementation for the GSM Short
+                Message Service using TAP. Allowing you to send
+                short messages to mobile phones and pagers.
+		Tested with a number of providers in the UK. These
+		include: Cellnet, Orange and Vodafone.
+Keywords:       TAP modem comms serial network mobile pager paging
+Author:         angelo@styx.demon.co.uk (Angelo Masci)
+Maintained-by:  angelo@styx.demon.co.uk (Angelo Masci)
+Primary-site:   sunsite.unc.edu /pub/Linux/apps/serialcomm/machines
+		22k sms_client-2.0.3.tgz
+		861 sms_client-2.0.3.lsm
+
+Alternate-site: http://lines0.uwic.ac.uk/~ac0412/sms_client
+                This site will be shutdown for maintenance on
+		13-15 December
+
+Original-site:  
+Platforms:      Linux, libmodem-1.0.0 package and modem
+Copying-policy: GPL
+End
+
+
+
+- -- 
+This article has been digitally signed by the moderator, using PGP.
+http://www.iki.fi/mjr/cola-public-key.asc has PGP key for validating signature.
+Send submissions for comp.os.linux.announce to: linux-announce@news.ornl.gov
+PLEASE remember a short description of the software and the LOCATION.
+This group is archived at http://www.iki.fi/liw/linux/cola.html
+
+-----BEGIN PGP SIGNATURE-----
+Version: 2.6.3ia
+Charset: latin1
+
+iQCVAgUBNJZ5p1rUI/eHXJZ5AQG1hwQAqh10WGywC7cgopMK7ikElbuGgTK8Q9l6
+dXf1IjsgqI+S7c5UF1W2LfM1TdxqS3vmERC0/54ybfRSX/5TcCQalzztiwVoCALD
+rGol5PTSzQXx9zaFmAqaq4i6+e+q/3MuAwwJmzhZKJY9hWetQ9EH7uPJD7HYrZL7
+YO+okoiSfwk=
+=6n9H
+-----END PGP SIGNATURE-----
+-- 
+email: gert@greenie.muc.de   fax: +49-89-3244814   http://www.leo.org/~doering
+
+With her body, woman is more sincere than man; but with her mind she lies.
+And when she lies, she does not believe herself.
+               --Tolstoy
+
+From gert Sun Nov 29 00:45:40 1998
+Return-Path: <gert>
+Received: by greenie.muc.de
+	via sendmail with stdio
+	id <m0zju3X-000D0nC@greenie.muc.de>
+	for gert; Sun, 29 Nov 1998 00:45:39 +0100 (MET)
+	(Smail-3.2 1996-Jul-4 #4 built -Feb-21)
+Message-Id: <m0zju3X-000D0nC@greenie.muc.de>
+Date: Sun, 29 Nov 1998 00:45:39 +0100 (MET)
+From: gert (Gert Doering)
+To: gert
+Subject: SMS Client 2.0.7k Released
+Status: RO
+Content-Length: 4367
+Lines: 93
+
+
+>Xref: greenie2 comp.os.linux.announce:11602
+>Path: greenie2!news.muc.de!newscore.ipf.de!fu-berlin.de!uni-erlangen.de!newsfeed1.telenordia.se!newsfeed1.funet.fi!news.helsinki.fi!not-for-mail
+>From: angelo@styx.demon.co.uk (Angelo)
+>Newsgroups: comp.os.linux.announce
+>Subject: SMS Client 2.0.7k Released
+>Followup-To: comp.os.linux.misc
+>Date: Mon, 23 Nov 1998 21:20:13 GMT
+>Organization: none
+>Lines: 67
+>Approved: linux-announce@news.ornl.gov (Mikko Rauhala)
+>Message-ID: <pycola.911856013.20617@revelation.bak.helsinki.fi>
+>NNTP-Posting-Host: vision-isdn.bak.helsinki.fi
+>Old-Date: Tue, 17 Nov 1998 13:18:25 +0000 (GMT)
+>X-No-Archive: yes
+>X-Auth: PGPMoose V1.1 PGP comp.os.linux.announce
+>	iQCVAgUBNlnRjlrUI/eHXJZ5AQHTfAQArrbWbU8gEc6iTkBlhyiae5Km4FXOon8s
+>	0sQAWerZrMwjVUkC8tdUO63oWMwpQZL5QQMBsQfCXaDjDhHly8aj/go+QQnODGJI
+>	a17r+yTPys4rfOvZSsKa5Ivx1uI4g1SGo8XDWUQFPd7MgXvGfwEVwxRhbEtROVEt
+>	MNaBdUX3reA=
+>	=b1vf
+
+-----BEGIN PGP SIGNED MESSAGE-----
+
+
+        Linux SMS Client 2.0.7k by (c) 1997,1998 Angelo Masci
+        =====================================================
+
+		http://www.styx.demon.co.uk/
+		http://smsclient.home.ml.org/
+        
+
+SMS Client is a simple UNIX client Allowing you to send SMS messages to 
+mobile phones and pagers. The software currently supports a number of 
+providers and protocols:
+
+  +----------------------------------------------------------------------+
+  | Service         Protocol      Notes                                  |
+  +----------------------------------------------------------------------+
+  | CELLNET         TAP           Supports multiple sends (see NOTE)     |
+  | DETEMOBIL       TAP           Supports multiple sends (see NOTE)     |
+  | AZCOM           TAP           Supports multiple sends (see NOTE)     |
+  | TELSTRA         TAP           Supports multiple sends (see NOTE)     |
+  | VODAFONE        proprietary                                          |
+  | ORANGE          proprietary   Supports multiple sends (see NOTE)     |
+  |                               Includes Hutchinson Pagers             |
+  | PAGEONE         proprietary   Supports multiple sends (see NOTE)     |
+  | MINICALL        PAGEONE       Supports multiple sends (see NOTE)     |
+  | ONE2ONE         proprietary   Supports multiple sends (see NOTE)     |
+  | VODAPAGE        proprietary   Block Mode supported                   |
+  | VODACOM         proprietary                                          |
+  | PTT/KPN Telcom  proprietary   Supports multiple sends (see NOTE)     |
+  | ANSWER          proprietary                                          |
+  | MTN             proprietary                                          |
+  | LIBERTEL        proprietary   Supports multiple sends (see NOTE)     |
+  | TIM             proprietary   Supports multiple sends (see NOTE)     |
+  | PROXIMUS        proprietary                                          |
+  | AMPI            TAP                                                  |
+  | EUROPOLITAN     CIMD          Currently in ALPHA and testing         |
+  +----------------------------------------------------------------------+
+  |                 SNPP*         Currently in ALPHA and testing         |
+  |                 GENERIC*      Currently in ALPHA and testing         |
+  +----------------------------------------------------------------------+
+
+Using an unlisted provider that allow TAP access should be quite straight 
+forward. 
+
+Visit the WWW Site to download the latest development version, get
+further information and join the SMS Client mailing list.
+
+
+
+- -- 
+This article has been digitally signed by the moderator, using PGP.
+http://www.iki.fi/mjr/cola-public-key.asc has PGP key for validating signature.
+Send submissions for comp.os.linux.announce to: linux-announce@news.ornl.gov
+PLEASE remember a short description of the software and the LOCATION.
+This group is archived at http://www.iki.fi/mjr/linux/cola.html
+
+-----BEGIN PGP SIGNATURE-----
+Version: 2.6.3ia
+Charset: latin1
+
+iQCVAgUBNlnRjVrUI/eHXJZ5AQHLpwP/WB3s/rzn71vPqMV305RkHV/oAKUDYhrF
+j41Iysm0AUhkxPlEH58M6wamxVvGB8zk3Ylw+U4+uOUfexCzYrjo2K2iD+E9DZL6
+FoF9XBDj/6fqeM525vf8MSHItWQqhRAqUlVbrSqrzkLBPAq2ep+1cRLkOF6SXLYE
+PKkSC9cRYME=
+=Fa1l
+-----END PGP SIGNATURE-----
+-- 
+gert@greenie.muc.de   fax: +49-89-35655025   http://alpha.greenie.net/mgetty/
+
+Electrical Engineers do it with less resistance.
+
+From gert Sat Dec  5 01:37:07 1998
+Return-Path: <gert>
+Received: by greenie.muc.de
+	via sendmail with stdio
+	id <m0zm5id-000DIbC@greenie.muc.de>
+	for mgetty-list; Sat, 5 Dec 1998 01:37:07 +0100 (MET)
+	(Smail-3.2 1996-Jul-4 #4 built -Feb-21)
+Sender: gert (Gert Doering)
+Received: from slarti.muc.de(really [193.174.4.10]) by greenie.muc.de
+	via smtpd with smtp
+	id <m0zm5ib-000DLjC@greenie.muc.de>
+	for <mgetty-local@greenie.muc.de>; Sat, 5 Dec 1998 01:37:05 +0100 (MET)
+	(Smail-3.2 1996-Jul-4 #19 built -Nov-19)
+Received: (qmail 14464 invoked by uid 1013); 5 Dec 1998 00:34:36 -0000
+Delivered-To: mgetty@muc.de
+Received: (qmail 14458 invoked from network); 5 Dec 1998 00:34:35 -0000
+Received: from greenie.muc.de (root@193.174.156.65)
+  by slarti.muc.de with SMTP; 5 Dec 1998 00:34:35 -0000
+Received: by greenie.muc.de
+	via sendmail with stdio
+	id <m0zm5Zt-000DM9C@greenie.muc.de>
+	for mgetty@muc.de; Sat, 5 Dec 1998 01:28:05 +0100 (MET)
+	(Smail-3.2 1996-Jul-4 #4 built -Feb-21)
+Received: from GATEWAY by greenie.muc.de with netnews
+	for mgetty@muc.de (mgetty@muc.de)
+To: mgetty@muc.de
+Date: Fri, 4 Dec 1998 16:56:34 +0100
+From: rfrank@golem.muc.de (Robert Frank)
+Message-ID: <slrn76g1hi.iv.rfrank@golem.muc.de>
+Organization: Golem, Inc.
+Sender: owner-mgetty@greenie.muc.de
+Subject: yaps - yet another pager software
+Status: RO
+Content-Length: 1475
+Lines: 39
+
+Hello,
+
+may be it is well a known program to some of you and Id like to apologize 
+if this is the case.
+
+I just stumbled about yaps ("yet another pager software"). yaps is able 
+to notify a pager with the following services: 
+D1, D2, E+, Telmi, Telmi-Fun, Telmi-Family, Telmi-Top, Telmi-Pro, Skyper, Quix
+As it is a simple command line oriented program
+(yaps <phone-number> "Text here") it should be trivial to write a script that
+notifies the user that a voice/fax arrived on your unix box. (Of course
+there is a much broader usage, e.g. to notify the sysop of warnings and errors).
+
+Here is the lsm-File:
+
+Title:          yaps
+Version:        0.96
+Entered-date:   14JUN97
+Description:    This is a standalone program to send messages to paging
+                devices over a modem gateway using well defined protocols.
+Keywords:       pager sms tap ucp
+Author:         ud@nitmar.tnet.de (Ulrich Dessauer)
+Maintained-by:  ud@nitmar.tnet.de (Ulrich Dessauer)
+Primary-site:   ftp.sta.com /pub/fk/yaps
+                91k yaps-0.96.tar.gz
+		725 yaps.lsm
+Alternate-site: sunsite.unc.edu /pub/Linux/apps/serialcomm/machines/
+                91k yaps-0.96.tar.gz
+		725 yaps.lsm
+Platforms:      Linux, Solaris, SunOS and modem (or modem like device,
+                e.g. ISDN) optional SLang V99.38, Lua-2.5
+Copying-policy: GPL
+
+Greetings,
+Robert
+-- 
+Dr. Robert Frank
+email: rfrank@muc.de  http://www.golem.muc.de
+PGP fingerprint: 1F A3 41 2A 90 57 A5 57  90 FE A1 6F 4A 77 91 31
+
diff -urP mgetty-1.1.22/tap/tap.c mgetty-current/tap/tap.c
--- mgetty-1.1.22/tap/tap.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/tap/tap.c	Thu Nov 16 11:41:44 2000
@@ -0,0 +1,633 @@
+/* tap.c
+ *
+ * TAP/UCP support for calling up paging servers (experimental)
+ *
+ * Copyright (c) 1997 Gert Doering
+ */
+#ident "$Id$"
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <signal.h>
+
+#include "policy.h"
+#include "mgetty.h"
+#include "tio.h"
+#include "config.h"
+
+char * Device = "/dev/cuaa1";
+
+#define STX 0x02
+#define ETX 0x03
+#define EOT 0x04
+#define CR  0x0d
+#define ACK 0x06
+#define NAK 0x15
+
+typedef enum { Ptap, Pucp1, Pucp52, Pcityruf } prot_type;
+
+struct prov_t { char * name;
+		char * prefix;
+		prot_type proto;
+		char * dialup_num;
+		char * modem_init;
+		int msglen; } 
+	prov[] = {
+    { "E+", "0177", Ptap, "01771167", "ATZ", 160 },
+    { "D1", "0171", Ptap, "01712092522", "ATZ", 160 }, /*!!! untested */
+    { "D2", "0172", Pucp1, "01722278020", "AT+FCLASS=0;&N0S7=60", 160 },	/*!!! UCP52 */
+    { "Quix", "quix-t", Pucp1, "016593", "ATZ", 80 }, /*!!! untested */
+    { "CR1", "cityruf", Pcityruf, "01691", "ATZ", 80 }, /*!!! untested */
+    { "CR2", "cityruf", Pcityruf, "01691", "ATZ", 80 }, /*!!! untested */
+    { NULL, NULL, Ptap, NULL, NULL }};
+
+
+#define MAXMSG 100
+struct messi { int prov;		/* provider */
+	       char * number;
+	       char * msg; } messi[100] = {
+/*    { 0, "2160221", "TapSent - Umlaut " }, */
+    { 2, "8213646", "Hallo Maex! Mal gucken, ob der Watchdog funzt..." }};
+int nummsg = 1;
+
+int tap_send_text( int fd, char * field1, char * field2 )
+{
+    int csum=0, bufl=1, i;
+
+    char buf[240];
+
+    buf[0] = STX;
+
+    strcpy( &buf[bufl], field1 );
+    bufl += strlen(field1);
+    buf[bufl++] = CR;
+
+    strcpy( &buf[bufl], field2 );
+    bufl += strlen(field2);
+    buf[bufl++] = CR;
+
+    buf[bufl++] = ETX;
+
+    for ( i=0; i<bufl; i++ ) 
+    {
+	lprintf( L_JUNK, "%2d: %c x=%02x d=%3d", i, buf[i], buf[i], buf[i]);
+        csum += ( buf[i] & 0x7f );
+    }
+    lprintf ( L_JUNK, "csum: o=%03o x=%02x", csum, csum );
+
+    buf[bufl++] = 0x30 + ( ( csum >> 8 ) &0x0f );
+    buf[bufl++] = 0x30 + ( ( csum >> 4 ) &0x0f );
+    buf[bufl++] = 0x30 + ( csum          & 0x0f );
+    buf[bufl++] = CR;
+
+    lprintf( L_MESG, "sending %d bytes, chksum %02x %02x %02x", 
+			bufl, buf[bufl-4], buf[bufl-3], buf[bufl-2] );
+
+    if ( fd > 0 )
+    {
+	if ( write( fd, buf, bufl ) != bufl ) 
+	{
+	    lprintf( L_ERROR, "can't send buf" );
+	    perror( "can't send message buffer" );
+	    exit(27);
+	}
+    }
+}
+
+int tap_send_message( int fd, char * field1, char * field2 )
+{
+int count, ack;
+char ch, buf[400]; int bl;
+
+    printf( "\nphone number: \"%s\"\nmessage: \"%s\"\n", field1, field2 );
+
+    tap_send_text( fd, field1, field2 );
+
+    lprintf( L_MESG, "wait for ACK, got: " );
+    count=0;
+    ack=0;
+
+    bl=0;
+
+    while( count < 5 )
+    {
+        if ( wait_for_input( fd, 20000 ) )
+        {
+	    read( fd, &ch, 1 );
+	    lputc( L_MESG, ch );
+
+	    if ( ch == CR )
+	    {
+		if ( bl <= 0 ) continue; 	/* empty buffer */
+
+		if ( buf[bl-1] == ACK )		/* success!! */
+		{
+		    printf( "got ACK -> short message successfully sent.\n" );
+		    break;
+		}
+
+		/* print text messages */
+		buf[bl]=0;
+		printf( "--> \"%s\"\n", buf );
+		bl=0;
+		continue;
+	    }
+
+	    if ( bl>sizeof(buf)-10 )		/* paranoia check */
+	    {
+		lprintf( L_FATAL, "buffer overrun, bl=%d\n", bl );
+		return -1;
+	    }
+	    
+	    buf[bl++]=ch;
+
+	    if ( ch == NAK )			/* failure */
+	    {
+		lprintf( L_ERROR, "got NAK... huh?? anyway, going on" );
+		printf( "got NAK -> message was NOT sent!\n" );
+		break;
+	    }
+	}
+	else
+	{
+	    lprintf( L_MESG, "got timeout, going on..." );
+	    printf( "got TIMEOUT -> message was (possibly) NOT sent!\n" );
+	    count++;
+	    break;
+	}
+    }
+    return 0;
+}
+
+int ucp_send_string( int fd, char * string )
+{
+static int trn=1;		/* transaction number */
+
+unsigned int l, chksum;
+char buf[1024];
+
+    sprintf( buf, "%c%02d/%05d/%s/", STX, trn++, strlen(string)+12, string );
+	
+    chksum=0;
+    for( l=1; buf[l]; l++) chksum+=(unsigned) buf[l];
+
+    sprintf( &buf[l], "%02X%c", (chksum & 0xff), ETX );
+
+    lprintf( L_MESG, "ucp_s_s: send '%s'.", buf );;
+
+    if ( fd >= 0 )
+    {
+	if ( write( fd, buf, strlen(buf)) != strlen(buf) )
+	{
+	    lprintf( L_ERROR, "ucp_s_s: write failed" );
+	    return ERROR;
+	}
+    }
+    return NOERROR;
+}
+
+int ucp_send_message( int fd, char * r, char * text )
+{
+    char buf[800], ch;
+    int l, count;
+
+    /*!!! length checks */
+
+    printf( "\nphone number: \"%s\"\nmessage: \"%s\"\n", r, text );
+
+    sprintf( buf, "O/01/%s///3/", r );
+    l = strlen( buf );
+
+    while( *text && l<sizeof(buf)-10 )
+    {
+	ch=*(text++);
+	switch( ch )			/* special rules */
+	{
+	    case '$': ch=0x02; break;
+	    case '': ch=0x1e; break;
+	    case '@': ch=0x5f; break;
+	    case '': ch=0x5e; break;
+	    case '': ch=0x7e; break;
+	    case '^': ch=0x5d; break;
+	}
+	sprintf( &buf[l], "%02X", (unsigned) ch );
+	l+=2;
+    }
+
+    if ( ucp_send_string( fd, buf ) == ERROR ) return ERROR;
+
+    /* wait for ACK */
+    lprintf( L_NOISE, "message sent, waiting for ACK, got: " );
+    count=0; l=0;
+    while( count<10 )		/*!!! higher timeout for QUIX */
+    {
+	if ( !wait_for_input( fd, 3000 ) ) 
+		{ lputs( L_NOISE, "<T>" ); count++; continue; }
+
+	if ( read( fd, &ch, 1 ) != 1 )
+	{
+	    lprintf( L_ERROR, "ucp_s_m: read failed" ); return ERROR;
+	}
+
+	lputc( L_NOISE, ch );
+
+        if ( ch == STX ) l=0;		/* start of text */
+	buf[l++]=ch;
+	if ( ch == ETX ) break;
+    }
+
+    lprintf( "break, count=%d, ch=0x%02x", count, ch );
+
+    if ( buf[10] != 'R' || buf[15] != 'A' )
+    {
+	printf( "got NAK -> message was NOT sent!\n" );
+	return ERROR;
+    }
+
+    printf( "got ACK -> short message successfully sent.\n" );
+    return NOERROR;
+}
+
+static int sm_timeout;
+RETSIGTYPE sm_sigalarm( SIG_HDLR_ARGS )
+{
+    lprintf( L_WARN, "sm_sigalarm: got timeout" );
+    sm_timeout = TRUE;
+}
+
+/* send data SLOW (with 1/10 sec. delay between each byte), for
+ * the SMSC of Deutsche Telekom, which can't take characters back-to-back
+ */
+void slowsend( int fd, char * buf, int len )
+{
+    lprintf( L_JUNK, "slowsend: " );
+    while( len > 0 )
+    {
+	delay(50);
+	lputc( L_JUNK, buf[0] );
+	write( fd, buf, 1 );
+	buf++; len--;
+    }
+}
+
+int cityruf_send_message( int fd, char * r, char * text )
+{
+    char buf[800], ibuf[800], ch;
+    int l, count, rx;
+
+    signal( SIGALRM, sm_sigalarm );
+#ifdef HAVE_SIGINTERRUPT
+    siginterrupt( SIGALRM, TRUE );
+#endif
+    sm_timeout = FALSE;
+    alarm(30);
+
+    /*!!! length checks */
+
+    printf( "\nphone number: \"%s\"\nmessage: \"%s\"\n", r, text );
+    lprintf( L_NOISE, "cityruf, got:" );
+
+    count=0;
+    rx=0;
+    while( ( l = read( fd, &ch, 1 ) ) == 1 && ! sm_timeout && rx<sizeof(ibuf) )
+    {
+	lputc( L_NOISE, ch );
+	ibuf[rx++] = ch;
+
+	if ( ch == ' ' && ibuf[rx-2] == '>' )
+	{
+	    switch( count++ )
+	    {
+		case 0:		/* phone number */
+		  sprintf( buf, "%s\r", r ); 
+		  lprintf( L_NOISE, "#0: send number '%s'", buf );
+		  slowsend( fd, buf, strlen(buf) );
+		  break;
+		case 1:		/* message */
+		  sprintf( buf, "%s\r", text ); 
+		  lprintf( L_NOISE, "#1: send messi (len=%d)", strlen(buf) );
+		  slowsend( fd, buf, strlen(buf) );
+		  break;
+		case 2:		/* "absenden?" */
+		  sprintf( buf, "ja\r" ); 
+		  lprintf( L_NOISE, "#2: sent ACK '%s'", buf );
+		  slowsend( fd, buf, strlen(buf) );
+		  break;
+	    }
+	    lprintf( L_NOISE, "got: " );
+	    rx=0;
+	}
+
+	if ( ch == '.' && rx > 6 && 
+	      strncmp( &ibuf[rx-6], "Anruf.", 6 ) == 0 )
+	{
+	    lprintf( L_MESG, "*success*, bye" );
+	    break;
+	}
+	if ( ch == 'R' && rx > 10 &&
+	      strncmp( &ibuf[rx-10], "NO CARRIER", 10 ) == 0 )
+	{
+	    lprintf( L_MESG, "missed end-of-message?!?" );
+	    l=0;
+	    break;
+	}
+    }
+    alarm(0);
+
+    if ( l < 1 || sm_timeout )				/* error? */
+    {
+	printf( "protocol error -> message most likely  not sent.\n");
+	lprintf( L_ERROR, "cityruf: read() returned error" );
+	return ERROR;
+    }
+
+    printf( "got ACK -> short message successfully sent.\n" );
+    return NOERROR;
+}
+
+
+int initial_handshake( int fd, prot_type proto )
+{
+int count, ack;
+char buf;
+
+    if ( proto != Ptap )
+    {
+	lprintf( L_MESG, "no initial handshake necessary" );
+	return 0;
+    }
+
+    lprintf( L_MESG, "TAP, initial handshake, got: " );
+
+    count=ack=0;
+    while( count < 10 )
+    {
+        if ( wait_for_input( fd, 2000 ) )
+        {
+	    read( fd, &buf, 1 );
+	    lputc( L_MESG, buf );
+
+	    if ( buf == '=' ) 	/* "ID=" */
+	    {
+		lprintf( L_MESG, "sending <esc>PG1<cr>, got: " );
+		write( fd, "\x1bPG1\x0d", 5 );
+		ack=0;
+	    }
+
+	    if ( buf == '\x1b' && ack == 0 ) ack++;
+	    if ( buf == '[' && ack == 1 ) ack++;
+	    if ( buf == 'p' && ack == 2 ) ack++;
+	    if ( buf == CR  && ack == 3 ) break;
+	}
+	else
+	{
+	    lputs( L_MESG, "<send [CR]>" );
+	    write( fd, "\x0d", 1 );
+	    count++;
+	}
+    }
+
+    lprintf( L_MESG, "count=%d, ack=%d", count, ack );
+
+    if ( count >= 10 ) return -1;
+
+    return 0;
+}
+
+/* final handshake before hanging up -- only TAP needs this 
+ */
+int final_handshake( int fd, prot_type proto )
+{
+char ch;
+
+    if ( proto == Ptap )
+    {
+	lprintf( L_MESG, "TAP, last message sent, send <EOT><CR>, got: " );
+	write( fd, "\x04\x0d", 2 );		/* <EOT><CR> */
+
+	while( wait_for_input( fd, 2000 ) && read( fd, &ch, 1 ) == 1 )
+	{
+	    lputc( L_MESG, ch );
+	}
+    }
+    return 0;
+}
+
+/* send all jobs queued for a given provider "pt" */
+int send_jobs( int pt )
+{
+int fd;
+TIO tio;
+char * l;
+char dialstring[200];
+int i;
+
+    lprintf( L_MESG, "connecting to provider '%s'", prov[pt].name );
+    printf( "\nConnecting to %s...\n", prov[pt].name );
+
+    fd = open( Device, O_RDWR | O_NDELAY );
+
+    if ( fd < 0 )
+    {
+	lprintf( L_ERROR, "can't open %s", Device );
+	perror( "open" );
+	return ERROR;
+    }
+
+    fcntl( fd, F_SETFL, O_RDWR );
+
+    if ( tio_get( fd, &tio ) == ERROR )
+    {
+	perror( "tio_get" ); close(fd); return ERROR;
+    }
+    tio_mode_sane(&tio,TRUE);
+    tio_set_speed(&tio, 38400);
+    tio_mode_raw(&tio);
+
+    /* go to 7E1 for TAP and UCP */
+
+    if ( prov[pt].proto != Pcityruf )
+    {
+	tio.c_iflag |= ISTRIP | IXON | IXANY;
+
+	tio.c_cflag &= ~(CSIZE | PARODD);
+	tio.c_cflag |= CS7 | PARENB;
+
+    }
+    if ( tio_set( fd, &tio ) == ERROR )
+    {
+	perror( "tio_set" ); close(fd); return ERROR;
+    }
+
+    if ( mdm_command( prov[pt].modem_init, fd ) == ERROR )
+    {
+	fprintf( stderr, "can't initialize modem. ABORT.\n" );
+	close(fd); return ERROR;
+    }
+
+    /* dial up provider... */
+    sprintf( dialstring, "ATX3DT0W%s", prov[pt].dialup_num );
+    mdm_send( dialstring, fd );
+
+    /* wait for connect */  /*!!!! TIMEOUT */
+    while( 1 )
+    {
+	l = mdm_get_line(fd);
+	if ( l == NULL ) break;
+
+	lprintf( L_NOISE, "mdm: read '%s'", l );
+
+	if ( strcmp( l, "NO CARRIER" ) == 0 )  { l = NULL; break; }
+	if ( strcmp( l, "NO DIALTONE" ) == 0 ) { l = NULL; break; }
+	if ( strcmp( l, "ERROR" ) == 0 )       { l = NULL; break; }
+	if ( strcmp( l, "BUSY" ) == 0 )        { l = NULL; break; }
+	if ( strncmp( l, "CONNECT", 7 ) == 0 ) break;
+    }
+
+    if ( l == NULL )
+    {
+	fprintf( stderr, "dialup failed\n" ); close(fd); 
+	return ERROR;
+    }
+
+    lprintf( L_MESG, "modem connection established." );
+
+    /* handshake phase */
+    if ( initial_handshake( fd, prov[pt].proto ) < 0 )
+    {
+	fprintf( stderr, "can't initiate succesful handshake with provider!\n");
+	close(fd); return ERROR;
+    }
+
+    /* initial handshake successful, send SMS */
+    printf( "handshake with %s service successful, now sending...\n",
+	       prov[pt].proto == Ptap? "TAP": 
+		 (prov[pt].proto == Pcityruf? "Cityruf" : "UCP") );
+
+    for ( i=0; i<nummsg; i++)
+    {
+	if ( messi[i].prov == pt )	/* provider connected to */
+	{
+	    switch( prov[pt].proto )
+	    {
+		case Ptap:
+		    tap_send_message( fd, messi[i].number, messi[i].msg );
+		    break;
+		case Pucp1:
+		    ucp_send_message( fd, messi[i].number, messi[i].msg );
+		    break;
+		case Pcityruf:
+		    cityruf_send_message( fd, messi[i].number, messi[i].msg );
+		    break;
+		default:
+		    fprintf( stderr, "pt=%d, yet unsupported protocol %d\n",
+			     pt, prov[pt].proto );
+		    break;
+	    }
+	}		/* if (correct provider) */
+    }			/* for (i=all messages) */
+
+    if ( final_handshake( fd, prov[pt].proto ) < 0 )
+    {
+	fprintf( stderr, "final handshake failed - messages propably not sent\r\n" );
+	close(fd); return ERROR;
+    }
+    
+    close(fd);
+    return SUCCESS; 
+}
+
+/*
+ * read file with all messages "in queue"...
+ */
+int read_messages( char * name )
+{
+    char * line, * key;
+    FILE * fp = fopen( name, "r" );
+
+    if ( fp == NULL )
+    {
+	lprintf( L_ERROR, "can't open %s", name );
+	perror( "error opening message file" );
+	return SUCCESS;
+    }
+
+    nummsg = 0;
+
+    while ( nummsg < MAXMSG && 
+	    ( line = fgetline( fp )) != NULL )
+    {
+	char * p = line;
+	int i;
+
+	norm_line( &p, &key );
+	for ( i=0; prov[i].name != NULL; i++ )	/* search prov. in list */
+	{
+	    if ( strcmp( prov[i].name, key ) == 0 )	/* found */
+	    {
+		norm_line( &p, &key );		/* get phone number */
+		messi[nummsg].prov = i;
+		messi[nummsg].number = strdup( key );
+		messi[nummsg].msg    = strdup( p );
+		break;
+	    }
+	}
+
+	if ( prov[i].name == NULL )
+	{
+	    fprintf( stderr, "ERROR: can't find provider '%s' (%s %s)\n",
+			key, key, p ); 
+	    continue;
+	}
+
+	nummsg++;
+    }
+    fclose( fp );
+    return NOERROR;
+}
+
+
+int main( int argc, char ** argv )
+{
+int i, pt;
+
+    log_init_paths( argv[0], "/tmp/tap.log", NULL );
+    log_set_llevel(5);
+
+    if ( argc != 2 )
+    {
+	fprintf( stderr, "Usage: tap <filename>\n" ); exit(1);
+    }
+
+    /* read messages from file in argv[1] */
+    if ( read_messages( argv[1] ) != SUCCESS )
+    {
+	fprintf( stderr, "can't process %s, exiting.\n", argv[1] ); exit(2);
+    }
+
+    if ( makelock( Device ) != SUCCESS )
+    {
+	fprintf( stderr, "device %s is locked, abort.\n", Device );
+	exit(17);
+	/* FIXME */
+    }
+
+    for ( pt=0; prov[pt].name != NULL; pt++ )
+    {
+	for( i=0; i<nummsg; i++ ) { if ( messi[i].prov == pt ) break; }
+
+	if ( i<nummsg )		/* found message for that provider */
+	{
+	    send_jobs(pt); sleep(5);
+	    /*!!! ERROR CODES!!! */
+	}
+    }
+    
+    rmlocks();
+    return 0;
+ 
+}
+
+
diff -urP mgetty-1.1.22/tio.c mgetty-current/tio.c
--- mgetty-1.1.22/tio.c	Sat Oct 23 23:56:57 1999
+++ mgetty-current/tio.c	Thu Nov 16 11:41:39 2000
@@ -1,4 +1,4 @@
-#ident "$Id$ Copyright (c) 1993 Gert Doering"
+#ident "$Id$ Copyright (c) 1993 Gert Doering"
 
 /* tio.c
  *
@@ -215,7 +215,8 @@
 
     for ( i=0; speedtab[i].cbaud != 0; i++ )
     {
-	if ( speedtab[i].nspeed == speed ) symspeed = speedtab[i].cbaud;
+	if ( speedtab[i].nspeed == speed ) 
+		{ symspeed = speedtab[i].cbaud; break; }
     }
 
     if ( symspeed == 0 )
diff -urP mgetty-1.1.22/tools/mid.c mgetty-current/tools/mid.c
--- mgetty-1.1.22/tools/mid.c	Sat Apr  3 14:45:14 1999
+++ mgetty-current/tools/mid.c	Thu Nov 16 11:41:44 2000
@@ -1,4 +1,4 @@
-#ident "$Id$ Copyright (c) Gert Doering"
+#ident "$Id$ Copyright (c) Gert Doering"
 
 /* mid.c
  *
@@ -21,7 +21,8 @@
 #include "policy.h"
 #include "tio.h"
 
-char * query_strings[] = { "ATI",  "ATI0", "ATI1", "ATI2", "ATI3", "ATI4",
+char * query_strings[] = { "ATE1Q0V1", 
+			   "ATI",  "ATI0", "ATI1", "ATI2", "ATI3", "ATI4",
                            "ATI5", "ATI6", "ATI7", "ATI8", "ATI9", "ATI10",
                            "ATI11","ATI12","ATI13","ATI14","ATI15",
 			   "AT+FCLASS=?",
Only in mgetty-1.1.22/voice: .makefile
diff -urP mgetty-1.1.22/voice/ChangeLog mgetty-current/voice/ChangeLog
--- mgetty-1.1.22/voice/ChangeLog	Thu Aug 10 22:37:22 2000
+++ mgetty-current/voice/ChangeLog	Thu Nov 16 11:41:45 2000
@@ -1,3 +1,93 @@
+Sat Oct 14 11:06:01 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
+
+	* All of below is 0.9.21
+
+	* Completely reworked the way the special case Supra56ePRO
+	works, since it was causing timeouts/delay at initialization
+	time for both the TP560 Data/Fax/Voice 56K Modem and
+	the good ol' 1496. (BTW mine just broke, so I hope that
+	others will test it. Symptoms: switch on with CD/OH/DSR/CTS
+	light. TXD blinks when typing on keyboard (e.g. with cu
+	with DTR/RTS/etc set), global fw reset doesn't work anymore).
+
+Sat Sep 16 18:38:14 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
+
+	* All of below is 0.9.19
+
+	* Added detection of modem ``TP560 Data/Fax/Voice 56K Modem'',
+	with friendly testing from Zsolt KOZAK <kozakzs@webigen.com>.
+	Note that that modem has buggy ATI3 handling, and this will
+	cause a timeout, which will be recovered. The test was done
+	at speed 115200. [ well infact this was not a buggy firmware,
+	see above ]
+
+Tue Sep 12 23:09:42 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
+
+	* All of below is 0.9.18
+
+	* Added new modem type Supra56ePRO, strongly based on
+	Supra.c; submitted by Rojhalat Ibrahim, roschi@ribrahim.de.
+	It seems we had to also implement ATI3 detection.
+	
+Mon Sep 11 13:30:25 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
+	
+	* libvoice/ISDN4Linux.c: using correct return code (cosmetic)
+	in answer_phone().
+
+	* libvoice/US_Robotics.c: using correct return code (cosmetic)
+	in answer_phone().
+
+	* vgetty/answer.c: if modem-specific code returns fax, forward
+ 	that to the mgetty caller. Note that mgetty doesn't yet support
+ 	this fully.
+	
+Sun Sep 10 09:36:26 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
+
+	* libvoice/V253modem.c: fix Kompressionmethod default setting
+	(gcc warning; could lead to Kompressionmethod 0 in an uncontrolled
+	way). Fixed comment for compression method 9.
+
+	* vgetty/answer.c: voice message file with a more unique name
+	(with timestamp).
+
+Sat Sep  9 09:57:31 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
+
+	* All of below is 0.9.17
+
+	* libvoice/Elsa.c: minor fix with no consequence so that
+	gcc doesn't spit out a `warning: `/*' within comment'
+	warning.
+
+	* pvftools/pvftormd.c: patch from Mark K. Kim <markkim@email.com>
+	fixing the wrong assumption that the compression method is
+	the bits-per-sampling rate, which is wrong for USR (GSM).
+	I find this change a bit bizarre (why hasn't anyone reported this),
+	and it could be a firmware problem. Well, let's see what it
+	breaks and hope people scream loudly.
+
+	* libvoice/V253modem.c: patch from Juergen Kosel <Juergen.Kosel@gmx.de>
+	implementing new voiceformats, and check_rmd_adequation() for
+	Elsa compatibility. Caller ID and distinctive ringing; setting
+	defaults (silence sensitivity; timeout). Added CVS ID. Note that
+	this version has a gcc warning; notified Juergen.
+ 	
+	* libvoice/Elsa.c: patch from Juergen Kosel <Juergen.Kosel@gmx.de>
+	fixing AT+VRN and adding comments about VLS.
+
+	* pvftools/rmdtopvf.c: patch from Juergen Kosel <Juergen.Kosel@gmx.de>;
+	implements header management for some new voice formats.
+
+	* libvoice/ZyXEL_Omni56k.c: fixed by gert; fix from Richard L. Hamilton
+ 	(rlhamil@smart.net); ATS40= commande shall not contain spaces.
+
+	* libvoice/IS_101.c: fixed by gert; fix from Andrew Morris
+ 	(Andrew.Morris@cnpl.enbridge.com); fix to watchdog change;
+	bug introduced in 0.9.16. Would never reset the watchdog
+	after the first reset.
+
+	* voice.conf-dist: fixed by gert; comment that the speed
+	definition must match mgetty's.
+	
 Thu Aug 10 08:14:50 2000  Marc SCHAEFER  <schaefer@vulcan.alphanet.ch>
 
 	* All of below is 0.9.16
diff -urP mgetty-1.1.22/voice/include/hardware.h mgetty-current/voice/include/hardware.h
--- mgetty-1.1.22/voice/include/hardware.h	Thu Aug 10 22:37:22 2000
+++ mgetty-current/voice/include/hardware.h	Thu Nov 16 11:41:46 2000
@@ -3,7 +3,7 @@
  *
  * Defines the structure with data and routines for the hardware drivers.
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -98,6 +98,7 @@
 extern voice_modem_struct IS_101;
 extern voice_modem_struct ISDN4Linux;
 extern voice_modem_struct Supra;
+extern voice_modem_struct Supra56ePRO;
 extern voice_modem_struct Multitech_2834ZDXv;
 extern voice_modem_struct Multitech_5634ZBAV;
 extern voice_modem_struct Multitech_5600ZDXv;
diff -urP mgetty-1.1.22/voice/include/version.h mgetty-current/voice/include/version.h
--- mgetty-1.1.22/voice/include/version.h	Thu Aug 10 22:37:23 2000
+++ mgetty-current/voice/include/version.h	Thu Nov 16 11:41:46 2000
@@ -1 +1 @@
-char *vgetty_version = "experimental test release 0.9.16 / 10Aug00";
+char *vgetty_version = "experimental test release 0.9.21 / 15Nov00";
diff -urP mgetty-1.1.22/voice/libutil/test_wildmat.c mgetty-current/voice/libutil/test_wildmat.c
--- mgetty-1.1.22/voice/libutil/test_wildmat.c	Wed Sep  9 20:50:57 1998
+++ mgetty-current/voice/libutil/test_wildmat.c	Thu Nov 16 11:41:48 2000
@@ -4,8 +4,6 @@
 
 #include <stdio.h>
 
-/* Yes, we use gets not fgets.  Sue me. */
-extern char     *gets();
 extern int wildmat(char *text, char *p, int length);
 
 int
@@ -21,12 +19,12 @@
     for ( ; ; ) {
         printf("\nEnter pattern:  ");
         (void)fflush(stdout);
-        if (gets(p) == NULL || p[0] == '\0')
+        if ( fgets(p, sizeof(p)-1, stdin) == NULL || p[0] == '\0')
             break;
         for ( ; ; ) {
             printf("Enter text:  ");
             (void)fflush(stdout);
-            if (gets(text) == NULL)
+            if (fgets(text, sizeof(text)-1, stdin) == NULL)
                 exit(0);
             if (text[0] == '\0')
                 /* Blank line; go back and get a new pattern. */
diff -urP mgetty-1.1.22/voice/libvoice/Elsa.c mgetty-current/voice/libvoice/Elsa.c
--- mgetty-1.1.22/voice/libvoice/Elsa.c	Thu Aug 10 22:33:45 2000
+++ mgetty-current/voice/libvoice/Elsa.c	Thu Nov 16 11:41:48 2000
@@ -9,7 +9,7 @@
  * You have set port_timeout in voice.conf to a minimum of 15
  * if you use 38400 Baud
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -85,9 +85,9 @@
       * before modem assumes phone has been answered.
       */
      sprintf(buffer,
-             "AT+VRA=%d+VRN=%d",
-             cvd.ringback_goes_away.d.i,
-             cvd.ringback_never_came.d.i);
+             "AT+VRA=%d;+VRN=%d",
+             cvd.ringback_goes_away.d.i,         /* 1/10 seconds */
+             cvd.ringback_never_came.d.i/10);    /* seconds */
 
      if (voice_command(buffer, "OK") != VMA_USER_1)
           lprintf(L_WARN, "setting ringback delay didn't work");     
@@ -179,7 +179,7 @@
                return(OK);
           case DIALUP_LINE:
                lprintf(L_JUNK, "%s: _DIALUP: (%d)", voice_modem_name, device);
-               voice_command("AT#VLS=4", "OK");
+               voice_command("AT#VLS=4", "OK");   /* This is DIALUP_WITH_INT_SPEAKER ! Look at contrib/Steffen_Klupsch-new-set-device-modes */
                return(OK);
           case INTERNAL_MICROPHONE:
                lprintf(L_JUNK, "%s: _INT_MIC: (%d)", voice_modem_name, device);
diff -urP mgetty-1.1.22/voice/libvoice/ISDN4Linux.c mgetty-current/voice/libvoice/ISDN4Linux.c
--- mgetty-1.1.22/voice/libvoice/ISDN4Linux.c	Sat Dec  4 18:00:55 1999
+++ mgetty-current/voice/libvoice/ISDN4Linux.c	Thu Nov 16 11:41:48 2000
@@ -37,7 +37,7 @@
  *   ATS18=1 OK
  * there your isdn-tty won't pick up data calls.
  *
- * $Id$
+ * $Id$
  * 
  */
 
@@ -94,7 +94,7 @@
      if (is_voicecall)
           return(IS_101_answer_phone());
 
-     return(OK);
+     return(VMA_CONNECT);
      }
 
 static int ISDN4Linux_init(void)
diff -urP mgetty-1.1.22/voice/libvoice/IS_101.c mgetty-current/voice/libvoice/IS_101.c
--- mgetty-1.1.22/voice/libvoice/IS_101.c	Thu Aug 10 22:33:45 2000
+++ mgetty-current/voice/libvoice/IS_101.c	Thu Nov 16 11:41:48 2000
@@ -5,7 +5,7 @@
  * follow the IS-101 interim standard for voice modems. Since the commands
  * are set in the modem structure, it should be quite generic.
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -588,6 +588,7 @@
                {
                lprintf(L_JUNK, "%s: <VOICE DATA %d bytes>", program_name, count);
                reset_watchdog();
+               watchdog_reset = time(NULL) + (cvd.watchdog_timeout.d.i / 2);
                count = 0;
                }
 
@@ -732,6 +733,7 @@
                     lprintf(L_JUNK, "%s: <VOICE DATA %d bytes>", voice_modem_name,
                      count);
                     reset_watchdog();
+                    watchdog_reset = time(NULL) + (cvd.watchdog_timeout.d.i / 2);
                     count = 0;
                     }
 
diff -urP mgetty-1.1.22/voice/libvoice/Makefile mgetty-current/voice/libvoice/Makefile
--- mgetty-1.1.22/voice/libvoice/Makefile	Thu Aug 10 22:33:45 2000
+++ mgetty-current/voice/libvoice/Makefile	Thu Nov 16 11:41:48 2000
@@ -3,7 +3,7 @@
 #
 # This is the Makefile for libvoice.
 #
-# $Id$
+# $Id$
 #
 
 VOICEOBJS=analyze.o close.o command.o detect.o event.o flush.o \
@@ -12,7 +12,7 @@
 	Cirrus_Logic.o Digi_RAS.o Dolphin.o Dr_Neuhaus.o Elsa.o V253modem.o IS_101.o \
 	ISDN4Linux.o Multitech_2834.o Rockwell.o Sierra.o Supra.o UMC.o \
 	US_Robotics.o ZyXEL_1496.o ZyXEL_2864.o ZyXEL_Omni56K.o \
-	Multitech_5634.o Multitech_5600ZDXv.o
+	Multitech_5634.o Multitech_5600ZDXv.o Supra56ePRO.o
 
 .c.o:
 	$(CC) $(CFLAGS) -c $*.c
diff -urP mgetty-1.1.22/voice/libvoice/Supra56ePRO.c mgetty-current/voice/libvoice/Supra56ePRO.c
--- mgetty-1.1.22/voice/libvoice/Supra56ePRO.c	Thu Jan  1 01:00:00 1970
+++ mgetty-current/voice/libvoice/Supra56ePRO.c	Thu Nov 16 11:41:49 2000
@@ -0,0 +1,260 @@
+/*
+ * Supra56ePRO.c
+ *
+ * This file contains a slightly changed version of the Supra driver
+ * hacked up so it works on my SupraExpress 56e PRO. 
+ * (by Rojhalat Ibrahim, roschi@ribrahim.de)
+ *
+ * it was lightly hack by Rob Ryan (rr2b@pacbell.net) from the Elsa
+ * version written by Karlo Gross kg@orion.ddorf.rhein-ruhr.de
+ * by using the old version from Stefan Froehlich and the
+ * help from Marc Eberhard.
+ * You have set port_timeout in voice.conf to a minimum of 15
+ * if you use 38400 Baud
+ *
+ * $Id$
+ *
+ */
+
+#include "../include/voice.h"
+
+static int Supra_set_device (int device);
+
+static int Supra_init (void)
+     {
+     char buffer[VOICE_BUF_LEN];
+
+     reset_watchdog();
+     voice_modem_state = INITIALIZING;
+     lprintf(L_MESG, "initializing Supra 56e PRO voice modem");
+
+     sprintf(buffer, "AT#VSP=%1u", cvd.rec_silence_len.d.i);
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set silence_len VSP");
+
+     sprintf(buffer, "AT#VSD=0");
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set VSD=0");
+
+     sprintf(buffer, "AT#VBS=4");                 /* for 38400 */
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set VBS=4");
+
+     sprintf(buffer, "AT#BDR=16");                /* for 38400 */
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set BDR=16");
+
+     sprintf(buffer, "AT#VTD=3F,3F,3F");
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set VTD=3F");
+
+     sprintf(buffer, "AT#VSS=%1u", cvd.rec_silence_threshold.d.i * 3 / 100);
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set silence threshold VSS");
+
+     sprintf(buffer, "ATS30=60");       /* fuer 38400 */
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set S30");
+
+     if (cvd.transmit_gain.d.i == -1)
+          cvd.transmit_gain.d.i = 50;
+
+     sprintf(buffer, "AT#VGT=%d", cvd.transmit_gain.d.i * 3 / 100 +
+      128);
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set speaker volume");
+
+     if (cvd.receive_gain.d.i == -1)
+          cvd.receive_gain.d.i = 50;
+
+#ifdef NOT_IMPLENTED
+     sprintf(buffer, "AT#VGR=%d", 0);
+
+     if (voice_command(buffer, "OK") != VMA_USER_1)
+          lprintf(L_WARN, "can't set record volume");
+#endif
+     
+     voice_modem->set_device(DIALUP_LINE);
+
+     if ((cvd.do_hard_flow.d.i) && (voice_command("AT&K3", "OK") ==
+      VMA_USER_1) )
+          {
+          TIO tio;
+          tio_get(voice_fd, &tio);
+          tio_set_flow_control(voice_fd, &tio, FLOW_HARD);
+          tio_set(voice_fd, &tio);
+          }
+     else
+          lprintf(L_WARN, "can't turn on hardware flow control");
+
+     voice_modem_state = IDLE;
+     return(OK);
+     }
+
+static int Supra_set_compression (int *compression, int *speed, int *bits)
+     {
+     reset_watchdog();
+
+     if (*compression == 0)
+          *compression = 2;
+
+     if (*speed == 0)
+          *speed = 7200;
+
+     /* supra express has 7200 and 11025 */
+     if (*speed != 7200 && *speed != 11025)
+          {
+          lprintf(L_WARN, "%s: Illegal sample speed (%d)",
+           voice_modem_name, *speed);
+          return(FAIL);
+          };
+
+     if (*compression == 2)
+          {
+          voice_command("AT#VBS=2", "OK");
+          *bits = 2;
+          return(OK);
+          }
+     if (*compression == 3)
+          {
+          voice_command("AT#VBS=3", "OK");
+          *bits = 3;
+          return(OK);
+          }
+     if (*compression == 4)
+          {
+          voice_command("AT#VBS=4", "OK");
+          *bits = 4;
+          return(OK);
+          }
+
+     lprintf(L_WARN, "%s: Illegal voice compression method (%d)",
+      voice_modem_name, *compression);
+     return(FAIL);
+     }
+
+static int Supra_set_device (int device)
+     {
+     reset_watchdog();
+
+     switch (device)
+          {
+          case NO_DEVICE:
+               lprintf(L_JUNK, "%s: _NO_DEV: (%d)", voice_modem_name, device);
+               voice_command("AT#VLS=0", "OK");
+               return(OK);
+          case DIALUP_LINE:
+               lprintf(L_JUNK, "%s: _DIALUP: (%d)", voice_modem_name, device);
+               voice_command("AT#VLS=4", "OK");
+	       return(OK);
+          case INTERNAL_MICROPHONE:
+	       lprintf(L_JUNK, "%s: _INT_MIC: (%d)", voice_modem_name, device);
+	       /* there is no internal mic. on the supra express 56e PRO */
+	       voice_command("AT#VLS=9", "VCON");
+	       return(OK);
+          case INTERNAL_SPEAKER:
+               lprintf(L_JUNK, "%s: _INT_SEAK: (%d)", voice_modem_name, device);
+               /* does not even work with the original diamond software */
+	       voice_command("AT#VLS=3", "VCON");
+               return(OK);
+          }
+
+     lprintf(L_WARN, "%s: Unknown device (%d)", voice_modem_name, device);
+     return(FAIL);
+     }
+
+
+static int Supra_switch_to_data_fax(char *mode)
+     {
+     if (IS_101_switch_to_data_fax(mode) != OK)
+        return(FAIL);
+	
+     if (voice_command("AT+FCLASS=2", "OK") != VMA_USER_1)
+        return(FAIL);
+	
+     return(OK);
+     }
+
+
+static char Supra_pick_phone_cmnd[] = "ATA";
+static char Supra_pick_phone_answr[] = "VCON|+VCON";
+static char Supra_beep_cmnd[] = "AT#VTS=[%d,0,%d]";
+#define     Supra_beep_timeunit 100
+static char Supra_hardflow_cmnd[] = "AT&K3";
+static char Supra_softflow_cmnd[] = "AT";
+static char Supra_start_play_cmnd[] = "AT#VTX";
+static char Supra_intr_play_cmnd[] = {DLE, CAN, 0x00};
+static char Supra_intr_play_answr[] = "OK|VCON";
+static char Supra_stop_play_answr[] = "OK|VCON";
+static char Supra_start_rec_cmnd[] = "AT#VRX";
+static char Supra_stop_rec_cmnd[] = "!";
+static char Supra_stop_rec_answr[] = "OK|VCON";
+static char Supra_switch_mode_cmnd[] = "AT#CLS=";
+static char Supra_ask_mode_cmnd[] = "AT#CLS?";
+
+voice_modem_struct Supra56ePRO =
+    {
+    "SupraExpress 56e PRO",
+    "Rockwell",
+     (char *) Supra_pick_phone_cmnd,
+     (char *) Supra_pick_phone_answr,
+     (char *) Supra_beep_cmnd,
+     (char *) IS_101_beep_answr,
+              Supra_beep_timeunit,
+     (char *) Supra_hardflow_cmnd,
+     (char *) IS_101_hardflow_answr,
+     (char *) Supra_softflow_cmnd,
+     (char *) IS_101_softflow_answr,
+     (char *) Supra_start_play_cmnd,
+     (char *) IS_101_start_play_answer,
+     (char *) IS_101_reset_play_cmnd,
+     (char *) Supra_intr_play_cmnd,
+     (char *) Supra_intr_play_answr,
+     (char *) IS_101_stop_play_cmnd,
+     (char *) Supra_stop_play_answr,
+     (char *) Supra_start_rec_cmnd,
+     (char *) IS_101_start_rec_answr,
+     (char *) Supra_stop_rec_cmnd,
+     (char *) Supra_stop_rec_answr,
+     (char *) Supra_switch_mode_cmnd,
+     (char *) IS_101_switch_mode_answr,
+     (char *) Supra_ask_mode_cmnd,
+     (char *) IS_101_ask_mode_answr,
+     (char *) IS_101_voice_mode_id,
+     (char *) IS_101_play_dtmf_cmd,
+     (char *) IS_101_play_dtmf_extra,
+     (char *) IS_101_play_dtmf_answr,
+    &IS_101_answer_phone,
+    &IS_101_beep,
+    &IS_101_dial,
+    &IS_101_handle_dle,
+    &Supra_init,
+    &IS_101_message_light_off,
+    &IS_101_message_light_on,
+    &IS_101_start_play_file,
+    NULL,
+    &IS_101_stop_play_file,
+    &IS_101_play_file,
+    &IS_101_record_file,
+    &Supra_set_compression,
+    &Supra_set_device,
+    &IS_101_stop_dialing,
+    &IS_101_stop_playing,
+    &IS_101_stop_recording,
+    &IS_101_stop_waiting,
+    &Supra_switch_to_data_fax,
+    &IS_101_voice_mode_off,
+    &IS_101_voice_mode_on,
+    &IS_101_wait,
+    &IS_101_play_dtmf,
+    &IS_101_check_rmd_adequation,
+    0
+    };
diff -urP mgetty-1.1.22/voice/libvoice/US_Robotics.c mgetty-current/voice/libvoice/US_Robotics.c
--- mgetty-1.1.22/voice/libvoice/US_Robotics.c	Thu Aug 10 22:33:45 2000
+++ mgetty-current/voice/libvoice/US_Robotics.c	Thu Nov 16 11:41:48 2000
@@ -24,7 +24,7 @@
  * A very good US Robotics technical reference manual is available
  * at: http://www.alliancedatacom.com/us-robotics-manuals.htm (not a typo).
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -68,8 +68,8 @@
       * 
       */
       
-     if (IS_101_beep(frequency, length) != OK)
-          return(FAIL);
+     if (IS_101_beep(frequency, length) != VMA_OK)
+          return(VMA_ERROR);
 
      /*  --- "Luca Olivetti" <luca@olivetti.dhis.org>
       *     A long time ago I introduced a workaround in US_Robotics.c to a
@@ -84,12 +84,12 @@
       *     hook -- it beeps with the *external* speaker though). 
       */ 
 
-     if (internal_speaker_used) return(OK);
+     if (internal_speaker_used) return(VMA_OK);
           
      if (IS_101_answer_phone() != VMA_OK)
-          return(FAIL);
+          return(VMA_ERROR);
      
-     return(OK);
+     return(VMA_OK);
 } 
 
 static int USR_init(void)
diff -urP mgetty-1.1.22/voice/libvoice/V253modem.c mgetty-current/voice/libvoice/V253modem.c
--- mgetty-1.1.22/voice/libvoice/V253modem.c	Thu Aug 10 22:33:58 2000
+++ mgetty-current/voice/libvoice/V253modem.c	Thu Nov 16 11:41:49 2000
@@ -3,6 +3,21 @@
  *
  * This file contains the commands for V253 complaient modems
  *
+  For this File I used the ELSA.c as template and replaced all pre-V.253 commands
+  with the commands defined in the ITU V.253 specification.
+  Newer ELSA-modems follow this specification.
+  So some ELSA-modems like the "ML 56k pro" could be used with the ELSA.c (and the old commands)
+  AND with this V253modem (But for these modems you should set sample rate in your voice.conf to 7200
+  otherwise fax/data-callingtonedetection will fail).
+  The "ML 56k FUN" and future ELSA-modems work only with this V253modem.
+
+  Because there are only V.253 commands here, this IS a GENERIC-DRIVER!
+
+  Hint: Recorded voice files are in .ub format (refer to the sox manpage about this) except the header.
+        So you can use this files with sox.
+ *
+ * $Id$
+ *
  */
 
 #include "../include/voice.h"
@@ -17,36 +32,47 @@
      voice_modem_state = INITIALIZING;
      lprintf(L_MESG, "initializing V253 voice modem");
 
+
+     /* enabling voicemode */
      sprintf(buffer, "AT+FCLASS=8");
      if (voice_command(buffer, "OK") != VMA_USER_1)
-          lprintf(L_WARN, "FCLASS=8");
-
+          lprintf(L_WARN, "could not set +FCLASS=8");
 
 
-     sprintf(buffer, "AT+VSD=%d,%d", cvd.rec_silence_threshold.d.i * 141 / 100, cvd.rec_silence_len.d.i);
+     /* set silence-sensitvity-level and silence length */
+/*
+first value of the +vsd command means:
+ 0: silence detection of/ or silencecompression with the +vsm command
+128: manufacturer default
+<128: less aggressive [more sensitive, lower noise levels considered to
+be silence].
+>128: more aggressive [less sensitive, higher noise levels considered to be silence].
 
+ */
+#if 0 /* enable this when cvd.rec_silence_threshold.d.i  is set as an absoult value
+(with default 128) instead of percent */
+     sprintf(buffer, "AT+VSD=%d,%d", cvd.rec_silence_threshold.d.i , cvd.rec_silence_len.d.i);
+#else /* until this, the sensitvity is harcoded with manufaturer default! */
+    sprintf(buffer, "AT+VSD=%d,%d", 128 , cvd.rec_silence_len.d.i);
+#endif
      if (voice_command(buffer, "OK") != VMA_USER_1)
           lprintf(L_WARN, "can't set silence threshold VSD");
 
-     sprintf(buffer, "ATS30=60");       /* fuer 38400 */
-
-     if (voice_command(buffer, "OK") != VMA_USER_1)
-          lprintf(L_WARN, "can't set S30");
-
+/* set transmit-gain manufacturer default is 128 so the vgetty default of 127 isn't far away */
      if (cvd.transmit_gain.d.i == -1)
           cvd.transmit_gain.d.i = 50;
 
-     sprintf(buffer, "AT+VGT=%d", cvd.transmit_gain.d.i * 127 / 100 +
-      128);
+     sprintf(buffer, "AT+VGT=%d", cvd.transmit_gain.d.i * 255 / 100 );
 
      if (voice_command(buffer, "OK") != VMA_USER_1)
           lprintf(L_WARN, "can't set speaker volume");
 
+/* set recieve-gain manufacturer default is 128 so the vgetty default of 127 isn't far away */
+
      if (cvd.receive_gain.d.i == -1)
           cvd.receive_gain.d.i = 50;
 
-     sprintf(buffer, "AT+VGR=%d", cvd.receive_gain.d.i * 127 / 100 +
-      128);
+     sprintf(buffer, "AT+VGR=%d", cvd.receive_gain.d.i * 255 / 100 );
 
      if (voice_command(buffer, "OK") != VMA_USER_1)
           lprintf(L_WARN, "can't set record volume");
@@ -55,13 +81,15 @@
       * before modem assumes phone has been answered.
       */
      sprintf(buffer,
-             "AT+VRA=%d+VRN=%d",
-             cvd.ringback_goes_away.d.i,
-             cvd.ringback_never_came.d.i);
+             "AT+VRA=%d;+VRN=%d",
+             cvd.ringback_goes_away.d.i,     /* 1/10 seconds */
+             cvd.ringback_never_came.d.i/10); /* seconds */
 
      if (voice_command(buffer, "OK") != VMA_USER_1)
           lprintf(L_WARN, "setting ringback delay didn't work");
 
+
+/* set hardflow */
      if ((cvd.do_hard_flow.d.i) && (voice_command("AT+IFC=2,2", "OK") ==
       VMA_USER_1) )
           {
@@ -73,6 +101,29 @@
      else
           lprintf(L_WARN, "can't turn on hardware flow control");
 
+
+     /* enable callerid (if supported) and setformat */
+     voice_command("AT+VCID=1", "OK");
+     /* mgetty supports formated callerid output */
+
+     /* set hangupcontroll */
+     voice_command("AT+VNH=0", "OK");
+     /* this means modem will hangup after is has switched to data/faxmode as normal
+        with +VNH=1 the modem doesn't make an automatic disconnect if connect fails in
+	data/faxmode so mgetty could switch back to voicemode */
+
+     /* set inactivity timer to 60seconds */
+     voice_command("AT+VIT=60", "OK");
+
+     /* enable distinctivering in pulse/pauseformat
+       this will look like this:
+DRON=20
+RING
+DROF=40
+DRON=20
+RING */
+     voice_command("AT+VDR=1,5", "OK");
+
      voice_modem_state = IDLE;
      return(OK);
      }
@@ -80,20 +131,115 @@
 static int V253modem_set_compression (int *compression, int *speed, int *bits)
      {
      char buffer[VOICE_BUF_LEN];
+     int Kompressionmethod = 1; /* a littlebit germinglish :-) */
      reset_watchdog();
 
-     if (*compression == 0)
-          *compression = 8;
-
+     switch (*compression)
+     {
+       case 0:
+       case 1:
+       case 8:
+       {
+          Kompressionmethod = 1;
+          *bits=8;
+          break;
+       }
+     /*  default is 8 Bit PCM/8 bit linear which should be supported by most modems
+         and be mapped to the V.253 defined AT+VSM=1 .
+         On the otherside the the compressionmodes from the Elsa.c
+         are mapped to the manufacturer specific +VSM values (above 127)
+         so voice files recorded with the &Elsa driver can be played with
+         this &V253modem driver (and the same modem of course) */
+       case 2:       /*  2bit ADPCM for some ELSA-modems */
+       {
+         *bits = 2;
+         if (voice_command("AT+VSM=140,7200", "OK")!= VMA_USER_1)
+         {
+         /* there are two diffrent implementations trying one first,
+            if this fails we try the other one later */
+           Kompressionmethod = 129;
+         }
+         *speed=7200;
+         break;
+        }
+       case 4:           /* 4bit ADPCM for some ELSA-modems */
+       {
+         if (voice_command("AT+VSM=141,7200", "OK")!= VMA_USER_1)
+         {
+         /* there are two diffrent implementations trying one first,
+            if this fails we try the other one later */
+
+           Kompressionmethod = 131;
+         }
+         *bits=4;
+         *speed=7200;
+         break;
+       }
+       case 5:
+       {
+         Kompressionmethod = 129;
+         *bits = 4;      /* 129 ->4bit ADPCM for the ML 56k Fun*/
+         break;
+       }
+       case 6:
+       {
+         Kompressionmethod = 131;
+         *bits = 8;      /* 8bit uLAW for the ML 56k Fun*/
+         *speed=8000;
+         break;
+       }
+       case 7:
+       {
+         Kompressionmethod = 132;
+         *bits = 8;      /* 8bit aLAW for the ML 56k Fun*/
+         *speed=8000;
+         break;
+       }
+       case 9:        /* ITU defined signed PCM */
+       {
+          Kompressionmethod = 0;
+          *bits=8;
+          break;
+       }
+       case 10:        /* ITU defined uLaw */
+       {
+          Kompressionmethod = 4;
+          *bits=8;
+          break;
+       }
+       case 11:        /* ITU defined aLaw */
+       {
+          Kompressionmethod = 5;
+          *bits=8;
+          break;
+       }
+
+
+       default:
+       {
+          lprintf(L_WARN, "compression method %d is not supported -> edit voice.conf",*compression);
+        /*  return(FAIL);  */
+          Kompressionmethod = 1;
+       }
+     }
      if (*speed == 0)
-          *speed = 8000;
-
-     sprintf(buffer, "AT+VSM=1,%d,8", *speed);
-     voice_command(buffer, "OK");   /* only no compression is common! */
-     *bits=8;
-     return(OK) ;
+          *speed = 8000; /* default value for the PCM voiceformat is 8000 */
 
+     sprintf(buffer, "AT+VSM=%d,%d",Kompressionmethod, *speed); /* only no compression is common! */
+       /* ATTENTION the AT+VSM=? output is diffrent from the AT+VSM=<Parameter> */
+     if (voice_command(buffer, "OK")!= VMA_USER_1)
+      {
+         lprintf(L_WARN, "can't set compression and speed");
+         /*return(FAIL);*/   /* when we don't say FAIL here,
+           the modem can still record the message with its
+           last/default compression-setting */
+         voice_command("AT+VSM?", "OK");
+         /* write the actual setting to the logfile */
+      }
 
+     lprintf(L_NOISE, "Just for info: port_speed should be greater than %d bps",(*bits)*(*speed)*10/8);
+     /* 8 Databits + 1 Stopbit +1 startbit, generel: (*bits)*(*speed)*9/8,  */
+     return(OK) ;
      }
 
 static int V253modem_set_device (int device)
@@ -104,29 +250,137 @@
           {
           case NO_DEVICE:
                lprintf(L_JUNK, "%s: _NO_DEV: (%d)", voice_modem_name, device);
-               voice_command("AT+VLS=0", "OK|VCON");
+               if (voice_command("AT+VLS=0", "OK|VCON")!= VMA_USER_1)   /* valid answer for +vls is only "OK" but to keep this more generic... */
+               {
+                 lprintf(L_WARN, "can't set No_Device");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
                return(OK);
           case DIALUP_LINE:
                lprintf(L_JUNK, "%s: _DIALUP: (%d)", voice_modem_name, device);
-               voice_command("AT+VLS=1", "OK");
+               if (voice_command("AT+VLS=1", "OK")!= VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set No_Device");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
                return(OK);
           case EXTERNAL_MICROPHONE:
-               voice_command("AT+VLS=11", "OK");
+               lprintf(L_JUNK, "%s: _External_Microphone: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=11", "OK")!= VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set External_Microphone");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
           case INTERNAL_MICROPHONE:
                lprintf(L_JUNK, "%s: _INT_MIC: (%d)", voice_modem_name, device);
-               voice_command("AT+VLS=6", "OK|VCON");
+               if (voice_command("AT+VLS=6", "OK|VCON")!= VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set Internal_Microphone");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
                return(OK);
           case INTERNAL_SPEAKER:
                lprintf(L_JUNK, "%s: _INT_SEAK: (%d)", voice_modem_name, device);
-               voice_command("AT+VLS=4", "OK|VCON");
+               if (voice_command("AT+VLS=4", "OK|VCON")!= VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set INTERNAL_SPEAKER");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+          case EXTERNAL_SPEAKER:
+               lprintf(L_JUNK, "%s: _EXTERNAL_SPEAKER: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=8", "OK|VCON")!= VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set External_SPEAKER");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+          case LOCAL_HANDSET :
+               lprintf(L_JUNK, "%s: _LOCAL_HANDSET: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=2", "OK|VCON") != VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set LOCAL_HANDSET");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+          case DIALUP_WITH_EXT_SPEAKER :
+               lprintf(L_JUNK, "%s: _DIALUP_WITH_EXT_SPEAKER: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=9", "OK|VCON") != VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set DIALUP_WITH_EXT_SPEAKER");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
                return(OK);
+
+
+          case DIALUP_WITH_INT_SPEAKER :
+               lprintf(L_JUNK, "%s: _DIALUP_WITH_INT_SPEAKER: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=5", "OK|VCON") != VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set DIALUP_WITH_INT_SPEAKER");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+
+          case DIALUP_WITH_LOCAL_HANDSET :
+               lprintf(L_JUNK, "%s: _DIALUP_WITH_LOCAL_HANDSET: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=3", "OK|VCON") != VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set DIALUP_WITH_LOCAL_HANDSET");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+
+          case DIALUP_WITH_EXTERNAL_MIC_AND_SPEAKER:
+               lprintf(L_JUNK, "%s: _DIALUP_WITH_EXTERNAL_MIC_AND_External_SPEAKER: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=13", "OK|VCON") != VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set DIALUP_WITH_EXTERNAL_MIC_AND_External_SPEAKER");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+
+          case DIALUP_WITH_INTERNAL_MIC_AND_SPEAKER:
+               lprintf(L_JUNK, "%s: _DIALUP_WITH_INTERNAL_MIC_AND_Internal_SPEAKER: (%d)", voice_modem_name, device);
+               if (voice_command("AT+VLS=7", "OK|VCON") != VMA_USER_1)
+               {
+                 lprintf(L_WARN, "can't set DIALUP_WITH_INTERNAL_MIC_AND_Internal_SPEAKER");
+                 /* I don't know what returnvalue should be used in this case of failure */
+               }
+               return(OK);
+
           }
 
      lprintf(L_WARN, "%s: Unknown device (%d)", voice_modem_name, device);
      return(FAIL);
      }
 
-static char V253modem_pick_phone_cmnd[] = "AT+FCLASS=8; AT+VLS=2";
+/* Only verifies the RMD name */
+#define V253modem_RMD_NAME "V253modem"
+#define ELSA_RMD_NAME "ELSA"
+int V253_check_rmd_adequation(char *rmd_name) {
+   /* We use hardware values so that this function can be
+    * inherited from 2864 too.
+    */
+   return !strncmp(rmd_name,
+                   V253modem_RMD_NAME,
+                   sizeof(V253modem_RMD_NAME))
+          || !strncmp(rmd_name,
+                      ELSA_RMD_NAME,
+                      sizeof(ELSA_RMD_NAME));
+}
+
+
+
+
+
+
+
+
+static char V253modem_pick_phone_cmnd[] = "AT+FCLASS=8";  /* because this will be followed by a
+                                                             V253modem_set_device (DIALUP_LINE)
+                                                             -> this picks up the line!*/
 static char V253modem_pick_phone_answr[] = "VCON|OK";
 
 
@@ -134,17 +388,12 @@
 static char V253modem_softflow_cmnd[] = "AT+IFC=1,1";
 
 static char V253modem_beep_cmnd[] = "AT+VTS=[%d,,%d]";
-/*static char V253modem_intr_play_answr[] = "OK|VCON";
-static char V253modem_stop_play_answr[] = "OK|VCON";
-
-static char V253modem_stop_rec_cmnd[] = "!";
-static char V253modem_stop_rec_answr[] = "OK|VCON"; */
 
 
 voice_modem_struct V253modem =
     {
     "V253 modem",
-    "V253modem",
+    V253modem_RMD_NAME,
      (char *) V253modem_pick_phone_cmnd,
      (char *) V253modem_pick_phone_answr,
      (char *) V253modem_beep_cmnd,
@@ -196,6 +445,6 @@
     &IS_101_voice_mode_on,
     &IS_101_wait,
     &IS_101_play_dtmf,
-    &IS_101_check_rmd_adequation,
+    &V253_check_rmd_adequation,
     0
     };
diff -urP mgetty-1.1.22/voice/libvoice/ZyXEL_Omni56K.c mgetty-current/voice/libvoice/ZyXEL_Omni56K.c
--- mgetty-1.1.22/voice/libvoice/ZyXEL_Omni56K.c	Thu Aug 10 22:33:45 2000
+++ mgetty-current/voice/libvoice/ZyXEL_Omni56K.c	Thu Nov 16 11:41:49 2000
@@ -6,7 +6,7 @@
  * Based on code for Elite 2864 modems (ZyXEL_2864.c), with
  * corrections made by Const Kaplinsky <const@ce.cctpu.edu.ru>
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -26,9 +26,11 @@
       * ATS40.4=1 - Enable distincitve ring type 2 (RING 1)
       * ATS40.5=1 - Enable distincitve ring type 3 (RING 2)
       * ATS40.6=1 - Enable distincitve ring type 4 (RING 3)
+      * MUST NOT send spaces in between ATS... commands, otherwise
+      * all but the first are ignored (Richard L. Hamilton)
       */
 
-     if (voice_command("ATS40.3=1 S40.4=1 S40.5=1 S40.6=1", "OK") !=
+     if (voice_command("ATS40.3=1S40.4=1S40.5=1S40.6=1", "OK") !=
       VMA_USER_1)
           lprintf(L_WARN, "couldn't initialize distinctive RING");
 
diff -urP mgetty-1.1.22/voice/libvoice/detect.c mgetty-current/voice/libvoice/detect.c
--- mgetty-1.1.22/voice/libvoice/detect.c	Tue Aug 15 10:51:59 2000
+++ mgetty-current/voice/libvoice/detect.c	Thu Nov 16 11:41:49 2000
@@ -3,7 +3,7 @@
  *
  * autodetect the modemtype we are connected to.
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -44,9 +44,9 @@
      {"ELS", "8550", &V253modem, "ELSA (coming soon...)" },
      {NULL, NULL, NULL}
      };
- 
-
+     
 const char ati[] = "ATI";
+const char ati3[] = "ATI3";
 const char ati6[] = "ATI6";
 const char ati4[] = "ATI4";
 const char ati9[] = "ATI9";
@@ -55,6 +55,8 @@
 
 static const struct modem_type_struct modem_database[] =
      {
+     {ati, "TP560 Data/Fax/Voice 56K Modem",
+                                   NULL, &Multitech_5634ZBAV},
      {ati, "1.04",                 NULL,   &Cirrus_Logic},
      {ati, "144",                  NULL,   &UMC},
      {ati, "144 VOICE",            NULL,   &Rockwell},
@@ -243,13 +245,66 @@
          	 return(OK);
          	}
 
-          cmnd = (char *) ati;
+          /* Detection using identification strings. Seems that it
+           * is required for some very specific modem types.
+           * -- (Rojhalat Ibrahim, roschi@ribrahim.de)
+           * IMPLEMENTATION NOTES
+           *    - We used to have a complicated ATI3 scheme with a table
+           *      which was wrong (every added entry to the table would have
+           *      consumed more lines of the modem output when a second
+           *      line was required; would cause timeouts on modems returning
+           *      less than 3 lines). We have simplified that.
+           * BUGS
+           *    - This implementation, although less likely to cause problems,
+           *      will make detection longer (timeout) on modems returning
+           *      something different than OK or ERROR, when they return
+           *      less than 2 lines (case significative).
+           */
+	  
+	  cmnd = (char *) ati3;
+	  if (voice_command(cmnd, "") != OK) {
+             lprintf(L_WARN, "modem detection failed");
+             exit(FAIL);
+          }
 
-          if (voice_command(cmnd, "") != OK)
-               {
-               lprintf(L_WARN, "modem detection failed");
-               exit(FAIL);
-               }
+          if (voice_read(buffer) != OK) {
+             lprintf(L_WARN, "modem detection failed");
+             exit(FAIL);
+          }
+
+          if ((strstr(buffer, "OK") == NULL)
+              && (strstr(buffer, "ERROR") == NULL)) {
+             /* The non-empty string wasn't OK/ERROR, so let's ignore it and
+              * go to the next line (that we assume exists -- else will
+              * timeout but recover).
+              */
+             if (voice_read(buffer) == OK) {
+                if (strstr(buffer, "SupraExpress 56e PRO")) {
+                   voice_modem = &Supra56ePRO;
+                }
+             }
+          }
+          /* else the modem already returned OK/ERROR, so no need to create
+           * a timeout.
+           */
+
+          /* Flush remaining data. We can't read, might not be there,
+           * and that would timeout, too.
+           */
+          voice_flush(1); /* wait until no chars and 100 ms have passed */
+
+          if (voice_modem != &no_modem) {
+             lprintf(L_MESG, "%s detected", voice_modem->name);
+             lprintf(L_NOISE, "voice modem type was set by using \
+                              identification strings");
+             return(OK);
+          }
+
+          cmnd = (char *) ati;
+          if (voice_command(cmnd, "") != OK) {
+             lprintf(L_WARN, "modem detection failed");
+             exit(FAIL);
+          }
 
           do
                {
diff -urP mgetty-1.1.22/voice/pvftools/pvftormd.c mgetty-current/voice/pvftools/pvftormd.c
--- mgetty-1.1.22/voice/pvftools/pvftormd.c	Thu Aug 10 22:37:23 2000
+++ mgetty-current/voice/pvftools/pvftormd.c	Thu Nov 16 11:41:51 2000
@@ -4,7 +4,7 @@
  * pvftormd converts from the pvf (portable voice format) format to the
  * rmd (raw modem data) format.
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -506,7 +506,8 @@
      if ((strcmp(modem_type, "US Robotics") == 0) && ((compression == 1) ||
          (compression == 4)))
           {
-          header_out.bits = compression;
+          if(compression == 1) header_out.bits = 8;
+          else header_out.bits = 4;
 
           if (write_rmd_header(fd_out, &header_out) != OK)
                {
diff -urP mgetty-1.1.22/voice/pvftools/rmdtopvf.c mgetty-current/voice/pvftools/rmdtopvf.c
--- mgetty-1.1.22/voice/pvftools/rmdtopvf.c	Thu Aug 10 22:37:24 2000
+++ mgetty-current/voice/pvftools/rmdtopvf.c	Thu Nov 16 11:41:51 2000
@@ -4,7 +4,7 @@
  * rmdtopvf converts from the rmd (raw modem data) format to the pvf
  * (portable voice format) format.
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -38,7 +38,10 @@
      fprintf(stderr, " - Multitech 2834 4 bit IMA ADPCM\n");
      fprintf(stderr, " - Rockwell       2, 3 and 4 bit Rockwell ADPCM\n");
      fprintf(stderr, " - Rockwell       8 bit Rockwell PCM\n");
-     fprintf(stderr, " - V253modem      8 bit PCM\n");
+     fprintf(stderr, " - V253modem      8 bit unsigned PCM\n");
+     fprintf(stderr, " - V253modem      8 bit signed PCM\n");
+     fprintf(stderr, " - V253modem      4 bit IMA ADPCM\n");
+     fprintf(stderr, " - V253modem      2 and 4 bit Rockwell ADPCM\n");
      fprintf(stderr, " - UMC            4 (G.721 ADPCM)\n");
      fprintf(stderr, " - US Robotics    1 and 4 (GSM and G.721 ADPCM)\n");
      fprintf(stderr, " - ZyXEL 1496     2, 3 and 4 bit ZyXEL ADPCM\n");
@@ -188,8 +191,44 @@
 
      if (strcmp(modem_type, "V253modem")==0)
 	{
-          if (lintopvf(fd_in, fd_out, &header_out, 0, 0, 0) == OK)
+          switch(compression)
+          {
+          case 0:
+          case 1:
+          case 8:
+            if (lintopvf(fd_in, fd_out, &header_out, 0, 0, 0) == OK)
+               exit(OK);
+            else exit(FAIL);
+          case 9:
+            if (lintopvf(fd_in, fd_out, &header_out, 1, 0, 0) == OK)   /* signed linear */
+               exit(OK);
+            else exit(FAIL);
+
+          case 2:
+          case 4:
+            if (rockwelltopvf(fd_in, fd_out, compression, &header_out) == OK)   /* the &Elsa compatible formats */
                exit(OK);
+            else exit(FAIL);
+
+          case 5:
+            if (imaadpcmtopvf(fd_in, fd_out, &header_out) == OK)
+               exit(OK);
+            else exit(FAIL);
+          case 6:   /* please add here uLaw or mu-Law (thats what Zyxel calls this) */
+          case 10:  /* please add here uLaw or mu-Law (thats what Zyxel calls this) */
+             fprintf(stderr, "here should be support for u-Law logarithmic see sox -U \n");
+             break;
+
+          case 7:
+          case 11:  /* please add here aLaw */
+             fprintf(stderr, "here should be support for a-Law logarithmic see sox -A \n");
+             break;
+
+          default:
+            fprintf(stderr, "%s: Unsupported compression method (%s/%d)\n",
+              program_name, modem_type, compression);
+            exit(FAIL);
+          }
         }
 
      if (((strcmp(modem_type, "Rockwell") == 0 && compression != 8) ||
diff -urP mgetty-1.1.22/voice/vgetty/answer.c mgetty-current/voice/vgetty/answer.c
--- mgetty-1.1.22/voice/vgetty/answer.c	Tue Jul  4 20:56:25 2000
+++ mgetty-current/voice/vgetty/answer.c	Thu Nov 16 11:41:51 2000
@@ -1,7 +1,7 @@
 /*
  * answer.c
  *
- * $Id$
+ * $Id$
  *
  */
 
@@ -207,11 +207,12 @@
      char greeting_message[VOICE_BUF_LEN];
      char receive_dir[VOICE_BUF_LEN];
      char message[VOICE_BUF_LEN];
-     char message_name[VOICE_BUF_LEN] = "vXXXXXX";
+     char message_name[VOICE_BUF_LEN];
      char *ring_type = "ring";
      int i, j;
      int result;
      char c;
+     pid_t pid = getpid();
 
      setup_environment(); /* caller ID, called ID and stuff */
 
@@ -284,15 +285,46 @@
        }
      }
 
-     if ((result = voice_answer_phone()) == VMA_CONNECT)
-          {
-          voice_restore_signal_handler();
-          tio_set(voice_fd, &tio_save);
-          return(VMA_CONNECT);
-          }
+     result = voice_answer_phone();
+     switch (result) {
+        case VMA_OK:
+           /* VOICE */
+           break;
+        case VMA_CONNECT:
+           /* DATA */
+        case VMA_FCON:
+           /* FAX */
+        case VMA_FAX:
+        case VMA_FCO:
+           voice_restore_signal_handler();
+           tio_set(voice_fd, &tio_save);
+           return result;
+           break;
+        default:
+           lprintf(L_WARN, "%s: Could not answer the phone. Strange...",
+                           program_name);
+           exit(99);
+           break;
+     }
 
      make_path(receive_dir, cvd.voice_dir.d.p, cvd.receive_dir.d.p);
-     mktemp(message_name);
+
+     /* The file name is made from "v", then the pid, then the
+      * time_t, then the possible CallerId, plus separators.
+      * The caller-ID is truncated at 16 characters.
+      * NOTES
+      *    - On system not supporting standard file names (e.g. 14-characters
+      *      sysvfs), only the pid will be used.
+      */
+
+#ifdef SHORT_FILENAMES
+     sprintf(message_name, "v%u",
+             pid);
+#else /* !SHORT_FILENAMES */
+     sprintf(message_name, "v-%u-%u",
+             pid,
+             (unsigned int) time(NULL));
+#endif /* !SHORT_FILENAMES */
 
 #ifndef SHORT_FILENAMES
      /* Include caller ID string in the file name */
@@ -327,13 +359,6 @@
 	   exit(99);
 	 }
      }
-
-     if (result == VMA_ERROR)
-          {
-          lprintf(L_WARN, "%s: Could not answer the phone. Strange...",
-           program_name);
-          exit(99);
-          }
 
      if (strlen(cvd.call_program.d.p) != 0)
           {
diff -urP mgetty-1.1.22/voice/voice.conf-dist mgetty-current/voice/voice.conf-dist
--- mgetty-1.1.22/voice/voice.conf-dist	Tue Jul  4 20:56:22 2000
+++ mgetty-current/voice/voice.conf-dist	Thu Nov 16 11:41:45 2000
@@ -2,7 +2,7 @@
 # Sample voice configuration file
 # -------------------------------
 #
-# $Id$
+# $Id$
 #
 # This file is read twice: First the program configuration is read and
 # second the port configuration. This means that generic values at the
@@ -94,6 +94,10 @@
 # mode used. Note that this is an integer, not one of the Bxxxx defines.
 # Basically you should select the highest possible speed your modem and
 # computer support. The default value is 38400.
+#
+# WARNING: if you use vgetty, this MUST be the same value as the
+#          setting of "speed <n>" in mgetty.config.  If you change one,
+#          change the other one as well!
 #
 
 port_speed 38400
